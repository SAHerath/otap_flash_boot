   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:stk500boot.c  **** License:   GNU General Public License
   8:stk500boot.c  **** 
   9:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:stk500boot.c  **** Date:      17 October 2007
  11:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:stk500boot.c  **** Compiler:  WINAVR20060421
  13:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  14:stk500boot.c  **** 
  15:stk500boot.c  **** DESCRIPTION:
  16:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  17:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  18:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  19:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  20:stk500boot.c  ****     "reset" vector in Application area.
  21:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  22:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  23:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  24:stk500boot.c  **** 
  25:stk500boot.c  **** USAGE:
  26:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  27:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  28:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  29:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  30:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  31:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  32:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  33:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  34:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  35:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  36:stk500boot.c  ****     - AVRISP will detect the bootloader
  37:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  38:stk500boot.c  **** 
  39:stk500boot.c  **** Note:
  40:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  41:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  42:stk500boot.c  ****     Flash is always erased before programming.
  43:stk500boot.c  **** 
  44:stk500boot.c  **** 	AVRdude:
  45:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  46:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  47:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  48:stk500boot.c  **** 
  49:stk500boot.c  **** NOTES:
  50:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  51:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  52:stk500boot.c  **** 
  53:stk500boot.c  **** LICENSE:
  54:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  55:stk500boot.c  **** 
  56:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  57:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  58:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  59:stk500boot.c  ****     any later version.
  60:stk500boot.c  **** 
  61:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  62:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  63:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  64:stk500boot.c  ****     GNU General Public License for more details.
  65:stk500boot.c  **** 
  66:stk500boot.c  **** *****************************************************************************/
  67:stk500boot.c  **** 
  68:stk500boot.c  **** //************************************************************************
  69:stk500boot.c  **** //*	Edit History
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  74:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  76:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  78:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  79:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  80:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  81:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  82:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  83:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  84:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  86:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  89:stk500boot.c  **** //************************************************************************
  90:stk500boot.c  **** 
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** 
 115:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 116:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 117:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 118:stk500boot.c  **** 	#define		ENABLE_MONITOR
 119:stk500boot.c  **** 	static void	RunMonitor(void);
 120:stk500boot.c  **** #endif
 121:stk500boot.c  **** 
 122:stk500boot.c  **** #ifndef EEWE
 123:stk500boot.c  **** 	#define EEWE    1
 124:stk500boot.c  **** #endif
 125:stk500boot.c  **** #ifndef EEMWE
 126:stk500boot.c  **** 	#define EEMWE   2
 127:stk500boot.c  **** #endif
 128:stk500boot.c  **** 
 129:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 130:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 131:stk500boot.c  **** 
 132:stk500boot.c  **** 
 133:stk500boot.c  **** /*
 134:stk500boot.c  ****  * Uncomment the following lines to save code space
 135:stk500boot.c  ****  */
 136:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 137:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 138:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 139:stk500boot.c  **** //
 140:stk500boot.c  **** 
 141:stk500boot.c  **** 
 142:stk500boot.c  **** 
 143:stk500boot.c  **** //************************************************************************
 144:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 145:stk500boot.c  **** //*	indicates that bootloader is active
 146:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 149:stk500boot.c  **** 
 150:stk500boot.c  **** #ifdef _MEGA_BOARD_
 151:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 152:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 153:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 154:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 155:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 156:stk500boot.c  **** 	//*	onbarod led is PORTE4
 157:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 158:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 159:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 160:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 161:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 162:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 163:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 164:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 165:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 166:stk500boot.c  **** #elif defined( _PENGUINO_ )
 167:stk500boot.c  **** 	//*	this is for the Penguino
 168:stk500boot.c  **** 	//*	onbarod led is PORTE4
 169:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 170:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 171:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 172:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 173:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 174:stk500boot.c  **** 	//*	onbarod led is PORTE4
 175:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 176:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 177:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 178:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 179:stk500boot.c  **** 	//*	onbarod led is PORTA7
 180:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 181:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 182:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 183:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 184:stk500boot.c  **** 
 185:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 186:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 187:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 188:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 189:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 190:stk500boot.c  **** 
 191:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 192:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 193:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 194:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 195:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 196:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 197:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 198:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 199:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 200:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 201:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 202:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 203:stk500boot.c  **** #elif defined( _AVRLIP_ )
 204:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 205:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 206:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 207:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 208:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 209:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 210:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 211:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 212:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 213:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 214:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 215:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 216:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 217:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 218:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 219:stk500boot.c  **** #else
 220:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 221:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 222:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 223:stk500boot.c  **** #endif
 224:stk500boot.c  **** 
 225:stk500boot.c  **** 
 226:stk500boot.c  **** 
 227:stk500boot.c  **** /*
 228:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 229:stk500boot.c  ****  */
 230:stk500boot.c  **** #ifndef F_CPU
 231:stk500boot.c  **** 	#define F_CPU 16000000UL
 232:stk500boot.c  **** #endif
 233:stk500boot.c  **** 
 234:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 235:stk500boot.c  **** /*
 236:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 237:stk500boot.c  ****  */
 238:stk500boot.c  **** 
 239:stk500boot.c  **** #ifndef BAUDRATE
 240:stk500boot.c  **** 	#define BAUDRATE 115200
 241:stk500boot.c  **** #endif
 242:stk500boot.c  **** 
 243:stk500boot.c  **** /*
 244:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 245:stk500boot.c  ****  */
 246:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 247:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 248:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 249:stk500boot.c  **** 	#else
 250:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 251:stk500boot.c  **** 	#endif
 252:stk500boot.c  **** #endif
 253:stk500boot.c  **** 
 254:stk500boot.c  **** /*
 255:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 256:stk500boot.c  ****  */
 257:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 258:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 259:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 260:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 261:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 262:stk500boot.c  **** 
 263:stk500boot.c  **** /*
 264:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 265:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 266:stk500boot.c  ****  */
 267:stk500boot.c  **** //#define BOOTSIZE 1024
 268:stk500boot.c  **** #if FLASHEND > 0x0F000
 269:stk500boot.c  **** 	#define BOOTSIZE 8192
 270:stk500boot.c  **** #else
 271:stk500boot.c  **** 	#define BOOTSIZE 2048
 272:stk500boot.c  **** #endif
 273:stk500boot.c  **** 
 274:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 275:stk500boot.c  **** 
 276:stk500boot.c  **** /*
 277:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 278:stk500boot.c  ****  */
 279:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 280:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 281:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 282:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 283:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 284:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 285:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 286:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 287:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 288:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 289:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 290:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 291:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 292:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 293:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 295:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 297:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 299:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 301:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 303:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 305:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 307:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 308:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 309:stk500boot.c  **** #else
 310:stk500boot.c  **** 	#error "no signature definition for MCU available"
 311:stk500boot.c  **** #endif
 312:stk500boot.c  **** 
 313:stk500boot.c  **** 
 314:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 315:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 316:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 317:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 318:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 319:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 320:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 321:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 322:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 323:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 324:stk500boot.c  **** 
 325:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 326:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 327:stk500boot.c  **** 	/* ATMega8 with one USART */
 328:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 329:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 330:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 331:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 332:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 333:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 334:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 335:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 336:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 337:stk500boot.c  **** 
 338:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 339:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 340:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 341:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 342:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 343:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 344:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 345:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 346:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 347:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 348:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 349:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 350:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 351:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 352:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 353:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 354:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 355:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 356:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 357:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 358:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 359:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 360:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 361:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 362:stk500boot.c  **** 	//* catch all
 363:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 364:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 365:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 366:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 367:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 368:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 369:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 370:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 371:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 372:stk500boot.c  **** #else
 373:stk500boot.c  **** 	#error "no UART definition for MCU available"
 374:stk500boot.c  **** #endif
 375:stk500boot.c  **** 
 376:stk500boot.c  **** 
 377:stk500boot.c  **** 
 378:stk500boot.c  **** /*
 379:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 380:stk500boot.c  ****  */
 381:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 382:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 383:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 384:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 385:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 386:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 387:stk500boot.c  **** #else
 388:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 389:stk500boot.c  **** #endif
 390:stk500boot.c  **** 
 391:stk500boot.c  **** 
 392:stk500boot.c  **** /*
 393:stk500boot.c  ****  * States used in the receive state machine
 394:stk500boot.c  ****  */
 395:stk500boot.c  **** #define	ST_START		0
 396:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 397:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 398:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 399:stk500boot.c  **** #define ST_GET_TOKEN	4
 400:stk500boot.c  **** #define ST_GET_DATA		5
 401:stk500boot.c  **** #define	ST_GET_CHECK	6
 402:stk500boot.c  **** #define	ST_PROCESS		7
 403:stk500boot.c  **** 
 404:stk500boot.c  **** /*
 405:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 406:stk500boot.c  ****  */
 407:stk500boot.c  **** #if defined(RAMPZ)
 408:stk500boot.c  **** 	typedef uint32_t address_t;
 409:stk500boot.c  **** #else
 410:stk500boot.c  **** 	typedef uint16_t address_t;
 411:stk500boot.c  **** #endif
 412:stk500boot.c  **** 
 413:stk500boot.c  **** /*
 414:stk500boot.c  ****  * function prototypes
 415:stk500boot.c  ****  */
 416:stk500boot.c  **** static void sendchar(char c);
 417:stk500boot.c  **** static unsigned char recchar(void);
 418:stk500boot.c  **** 
 419:stk500boot.c  **** /*
 420:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 421:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 422:stk500boot.c  ****  */
 423:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 424:stk500boot.c  **** #include <avr/sfr_defs.h>
 425:stk500boot.c  **** 
 426:stk500boot.c  **** //#define	SPH_REG	0x3E
 427:stk500boot.c  **** //#define	SPL_REG	0x3D
 428:stk500boot.c  **** 
 429:stk500boot.c  **** //*****************************************************************************
 430:stk500boot.c  **** void __jumpMain(void)
 431:stk500boot.c  **** {
 432:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 433:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 434:stk500boot.c  **** 
 435:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 436:stk500boot.c  **** 
 437:stk500boot.c  **** //*	set stack pointer to top of RAM
 438:stk500boot.c  **** 
 439:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 440:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 441:stk500boot.c  **** 
 442:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 443:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 444:stk500boot.c  **** 
 445:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 446:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 447:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 448:stk500boot.c  **** }
 449:stk500boot.c  **** 
 450:stk500boot.c  **** 
 451:stk500boot.c  **** //*****************************************************************************
 452:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 453:stk500boot.c  **** {
 454:stk500boot.c  **** 	unsigned int i;
 455:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 456:stk500boot.c  **** 	{
 457:stk500boot.c  **** 		_delay_ms(0.5);
 458:stk500boot.c  **** 	}
 459:stk500boot.c  **** }
 460:stk500boot.c  **** 
 461:stk500boot.c  **** 
 462:stk500boot.c  **** //*****************************************************************************
 463:stk500boot.c  **** /*
 464:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 465:stk500boot.c  ****  */
 466:stk500boot.c  **** static void sendchar(char c)
 467:stk500boot.c  **** {
  15               		.loc 1 467 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 468:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 468 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 469:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 469 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 470:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 470 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE13:
  39               		.section	.text.unlikely,"ax",@progbits
  41               	recchar:
  42               	.LFB15:
 471:stk500boot.c  **** }
 472:stk500boot.c  **** 
 473:stk500boot.c  **** 
 474:stk500boot.c  **** //************************************************************************
 475:stk500boot.c  **** static int	Serial_Available(void)
 476:stk500boot.c  **** {
 477:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 478:stk500boot.c  **** }
 479:stk500boot.c  **** 
 480:stk500boot.c  **** 
 481:stk500boot.c  **** //*****************************************************************************
 482:stk500boot.c  **** /*
 483:stk500boot.c  ****  * Read single byte from USART, block if no data available
 484:stk500boot.c  ****  */
 485:stk500boot.c  **** static unsigned char recchar(void)
 486:stk500boot.c  **** {
  43               		.loc 1 486 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49               	.L7:
 487:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  50               		.loc 1 487 0 discriminator 1
  51 0000 8091 C000 		lds r24,192
  52 0004 87FF      		sbrs r24,7
  53 0006 00C0      		rjmp .L7
 488:stk500boot.c  **** 	{
 489:stk500boot.c  **** 		// wait for data
 490:stk500boot.c  **** 	}
 491:stk500boot.c  **** 	return UART_DATA_REG;
  54               		.loc 1 491 0
  55 0008 8091 C600 		lds r24,198
 492:stk500boot.c  **** }
  56               		.loc 1 492 0
  57 000c 0895      		ret
  58               		.cfi_endproc
  59               	.LFE15:
  61               		.section	.init9,"ax",@progbits
  62               	.global	__jumpMain
  64               	__jumpMain:
  65               	.LFB11:
 431:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  66               		.loc 1 431 0
  67               		.cfi_startproc
  68               	/* prologue: naked */
  69               	/* frame size = 0 */
  70               	/* stack size = 0 */
  71               	.L__stack_usage = 0
 435:stk500boot.c  **** 
  72               		.loc 1 435 0
  73               	/* #APP */
  74               	 ;  435 "stk500boot.c" 1
  75               		.set __stack, 8703
  76               	 ;  0 "" 2
 439:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  77               		.loc 1 439 0
  78               	 ;  439 "stk500boot.c" 1
  79 0000 01E2      		ldi	16, 33
  80               	 ;  0 "" 2
 440:stk500boot.c  **** 
  81               		.loc 1 440 0
  82               	 ;  440 "stk500boot.c" 1
  83 0002 0EBF      		out 62,16
  84               	 ;  0 "" 2
 442:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  85               		.loc 1 442 0
  86               	 ;  442 "stk500boot.c" 1
  87 0004 0FEF      		ldi	16, 255
  88               	 ;  0 "" 2
 443:stk500boot.c  **** 
  89               		.loc 1 443 0
  90               	 ;  443 "stk500boot.c" 1
  91 0006 0DBF      		out 61,16
  92               	 ;  0 "" 2
 445:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  93               		.loc 1 445 0
  94               	 ;  445 "stk500boot.c" 1
  95 0008 1124      		clr __zero_reg__
  96               	 ;  0 "" 2
 446:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
  97               		.loc 1 446 0
  98               	 ;  446 "stk500boot.c" 1
  99 000a 1FBE      		out 63, __zero_reg__
 100               	 ;  0 "" 2
 447:stk500boot.c  **** }
 101               		.loc 1 447 0
 102               	 ;  447 "stk500boot.c" 1
 103 000c 0C94 0000 		jmp main
 104               	 ;  0 "" 2
 105               	/* epilogue start */
 448:stk500boot.c  **** 
 106               		.loc 1 448 0
 107               	/* #NOAPP */
 108               		.cfi_endproc
 109               	.LFE11:
 111               		.text
 112               	.global	delay_ms
 114               	delay_ms:
 115               	.LFB12:
 453:stk500boot.c  **** 	unsigned int i;
 116               		.loc 1 453 0
 117               		.cfi_startproc
 118               	.LVL3:
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 455:stk500boot.c  **** 	{
 123               		.loc 1 455 0
 124 0018 20E0      		ldi r18,0
 125 001a 30E0      		ldi r19,0
 126               	.LVL4:
 127               	.L11:
 455:stk500boot.c  **** 	{
 128               		.loc 1 455 0 is_stmt 0 discriminator 1
 129 001c 2817      		cp r18,r24
 130 001e 3907      		cpc r19,r25
 131 0020 01F0      		breq .L13
 132               	.LVL5:
 133               	.LBB77:
 134               	.LBB78:
 135               		.file 2 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ut
   1:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 136               		.loc 2 187 0 is_stmt 1
 137 0022 EFEC      		ldi r30,lo8(1999)
 138 0024 F7E0      		ldi r31,hi8(1999)
 139 0026 3197      	1:	sbiw r30,1
 140 0028 01F4      		brne 1b
 141 002a 00C0      		rjmp .
 142 002c 0000      		nop
 143               	.LVL6:
 144               	.LBE78:
 145               	.LBE77:
 455:stk500boot.c  **** 	{
 146               		.loc 1 455 0
 147 002e 2F5F      		subi r18,-1
 148 0030 3F4F      		sbci r19,-1
 149               	.LVL7:
 150 0032 00C0      		rjmp .L11
 151               	.L13:
 152               	/* epilogue start */
 459:stk500boot.c  **** 
 153               		.loc 1 459 0
 154 0034 0895      		ret
 155               		.cfi_endproc
 156               	.LFE12:
 158               	.global	PrintFromPROGMEM
 160               	PrintFromPROGMEM:
 161               	.LFB18:
 493:stk500boot.c  **** 
 494:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 495:stk500boot.c  **** //*****************************************************************************
 496:stk500boot.c  **** static unsigned char recchar_timeout(void)
 497:stk500boot.c  **** {
 498:stk500boot.c  **** uint32_t count = 0;
 499:stk500boot.c  **** 
 500:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 501:stk500boot.c  **** 	{
 502:stk500boot.c  **** 		// wait for data
 503:stk500boot.c  **** 		count++;
 504:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 505:stk500boot.c  **** 		{
 506:stk500boot.c  **** 		unsigned int	data;
 507:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 508:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 509:stk500boot.c  **** 		#else
 510:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 511:stk500boot.c  **** 		#endif
 512:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 513:stk500boot.c  **** 			{
 514:stk500boot.c  **** 				asm volatile(
 515:stk500boot.c  **** 						"clr	r30		\n\t"
 516:stk500boot.c  **** 						"clr	r31		\n\t"
 517:stk500boot.c  **** 						"ijmp	\n\t"
 518:stk500boot.c  **** 						);
 519:stk500boot.c  **** 			}
 520:stk500boot.c  **** 			count	=	0;
 521:stk500boot.c  **** 		}
 522:stk500boot.c  **** 	}
 523:stk500boot.c  **** 	return UART_DATA_REG;
 524:stk500boot.c  **** }
 525:stk500boot.c  **** 
 526:stk500boot.c  **** //*	for watch dog timer startup
 527:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 528:stk500boot.c  **** 
 529:stk500boot.c  **** 
 530:stk500boot.c  **** //*****************************************************************************
 531:stk500boot.c  **** int main(void)
 532:stk500boot.c  **** {
 533:stk500boot.c  **** 	address_t		address			=	0;
 534:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 535:stk500boot.c  **** 	unsigned char	msgParseState;
 536:stk500boot.c  **** 	unsigned int	ii				=	0;
 537:stk500boot.c  **** 	unsigned char	checksum		=	0;
 538:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 539:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 540:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 541:stk500boot.c  **** 	unsigned char	c, *p;
 542:stk500boot.c  **** 	unsigned char   isLeave = 0;
 543:stk500boot.c  **** 
 544:stk500boot.c  **** 	unsigned long	boot_timeout;
 545:stk500boot.c  **** 	unsigned long	boot_timer;
 546:stk500boot.c  **** 	unsigned int	boot_state;
 547:stk500boot.c  **** #ifdef ENABLE_MONITOR
 548:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 549:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 550:stk500boot.c  **** #endif
 551:stk500boot.c  **** 
 552:stk500boot.c  **** 	//*	some chips dont set the stack properly
 553:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 554:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 555:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 556:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 557:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 558:stk500boot.c  **** 
 559:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 560:stk500boot.c  **** 	//************************************************************************
 561:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 562:stk500boot.c  **** 	//*	handle the watch dog timer
 563:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 564:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 565:stk500boot.c  **** 
 566:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 567:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 568:stk500boot.c  **** 	
 569:stk500boot.c  **** 	/*MCUSR	=	0;*/
 570:stk500boot.c  **** 	MCUSR &= ~(1<<WDRF);
 571:stk500boot.c  **** 	
 572:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 573:stk500boot.c  **** 	WDTCSR	=	0;
 574:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 575:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 576:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 577:stk500boot.c  **** 	{
 578:stk500boot.c  **** 		app_start();
 579:stk500boot.c  **** 	}
 580:stk500boot.c  **** 	//************************************************************************
 581:stk500boot.c  **** #endif
 582:stk500boot.c  **** 
 583:stk500boot.c  **** 
 584:stk500boot.c  **** 	boot_timer	=	0;
 585:stk500boot.c  **** 	boot_state	=	0;
 586:stk500boot.c  **** 
 587:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 588:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 589:stk500boot.c  **** //	boot_timeout	=	170000;
 590:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 591:stk500boot.c  **** #else
 592:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 593:stk500boot.c  **** #endif
 594:stk500boot.c  **** 	/*
 595:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 596:stk500boot.c  **** 	 */
 597:stk500boot.c  **** 
 598:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 599:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 600:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 601:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 602:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 603:stk500boot.c  **** 
 604:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 605:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 606:stk500boot.c  **** 	{
 607:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 608:stk500boot.c  **** 		delay_ms(100);
 609:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 610:stk500boot.c  **** 		delay_ms(100);
 611:stk500boot.c  **** 	}
 612:stk500boot.c  **** #endif
 613:stk500boot.c  **** 
 614:stk500boot.c  **** #endif
 615:stk500boot.c  **** 	/*
 616:stk500boot.c  **** 	 * Init UART
 617:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 618:stk500boot.c  **** 	 */
 619:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 620:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 621:stk500boot.c  **** #endif
 622:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 623:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 624:stk500boot.c  **** 
 625:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 626:stk500boot.c  **** 
 627:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 628:stk500boot.c  **** //	delay_ms(500);
 629:stk500boot.c  **** 
 630:stk500boot.c  **** 	sendchar('s');
 631:stk500boot.c  **** 	sendchar('t');
 632:stk500boot.c  **** 	sendchar('k');
 633:stk500boot.c  **** //	sendchar('5');
 634:stk500boot.c  **** //	sendchar('0');
 635:stk500boot.c  **** //	sendchar('0');
 636:stk500boot.c  **** 	sendchar('v');
 637:stk500boot.c  **** 	sendchar('2');
 638:stk500boot.c  **** 	sendchar(0x0d);
 639:stk500boot.c  **** 	sendchar(0x0a);
 640:stk500boot.c  **** 
 641:stk500boot.c  **** 	delay_ms(100);
 642:stk500boot.c  **** #endif
 643:stk500boot.c  **** 
 644:stk500boot.c  **** 	while (boot_state==0)
 645:stk500boot.c  **** 	{
 646:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 647:stk500boot.c  **** 		{
 648:stk500boot.c  **** 			_delay_ms(0.001);
 649:stk500boot.c  **** 			boot_timer++;
 650:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 651:stk500boot.c  **** 			{
 652:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 653:stk500boot.c  **** 			}
 654:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 655:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 656:stk500boot.c  **** 			{
 657:stk500boot.c  **** 				//*	toggle the LED
 658:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 659:stk500boot.c  **** 			}
 660:stk500boot.c  **** 		#endif
 661:stk500boot.c  **** 		}
 662:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 663:stk500boot.c  **** 	}
 664:stk500boot.c  **** 
 665:stk500boot.c  **** 
 666:stk500boot.c  **** 	if (boot_state==1)
 667:stk500boot.c  **** 	{
 668:stk500boot.c  **** 		//*	main loop
 669:stk500boot.c  **** 		while (!isLeave)
 670:stk500boot.c  **** 		{
 671:stk500boot.c  **** 			/*
 672:stk500boot.c  **** 			 * Collect received bytes to a complete message
 673:stk500boot.c  **** 			 */
 674:stk500boot.c  **** 			msgParseState	=	ST_START;
 675:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 676:stk500boot.c  **** 			{
 677:stk500boot.c  **** 				if (boot_state==1)
 678:stk500boot.c  **** 				{
 679:stk500boot.c  **** 					boot_state	=	0;
 680:stk500boot.c  **** 					c			=	UART_DATA_REG;
 681:stk500boot.c  **** 				}
 682:stk500boot.c  **** 				else
 683:stk500boot.c  **** 				{
 684:stk500boot.c  **** 				//	c	=	recchar();
 685:stk500boot.c  **** 					c	=	recchar_timeout();
 686:stk500boot.c  **** 					
 687:stk500boot.c  **** 				}
 688:stk500boot.c  **** 
 689:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 690:stk500boot.c  **** 				rcvdCharCntr++;
 691:stk500boot.c  **** 
 692:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 693:stk500boot.c  **** 				{
 694:stk500boot.c  **** 					exPointCntr++;
 695:stk500boot.c  **** 					if (exPointCntr == 3)
 696:stk500boot.c  **** 					{
 697:stk500boot.c  **** 						RunMonitor();
 698:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 699:stk500boot.c  **** 						isLeave			=	1;
 700:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 701:stk500boot.c  **** 						break;
 702:stk500boot.c  **** 					}
 703:stk500boot.c  **** 				}
 704:stk500boot.c  **** 				else
 705:stk500boot.c  **** 				{
 706:stk500boot.c  **** 					exPointCntr	=	0;
 707:stk500boot.c  **** 				}
 708:stk500boot.c  **** 			#endif
 709:stk500boot.c  **** 
 710:stk500boot.c  **** 				switch (msgParseState)
 711:stk500boot.c  **** 				{
 712:stk500boot.c  **** 					case ST_START:
 713:stk500boot.c  **** 						if ( c == MESSAGE_START )
 714:stk500boot.c  **** 						{
 715:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 716:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 717:stk500boot.c  **** 						}
 718:stk500boot.c  **** 						break;
 719:stk500boot.c  **** 
 720:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 721:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 722:stk500boot.c  **** 						seqNum			=	c;
 723:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 724:stk500boot.c  **** 						checksum		^=	c;
 725:stk500boot.c  **** 					#else
 726:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 727:stk500boot.c  **** 						{
 728:stk500boot.c  **** 							seqNum			=	c;
 729:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 730:stk500boot.c  **** 							checksum		^=	c;
 731:stk500boot.c  **** 						}
 732:stk500boot.c  **** 						else
 733:stk500boot.c  **** 						{
 734:stk500boot.c  **** 							msgParseState	=	ST_START;
 735:stk500boot.c  **** 						}
 736:stk500boot.c  **** 					#endif
 737:stk500boot.c  **** 						break;
 738:stk500boot.c  **** 
 739:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 740:stk500boot.c  **** 						msgLength		=	c<<8;
 741:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 742:stk500boot.c  **** 						checksum		^=	c;
 743:stk500boot.c  **** 						break;
 744:stk500boot.c  **** 
 745:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 746:stk500boot.c  **** 						msgLength		|=	c;
 747:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 748:stk500boot.c  **** 						checksum		^=	c;
 749:stk500boot.c  **** 						break;
 750:stk500boot.c  **** 
 751:stk500boot.c  **** 					case ST_GET_TOKEN:
 752:stk500boot.c  **** 						if ( c == TOKEN )
 753:stk500boot.c  **** 						{
 754:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 755:stk500boot.c  **** 							checksum		^=	c;
 756:stk500boot.c  **** 							ii				=	0;
 757:stk500boot.c  **** 						}
 758:stk500boot.c  **** 						else
 759:stk500boot.c  **** 						{
 760:stk500boot.c  **** 							msgParseState	=	ST_START;
 761:stk500boot.c  **** 						}
 762:stk500boot.c  **** 						break;
 763:stk500boot.c  **** 
 764:stk500boot.c  **** 					case ST_GET_DATA:
 765:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 766:stk500boot.c  **** 						checksum		^=	c;
 767:stk500boot.c  **** 						if (ii == msgLength )
 768:stk500boot.c  **** 						{
 769:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 770:stk500boot.c  **** 						}
 771:stk500boot.c  **** 						break;
 772:stk500boot.c  **** 
 773:stk500boot.c  **** 					case ST_GET_CHECK:
 774:stk500boot.c  **** 						if ( c == checksum )
 775:stk500boot.c  **** 						{
 776:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 777:stk500boot.c  **** 						}
 778:stk500boot.c  **** 						else
 779:stk500boot.c  **** 						{
 780:stk500boot.c  **** 							msgParseState	=	ST_START;
 781:stk500boot.c  **** 						}
 782:stk500boot.c  **** 						break;
 783:stk500boot.c  **** 				}	//	switch
 784:stk500boot.c  **** 			}	//	while(msgParseState)
 785:stk500boot.c  **** 
 786:stk500boot.c  **** 			/*
 787:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 788:stk500boot.c  **** 			 */
 789:stk500boot.c  **** 
 790:stk500boot.c  **** 			switch (msgBuffer[0])
 791:stk500boot.c  **** 			{
 792:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 793:stk500boot.c  **** 				case CMD_SPI_MULTI:
 794:stk500boot.c  **** 					{
 795:stk500boot.c  **** 						unsigned char answerByte;
 796:stk500boot.c  **** 						unsigned char flag=0;
 797:stk500boot.c  **** 
 798:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 799:stk500boot.c  **** 						{
 800:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 801:stk500boot.c  **** 
 802:stk500boot.c  **** 							if ( signatureIndex == 0 )
 803:stk500boot.c  **** 							{
 804:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 805:stk500boot.c  **** 							}
 806:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 807:stk500boot.c  **** 							{
 808:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 809:stk500boot.c  **** 							}
 810:stk500boot.c  **** 							else
 811:stk500boot.c  **** 							{
 812:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 813:stk500boot.c  **** 							}
 814:stk500boot.c  **** 						}
 815:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 816:stk500boot.c  **** 						{
 817:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 818:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 819:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 820:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 821:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 822:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 823:stk500boot.c  **** 							{
 824:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 825:stk500boot.c  **** 							}
 826:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 827:stk500boot.c  **** 							{
 828:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 829:stk500boot.c  **** 							}
 830:stk500boot.c  **** 							else
 831:stk500boot.c  **** 							{
 832:stk500boot.c  **** 								answerByte	=	0;
 833:stk500boot.c  **** 							}
 834:stk500boot.c  **** 						}
 835:stk500boot.c  **** 						else
 836:stk500boot.c  **** 						{
 837:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 838:stk500boot.c  **** 						}
 839:stk500boot.c  **** 						if ( !flag )
 840:stk500boot.c  **** 						{
 841:stk500boot.c  **** 							msgLength		=	7;
 842:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 843:stk500boot.c  **** 							msgBuffer[2]	=	0;
 844:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 845:stk500boot.c  **** 							msgBuffer[4]	=	0;
 846:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 847:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 848:stk500boot.c  **** 						}
 849:stk500boot.c  **** 					}
 850:stk500boot.c  **** 					break;
 851:stk500boot.c  **** 	#endif
 852:stk500boot.c  **** 				case CMD_SIGN_ON:
 853:stk500boot.c  **** 					msgLength		=	11;
 854:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 855:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 856:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 857:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 858:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 859:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 860:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 861:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 862:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 863:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 864:stk500boot.c  **** 					break;
 865:stk500boot.c  **** 
 866:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 867:stk500boot.c  **** 					{
 868:stk500boot.c  **** 						unsigned char value;
 869:stk500boot.c  **** 
 870:stk500boot.c  **** 						switch(msgBuffer[1])
 871:stk500boot.c  **** 						{
 872:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 873:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 874:stk500boot.c  **** 							break;
 875:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 876:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 877:stk500boot.c  **** 							break;
 878:stk500boot.c  **** 						case PARAM_HW_VER:
 879:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 880:stk500boot.c  **** 							break;
 881:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 882:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 883:stk500boot.c  **** 							break;
 884:stk500boot.c  **** 						case PARAM_SW_MINOR:
 885:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 886:stk500boot.c  **** 							break;
 887:stk500boot.c  **** 						default:
 888:stk500boot.c  **** 							value	=	0;
 889:stk500boot.c  **** 							break;
 890:stk500boot.c  **** 						}
 891:stk500boot.c  **** 						msgLength		=	3;
 892:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 893:stk500boot.c  **** 						msgBuffer[2]	=	value;
 894:stk500boot.c  **** 					}
 895:stk500boot.c  **** 					break;
 896:stk500boot.c  **** 
 897:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 898:stk500boot.c  **** 					isLeave	=	1;
 899:stk500boot.c  **** 					//*	fall thru
 900:stk500boot.c  **** 
 901:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 902:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 903:stk500boot.c  **** 					msgLength		=	2;
 904:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 905:stk500boot.c  **** 					break;
 906:stk500boot.c  **** 
 907:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 908:stk500boot.c  **** 					{
 909:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 910:stk500boot.c  **** 						unsigned char signature;
 911:stk500boot.c  **** 
 912:stk500boot.c  **** 						if ( signatureIndex == 0 )
 913:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 914:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 915:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 916:stk500boot.c  **** 						else
 917:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 918:stk500boot.c  **** 
 919:stk500boot.c  **** 						msgLength		=	4;
 920:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 921:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 922:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 923:stk500boot.c  **** 					}
 924:stk500boot.c  **** 					break;
 925:stk500boot.c  **** 
 926:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 927:stk500boot.c  **** 					msgLength		=	4;
 928:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 929:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 930:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 931:stk500boot.c  **** 					break;
 932:stk500boot.c  **** 
 933:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 934:stk500boot.c  **** 					{
 935:stk500boot.c  **** 						unsigned char fuseBits;
 936:stk500boot.c  **** 
 937:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 938:stk500boot.c  **** 						{
 939:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 940:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 941:stk500boot.c  **** 							else
 942:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 943:stk500boot.c  **** 						}
 944:stk500boot.c  **** 						else
 945:stk500boot.c  **** 						{
 946:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 947:stk500boot.c  **** 						}
 948:stk500boot.c  **** 						msgLength		=	4;
 949:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 950:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 951:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 952:stk500boot.c  **** 					}
 953:stk500boot.c  **** 					break;
 954:stk500boot.c  **** 
 955:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 956:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
 957:stk500boot.c  **** 					{
 958:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
 959:stk500boot.c  **** 
 960:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 961:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 962:stk500boot.c  **** 						boot_spm_busy_wait();
 963:stk500boot.c  **** 
 964:stk500boot.c  **** 						msgLength		=	3;
 965:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 966:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 967:stk500boot.c  **** 					}
 968:stk500boot.c  **** 					break;
 969:stk500boot.c  **** 	#endif
 970:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
 971:stk500boot.c  **** 					eraseAddress	=	0;
 972:stk500boot.c  **** 					msgLength		=	2;
 973:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 974:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 975:stk500boot.c  **** 					break;
 976:stk500boot.c  **** 
 977:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
 978:stk500boot.c  **** 	#if defined(RAMPZ)
 979:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 980:stk500boot.c  **** 	#else
 981:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 982:stk500boot.c  **** 	#endif
 983:stk500boot.c  **** 					msgLength		=	2;
 984:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 985:stk500boot.c  **** 					break;
 986:stk500boot.c  **** 
 987:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
 988:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
 989:stk500boot.c  **** 					{
 990:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 991:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 992:stk500boot.c  **** 						unsigned int	data;
 993:stk500boot.c  **** 						unsigned char	highByte, lowByte;
 994:stk500boot.c  **** 						address_t		tempaddress	=	address;
 995:stk500boot.c  **** 
 996:stk500boot.c  **** 
 997:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 998:stk500boot.c  **** 						{
 999:stk500boot.c  **** 							// erase only main section (bootloader protection)
1000:stk500boot.c  **** 							if (eraseAddress < APP_END )
1001:stk500boot.c  **** 							{
1002:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1003:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1004:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1005:stk500boot.c  **** 							}
1006:stk500boot.c  **** 
1007:stk500boot.c  **** 							/* Write FLASH */
1008:stk500boot.c  **** 							do {
1009:stk500boot.c  **** 								lowByte		=	*p++;
1010:stk500boot.c  **** 								highByte 	=	*p++;
1011:stk500boot.c  **** 
1012:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1013:stk500boot.c  **** 								boot_page_fill(address,data);
1014:stk500boot.c  **** 
1015:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1016:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1017:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1018:stk500boot.c  **** 
1019:stk500boot.c  **** 							boot_page_write(tempaddress);
1020:stk500boot.c  **** 							boot_spm_busy_wait();
1021:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1022:stk500boot.c  **** 						}
1023:stk500boot.c  **** 						else
1024:stk500boot.c  **** 						{
1025:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1026:stk500boot.c  **** 							uint16_t ii = address >> 1;
1027:stk500boot.c  **** 							/* write EEPROM */
1028:stk500boot.c  **** 							while (size) {
1029:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1030:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1031:stk500boot.c  **** 								ii++;
1032:stk500boot.c  **** 								size--;
1033:stk500boot.c  **** 							}
1034:stk500boot.c  **** 						}
1035:stk500boot.c  **** 						msgLength		=	2;
1036:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1037:stk500boot.c  **** 					}
1038:stk500boot.c  **** 					break;
1039:stk500boot.c  **** 
1040:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1041:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1042:stk500boot.c  **** 					{
1043:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1044:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1045:stk500boot.c  **** 						msgLength				=	size+3;
1046:stk500boot.c  **** 
1047:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1048:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1049:stk500boot.c  **** 						{
1050:stk500boot.c  **** 							unsigned int data;
1051:stk500boot.c  **** 
1052:stk500boot.c  **** 							// Read FLASH
1053:stk500boot.c  **** 							do {
1054:stk500boot.c  **** 						//#if defined(RAMPZ)
1055:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1056:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1057:stk500boot.c  **** 						#else
1058:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1059:stk500boot.c  **** 						#endif
1060:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1061:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1062:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1063:stk500boot.c  **** 								size	-=	2;
1064:stk500boot.c  **** 							}while (size);
1065:stk500boot.c  **** 						}
1066:stk500boot.c  **** 						else
1067:stk500boot.c  **** 						{
1068:stk500boot.c  **** 							/* Read EEPROM */
1069:stk500boot.c  **** 							do {
1070:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1071:stk500boot.c  **** 								EEARH	=	((address >> 8));
1072:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1073:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1074:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1075:stk500boot.c  **** 								size--;
1076:stk500boot.c  **** 							} while (size);
1077:stk500boot.c  **** 						}
1078:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1079:stk500boot.c  **** 					}
1080:stk500boot.c  **** 					break;
1081:stk500boot.c  **** 
1082:stk500boot.c  **** 				default:
1083:stk500boot.c  **** 					msgLength		=	2;
1084:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1085:stk500boot.c  **** 					break;
1086:stk500boot.c  **** 			}
1087:stk500boot.c  **** 
1088:stk500boot.c  **** 			/*
1089:stk500boot.c  **** 			 * Now send answer message back
1090:stk500boot.c  **** 			 */
1091:stk500boot.c  **** 			sendchar(MESSAGE_START);
1092:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1093:stk500boot.c  **** 
1094:stk500boot.c  **** 			sendchar(seqNum);
1095:stk500boot.c  **** 			checksum	^=	seqNum;
1096:stk500boot.c  **** 
1097:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1098:stk500boot.c  **** 			sendchar(c);
1099:stk500boot.c  **** 			checksum	^=	c;
1100:stk500boot.c  **** 
1101:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1102:stk500boot.c  **** 			sendchar(c);
1103:stk500boot.c  **** 			checksum ^= c;
1104:stk500boot.c  **** 
1105:stk500boot.c  **** 			sendchar(TOKEN);
1106:stk500boot.c  **** 			checksum ^= TOKEN;
1107:stk500boot.c  **** 
1108:stk500boot.c  **** 			p	=	msgBuffer;
1109:stk500boot.c  **** 			while ( msgLength )
1110:stk500boot.c  **** 			{
1111:stk500boot.c  **** 				c	=	*p++;
1112:stk500boot.c  **** 				sendchar(c);
1113:stk500boot.c  **** 				checksum ^=c;
1114:stk500boot.c  **** 				msgLength--;
1115:stk500boot.c  **** 			}
1116:stk500boot.c  **** 			sendchar(checksum);
1117:stk500boot.c  **** 			seqNum++;
1118:stk500boot.c  **** 	
1119:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1120:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1121:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1122:stk500boot.c  **** 		#endif
1123:stk500boot.c  **** 
1124:stk500boot.c  **** 		}
1125:stk500boot.c  **** 	}
1126:stk500boot.c  **** 
1127:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1128:stk500boot.c  **** 	//*	this is for debugging it can be removed
1129:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1130:stk500boot.c  **** 	{
1131:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1132:stk500boot.c  **** 		delay_ms(200);
1133:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1134:stk500boot.c  **** 		delay_ms(200);
1135:stk500boot.c  **** 	}
1136:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1137:stk500boot.c  **** #endif
1138:stk500boot.c  **** 
1139:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1140:stk500boot.c  **** 	sendchar('j');
1141:stk500boot.c  **** //	sendchar('u');
1142:stk500boot.c  **** //	sendchar('m');
1143:stk500boot.c  **** //	sendchar('p');
1144:stk500boot.c  **** //	sendchar(' ');
1145:stk500boot.c  **** //	sendchar('u');
1146:stk500boot.c  **** //	sendchar('s');
1147:stk500boot.c  **** //	sendchar('r');
1148:stk500boot.c  **** 	sendchar(0x0d);
1149:stk500boot.c  **** 	sendchar(0x0a);
1150:stk500boot.c  **** 
1151:stk500boot.c  **** 	delay_ms(100);
1152:stk500boot.c  **** #endif
1153:stk500boot.c  **** 
1154:stk500boot.c  **** 
1155:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1156:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1157:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1158:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1159:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1160:stk500boot.c  **** #endif
1161:stk500boot.c  **** 
1162:stk500boot.c  **** 
1163:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1164:stk500boot.c  **** 
1165:stk500boot.c  **** 	/*
1166:stk500boot.c  **** 	 * Now leave bootloader
1167:stk500boot.c  **** 	 */
1168:stk500boot.c  **** 
1169:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1170:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1171:stk500boot.c  **** 
1172:stk500boot.c  **** 
1173:stk500boot.c  **** 	asm volatile(
1174:stk500boot.c  **** 			"clr	r30		\n\t"
1175:stk500boot.c  **** 			"clr	r31		\n\t"
1176:stk500boot.c  **** 			"ijmp	\n\t"
1177:stk500boot.c  **** 			);
1178:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1179:stk500boot.c  **** //					"push r1" "\n\t"
1180:stk500boot.c  **** //					"ret"	 "\n\t"
1181:stk500boot.c  **** //					::);
1182:stk500boot.c  **** 
1183:stk500boot.c  **** 	 /*
1184:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1185:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1186:stk500boot.c  **** 	 * understand this
1187:stk500boot.c  **** 	 */
1188:stk500boot.c  **** 	for(;;);
1189:stk500boot.c  **** }
1190:stk500boot.c  **** 
1191:stk500boot.c  **** /*
1192:stk500boot.c  **** base address = f800
1193:stk500boot.c  **** 
1194:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1195:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1196:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1197:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1198:stk500boot.c  **** avrdude>
1199:stk500boot.c  **** 
1200:stk500boot.c  **** 
1201:stk500boot.c  **** base address = f000
1202:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1203:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1204:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1205:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1206:stk500boot.c  **** avrdude>
1207:stk500boot.c  **** */
1208:stk500boot.c  **** 
1209:stk500boot.c  **** //************************************************************************
1210:stk500boot.c  **** #ifdef ENABLE_MONITOR
1211:stk500boot.c  **** #include	<math.h>
1212:stk500boot.c  **** 
1213:stk500boot.c  **** unsigned long	gRamIndex;
1214:stk500boot.c  **** unsigned long	gFlashIndex;
1215:stk500boot.c  **** unsigned long	gEepromIndex;
1216:stk500boot.c  **** 
1217:stk500boot.c  **** 
1218:stk500boot.c  **** #define	true	1
1219:stk500boot.c  **** #define	false	0
1220:stk500boot.c  **** 
1221:stk500boot.c  **** #include	"avr_cpunames.h"
1222:stk500boot.c  **** 
1223:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1224:stk500boot.c  **** 	#error cpu name not defined
1225:stk500boot.c  **** #endif
1226:stk500boot.c  **** 
1227:stk500boot.c  **** #ifdef _VECTORS_SIZE
1228:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1229:stk500boot.c  **** #else
1230:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1231:stk500boot.c  **** #endif
1232:stk500boot.c  **** 
1233:stk500boot.c  **** 
1234:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1235:stk500boot.c  **** 
1236:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1237:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1238:stk500boot.c  **** #else
1239:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1240:stk500boot.c  **** #endif
1241:stk500boot.c  **** 
1242:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1243:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1244:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1245:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1246:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1247:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1248:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1249:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1250:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1251:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1252:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1253:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1254:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1255:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1256:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1257:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1258:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1259:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1260:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1261:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1262:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1263:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1264:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1265:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1266:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1267:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1268:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1269:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1270:stk500boot.c  **** 
1271:stk500boot.c  **** 
1272:stk500boot.c  **** //************************************************************************
1273:stk500boot.c  **** //*	Help messages
1274:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1275:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1276:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1277:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1278:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1279:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1280:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1281:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1282:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1283:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1284:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1285:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1286:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1287:stk500boot.c  **** 
1288:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1289:stk500boot.c  **** 
1290:stk500boot.c  **** 
1291:stk500boot.c  **** //************************************************************************
1292:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1293:stk500boot.c  **** {
 162               		.loc 1 1293 0
 163               		.cfi_startproc
 164               	.LVL8:
 165 0036 CF93      		push r28
 166               	.LCFI0:
 167               		.cfi_def_cfa_offset 4
 168               		.cfi_offset 28, -3
 169 0038 DF93      		push r29
 170               	.LCFI1:
 171               		.cfi_def_cfa_offset 5
 172               		.cfi_offset 29, -4
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 2 */
 176               	.L__stack_usage = 2
1294:stk500boot.c  **** char	theChar;
1295:stk500boot.c  **** 
1296:stk500boot.c  **** 	dataPtr		+=	offset;
 177               		.loc 1 1296 0
 178 003a EC01      		movw r28,r24
 179 003c C60F      		add r28,r22
 180 003e D11D      		adc r29,__zero_reg__
 181               	.LVL9:
 182               	.L16:
 183               	.LBB79:
1297:stk500boot.c  **** 
1298:stk500boot.c  **** 	do {
1299:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1300:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 184               		.loc 1 1300 0
 185 0040 CE01      		movw r24,r28
 186 0042 A0E0      		ldi r26,0
 187 0044 B0E0      		ldi r27,0
 188               	/* #APP */
 189               	 ;  1300 "stk500boot.c" 1
 190 0046 ABBF      		out 59, r26
 191 0048 FC01      		movw r30, r24
 192 004a 8791      		elpm r24, Z+
 193               		
 194               	 ;  0 "" 2
 195               	.LVL10:
 196               	/* #NOAPP */
 197               	.LBE79:
1301:stk500boot.c  **** 	#else
1302:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1303:stk500boot.c  **** 	#endif
1304:stk500boot.c  **** 		if (theChar != 0)
 198               		.loc 1 1304 0
 199 004c 8823      		tst r24
 200 004e 01F0      		breq .L14
 201               	.LBB80:
1300:stk500boot.c  **** 	#else
 202               		.loc 1 1300 0
 203 0050 2196      		adiw r28,1
 204               	.LVL11:
 205               	.LBE80:
1305:stk500boot.c  **** 		{
1306:stk500boot.c  **** 			sendchar(theChar);
 206               		.loc 1 1306 0
 207 0052 0E94 0000 		call sendchar
 208               	.LVL12:
 209 0056 00C0      		rjmp .L16
 210               	.LVL13:
 211               	.L14:
 212               	/* epilogue start */
1307:stk500boot.c  **** 		}
1308:stk500boot.c  **** 	} while (theChar != 0);
1309:stk500boot.c  **** }
 213               		.loc 1 1309 0
 214 0058 DF91      		pop r29
 215 005a CF91      		pop r28
 216               	.LVL14:
 217 005c 0895      		ret
 218               		.cfi_endproc
 219               	.LFE18:
 221               	.global	PrintNewLine
 223               	PrintNewLine:
 224               	.LFB19:
1310:stk500boot.c  **** 
1311:stk500boot.c  **** //************************************************************************
1312:stk500boot.c  **** void	PrintNewLine(void)
1313:stk500boot.c  **** {
 225               		.loc 1 1313 0
 226               		.cfi_startproc
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
1314:stk500boot.c  **** 	sendchar(0x0d);
 231               		.loc 1 1314 0
 232 005e 8DE0      		ldi r24,lo8(13)
 233 0060 0E94 0000 		call sendchar
 234               	.LVL15:
1315:stk500boot.c  **** 	sendchar(0x0a);
 235               		.loc 1 1315 0
 236 0064 8AE0      		ldi r24,lo8(10)
 237 0066 0C94 0000 		jmp sendchar
 238               	.LVL16:
 239               		.cfi_endproc
 240               	.LFE19:
 242               		.section	.text.unlikely
 244               	PrintAvailablePort:
 245               	.LFB29:
1316:stk500boot.c  **** }
1317:stk500boot.c  **** 
1318:stk500boot.c  **** 
1319:stk500boot.c  **** //************************************************************************
1320:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1321:stk500boot.c  **** {
1322:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1323:stk500boot.c  **** 
1324:stk500boot.c  **** 	PrintNewLine();
1325:stk500boot.c  **** }
1326:stk500boot.c  **** 
1327:stk500boot.c  **** 
1328:stk500boot.c  **** //************************************************************************
1329:stk500boot.c  **** void	PrintString(char *textString)
1330:stk500boot.c  **** {
1331:stk500boot.c  **** char	theChar;
1332:stk500boot.c  **** int		ii;
1333:stk500boot.c  **** 
1334:stk500boot.c  **** 	theChar		=	1;
1335:stk500boot.c  **** 	ii			=	0;
1336:stk500boot.c  **** 	while (theChar != 0)
1337:stk500boot.c  **** 	{
1338:stk500boot.c  **** 		theChar	=	textString[ii];
1339:stk500boot.c  **** 		if (theChar != 0)
1340:stk500boot.c  **** 		{
1341:stk500boot.c  **** 			sendchar(theChar);
1342:stk500boot.c  **** 		}
1343:stk500boot.c  **** 		ii++;
1344:stk500boot.c  **** 	}
1345:stk500boot.c  **** }
1346:stk500boot.c  **** 
1347:stk500boot.c  **** //************************************************************************
1348:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1349:stk500boot.c  **** {
1350:stk500boot.c  **** char	theChar;
1351:stk500boot.c  **** 
1352:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1353:stk500boot.c  **** 	if (theChar > 0x39)
1354:stk500boot.c  **** 	{
1355:stk500boot.c  **** 		theChar	+=	7;
1356:stk500boot.c  **** 	}
1357:stk500boot.c  **** 	sendchar(theChar );
1358:stk500boot.c  **** 
1359:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1360:stk500boot.c  **** 	if (theChar > 0x39)
1361:stk500boot.c  **** 	{
1362:stk500boot.c  **** 		theChar	+=	7;
1363:stk500boot.c  **** 	}
1364:stk500boot.c  **** 	sendchar(theChar );
1365:stk500boot.c  **** }
1366:stk500boot.c  **** 
1367:stk500boot.c  **** //************************************************************************
1368:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1369:stk500boot.c  **** {
1370:stk500boot.c  **** int	theChar;
1371:stk500boot.c  **** int	myNumber;
1372:stk500boot.c  **** 
1373:stk500boot.c  **** 	myNumber	=	theNumber;
1374:stk500boot.c  **** 
1375:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1376:stk500boot.c  **** 	{
1377:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1378:stk500boot.c  **** 		sendchar(theChar );
1379:stk500boot.c  **** 	}
1380:stk500boot.c  **** 
1381:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1382:stk500boot.c  **** 	{
1383:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1384:stk500boot.c  **** 		sendchar(theChar );
1385:stk500boot.c  **** 	}
1386:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1387:stk500boot.c  **** 	sendchar(theChar );
1388:stk500boot.c  **** }
1389:stk500boot.c  **** 
1390:stk500boot.c  **** 
1391:stk500boot.c  **** 
1392:stk500boot.c  **** 
1393:stk500boot.c  **** //************************************************************************
1394:stk500boot.c  **** static void	PrintCPUstats(void)
1395:stk500boot.c  **** {
1396:stk500boot.c  **** unsigned char fuseByte;
1397:stk500boot.c  **** 
1398:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1399:stk500boot.c  **** 
1400:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1401:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1404:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1405:stk500boot.c  **** 
1406:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1407:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1408:stk500boot.c  **** 	PrintNewLine();
1409:stk500boot.c  **** 
1410:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1411:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1412:stk500boot.c  **** 
1413:stk500boot.c  **** 	//*	these can be found in avr/version.h
1414:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1415:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1416:stk500boot.c  **** 
1417:stk500boot.c  **** #if defined(SIGNATURE_0)
1418:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1419:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1420:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1421:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1422:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1423:stk500boot.c  **** 	PrintNewLine();
1424:stk500boot.c  **** #endif
1425:stk500boot.c  **** 
1426:stk500boot.c  **** 
1427:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1428:stk500boot.c  **** 	//*	fuse settings
1429:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1430:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1431:stk500boot.c  **** 	PrintHexByte(fuseByte);
1432:stk500boot.c  **** 	PrintNewLine();
1433:stk500boot.c  **** 
1434:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1435:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1436:stk500boot.c  **** 	PrintHexByte(fuseByte);
1437:stk500boot.c  **** 	PrintNewLine();
1438:stk500boot.c  **** 
1439:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1440:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1441:stk500boot.c  **** 	PrintHexByte(fuseByte);
1442:stk500boot.c  **** 	PrintNewLine();
1443:stk500boot.c  **** 
1444:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1445:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1446:stk500boot.c  **** 	PrintHexByte(fuseByte);
1447:stk500boot.c  **** 	PrintNewLine();
1448:stk500boot.c  **** 
1449:stk500boot.c  **** #endif
1450:stk500boot.c  **** 
1451:stk500boot.c  **** }
1452:stk500boot.c  **** 
1453:stk500boot.c  **** 
1454:stk500boot.c  **** //************************************************************************
1455:stk500boot.c  **** static void BlinkLED(void)
1456:stk500boot.c  **** {
1457:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1458:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1459:stk500boot.c  **** 
1460:stk500boot.c  **** 	while (!Serial_Available())
1461:stk500boot.c  **** 	{
1462:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1463:stk500boot.c  **** 		delay_ms(100);
1464:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1465:stk500boot.c  **** 		delay_ms(100);
1466:stk500boot.c  **** 	}
1467:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1468:stk500boot.c  **** }
1469:stk500boot.c  **** 
1470:stk500boot.c  **** enum
1471:stk500boot.c  **** {
1472:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1473:stk500boot.c  **** 	kDUMP_EEPROM,
1474:stk500boot.c  **** 	kDUMP_RAM
1475:stk500boot.c  **** };
1476:stk500boot.c  **** 
1477:stk500boot.c  **** //************************************************************************
1478:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1479:stk500boot.c  **** {
1480:stk500boot.c  **** unsigned long	myAddressPointer;
1481:stk500boot.c  **** uint8_t			ii;
1482:stk500boot.c  **** unsigned char	theValue;
1483:stk500boot.c  **** char			asciiDump[18];
1484:stk500boot.c  **** unsigned char	*ramPtr;
1485:stk500boot.c  **** 
1486:stk500boot.c  **** 
1487:stk500boot.c  **** 	ramPtr				=	0;
1488:stk500boot.c  **** 	theValue			=	0;
1489:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1490:stk500boot.c  **** 	while (numRows > 0)
1491:stk500boot.c  **** 	{
1492:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1493:stk500boot.c  **** 		{
1494:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1495:stk500boot.c  **** 		}
1496:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1497:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1498:stk500boot.c  **** 		sendchar(0x20);
1499:stk500boot.c  **** 		sendchar('-');
1500:stk500boot.c  **** 		sendchar(0x20);
1501:stk500boot.c  **** 
1502:stk500boot.c  **** 		asciiDump[0]		=	0;
1503:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1504:stk500boot.c  **** 		{
1505:stk500boot.c  **** 			switch(dumpWhat)
1506:stk500boot.c  **** 			{
1507:stk500boot.c  **** 				case kDUMP_FLASH:
1508:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1509:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1510:stk500boot.c  **** 				#else
1511:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1512:stk500boot.c  **** 				#endif
1513:stk500boot.c  **** 					break;
1514:stk500boot.c  **** 
1515:stk500boot.c  **** 				case kDUMP_EEPROM:
1516:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1517:stk500boot.c  **** 					break;
1518:stk500boot.c  **** 
1519:stk500boot.c  **** 				case kDUMP_RAM:
1520:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1521:stk500boot.c  **** 					break;
1522:stk500boot.c  **** 
1523:stk500boot.c  **** 			}
1524:stk500boot.c  **** 			PrintHexByte(theValue);
1525:stk500boot.c  **** 			sendchar(0x20);
1526:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1527:stk500boot.c  **** 			{
1528:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1529:stk500boot.c  **** 			}
1530:stk500boot.c  **** 			else
1531:stk500boot.c  **** 			{
1532:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1533:stk500boot.c  **** 			}
1534:stk500boot.c  **** 
1535:stk500boot.c  **** 			myAddressPointer++;
1536:stk500boot.c  **** 		}
1537:stk500boot.c  **** 		asciiDump[16]	=	0;
1538:stk500boot.c  **** 		PrintString(asciiDump);
1539:stk500boot.c  **** 		PrintNewLine();
1540:stk500boot.c  **** 
1541:stk500boot.c  **** 		numRows--;
1542:stk500boot.c  **** 	}
1543:stk500boot.c  **** }
1544:stk500boot.c  **** 
1545:stk500boot.c  **** 
1546:stk500boot.c  **** 
1547:stk500boot.c  **** //************************************************************************
1548:stk500boot.c  **** //*	returns amount of extended memory
1549:stk500boot.c  **** static void	EEPROMtest(void)
1550:stk500boot.c  **** {
1551:stk500boot.c  **** int		ii;
1552:stk500boot.c  **** char	theChar;
1553:stk500boot.c  **** char	theEEPROMchar;
1554:stk500boot.c  **** int		errorCount;
1555:stk500boot.c  **** 
1556:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1557:stk500boot.c  **** 	PrintNewLine();
1558:stk500boot.c  **** 	ii			=	0;
1559:stk500boot.c  **** #if (FLASHEND > 0x10000)
1560:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1561:stk500boot.c  **** #else
1562:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1563:stk500boot.c  **** #endif
1564:stk500boot.c  **** 	{
1565:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1566:stk500boot.c  **** 		if (theChar == 0)
1567:stk500boot.c  **** 		{
1568:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1569:stk500boot.c  **** 		}
1570:stk500boot.c  **** 		else
1571:stk500boot.c  **** 		{
1572:stk500boot.c  **** 			sendchar(theChar);
1573:stk500boot.c  **** 		}
1574:stk500boot.c  **** 		ii++;
1575:stk500boot.c  **** 	}
1576:stk500boot.c  **** 
1577:stk500boot.c  **** 	//*	no go back through and test
1578:stk500boot.c  **** 	PrintNewLine();
1579:stk500boot.c  **** 	PrintNewLine();
1580:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1581:stk500boot.c  **** 	PrintNewLine();
1582:stk500boot.c  **** 	errorCount	=	0;
1583:stk500boot.c  **** 	ii			=	0;
1584:stk500boot.c  **** #if (FLASHEND > 0x10000)
1585:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1586:stk500boot.c  **** #else
1587:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1588:stk500boot.c  **** #endif
1589:stk500boot.c  **** 	{
1590:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1591:stk500boot.c  **** 		if (theEEPROMchar == 0)
1592:stk500boot.c  **** 		{
1593:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1594:stk500boot.c  **** 		}
1595:stk500boot.c  **** 		else
1596:stk500boot.c  **** 		{
1597:stk500boot.c  **** 			sendchar(theEEPROMchar);
1598:stk500boot.c  **** 		}
1599:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1600:stk500boot.c  **** 		{
1601:stk500boot.c  **** 			errorCount++;
1602:stk500boot.c  **** 		}
1603:stk500boot.c  **** 		ii++;
1604:stk500boot.c  **** 	}
1605:stk500boot.c  **** 	PrintNewLine();
1606:stk500boot.c  **** 	PrintNewLine();
1607:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1608:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1609:stk500boot.c  **** 	PrintNewLine();
1610:stk500boot.c  **** 	PrintNewLine();
1611:stk500boot.c  **** 
1612:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1613:stk500boot.c  **** 
1614:stk500boot.c  **** }
1615:stk500boot.c  **** 
1616:stk500boot.c  **** 
1617:stk500boot.c  **** 
1618:stk500boot.c  **** #if (FLASHEND > 0x08000)
1619:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1620:stk500boot.c  **** //*	memory to include this
1621:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1622:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1623:stk500boot.c  **** //		#warning Interrupt vectors not defined
1624:stk500boot.c  **** //	#endif
1625:stk500boot.c  **** #endif
1626:stk500boot.c  **** 
1627:stk500boot.c  **** //************************************************************************
1628:stk500boot.c  **** static void	VectorDisplay(void)
1629:stk500boot.c  **** {
1630:stk500boot.c  **** unsigned long	byte1;
1631:stk500boot.c  **** unsigned long	byte2;
1632:stk500boot.c  **** unsigned long	byte3;
1633:stk500boot.c  **** unsigned long	byte4;
1634:stk500boot.c  **** unsigned long	word1;
1635:stk500boot.c  **** unsigned long	word2;
1636:stk500boot.c  **** int				vectorIndex;
1637:stk500boot.c  **** unsigned long	myMemoryPtr;
1638:stk500boot.c  **** unsigned long	wordMemoryAddress;
1639:stk500boot.c  **** unsigned long	realitiveAddr;
1640:stk500boot.c  **** unsigned long	myFullAddress;
1641:stk500boot.c  **** unsigned long	absoluteAddr;
1642:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1643:stk500boot.c  **** 	long		stringPointer;
1644:stk500boot.c  **** #endif
1645:stk500boot.c  **** 
1646:stk500boot.c  **** 	myMemoryPtr		=	0;
1647:stk500boot.c  **** 	vectorIndex		=	0;
1648:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1649:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1650:stk500boot.c  **** 	//					 V#   ADDR   op code
1651:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1652:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1653:stk500boot.c  **** 	{
1654:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1655:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1656:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1657:stk500boot.c  **** 		sendchar(0x20);
1658:stk500boot.c  **** 		sendchar('-');
1659:stk500boot.c  **** 		sendchar(0x20);
1660:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1661:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1662:stk500boot.c  **** 		sendchar(0x20);
1663:stk500boot.c  **** 		sendchar('=');
1664:stk500boot.c  **** 		sendchar(0x20);
1665:stk500boot.c  **** 
1666:stk500boot.c  **** 	
1667:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1668:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1669:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1670:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1671:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1672:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1673:stk500boot.c  **** 	#else
1674:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1675:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1676:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1677:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1678:stk500boot.c  **** 	#endif
1679:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1680:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1681:stk500boot.c  **** 
1682:stk500boot.c  **** 
1683:stk500boot.c  **** 		PrintHexByte(byte2);
1684:stk500boot.c  **** 		sendchar(0x20);
1685:stk500boot.c  **** 		PrintHexByte(byte1);
1686:stk500boot.c  **** 		sendchar(0x20);
1687:stk500boot.c  **** 		PrintHexByte(byte4);
1688:stk500boot.c  **** 		sendchar(0x20);
1689:stk500boot.c  **** 		PrintHexByte(byte3);
1690:stk500boot.c  **** 		sendchar(0x20);
1691:stk500boot.c  **** 	
1692:stk500boot.c  **** 		if (word1 == 0xffff)
1693:stk500boot.c  **** 		{
1694:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1695:stk500boot.c  **** 		}
1696:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1697:stk500boot.c  **** 		{
1698:stk500boot.c  **** 			//*	rjmp instruction
1699:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1700:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1701:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1702:stk500boot.c  **** 
1703:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1704:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1705:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1706:stk500boot.c  **** 			sendchar(0x20);
1707:stk500boot.c  **** 			sendchar('>');
1708:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1709:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1710:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1711:stk500boot.c  **** 	
1712:stk500boot.c  **** 		}
1713:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1714:stk500boot.c  **** 		{
1715:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1716:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1717:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1718:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1719:stk500boot.c  **** 								word2;
1720:stk500boot.c  **** 							
1721:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1722:stk500boot.c  **** 							
1723:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1724:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1725:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1726:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1727:stk500boot.c  **** 			sendchar(0x20);
1728:stk500boot.c  **** 			sendchar('>');
1729:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1730:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1731:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1732:stk500boot.c  **** 		}
1733:stk500boot.c  **** 
1734:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1735:stk500boot.c  **** 		sendchar(0x20);
1736:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1737:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1738:stk500boot.c  **** 	#else
1739:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1740:stk500boot.c  **** 	#endif
1741:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1742:stk500boot.c  **** 	#endif
1743:stk500boot.c  **** 		PrintNewLine();
1744:stk500boot.c  **** 
1745:stk500boot.c  **** 		vectorIndex++;
1746:stk500boot.c  **** 	}
1747:stk500boot.c  **** }
1748:stk500boot.c  **** 
1749:stk500boot.c  **** //************************************************************************
1750:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1751:stk500boot.c  **** {
 246               		.loc 1 1751 0
 247               		.cfi_startproc
 248               	.LVL17:
 249 000e CF93      		push r28
 250               	.LCFI2:
 251               		.cfi_def_cfa_offset 4
 252               		.cfi_offset 28, -3
 253               	/* prologue: function */
 254               	/* frame size = 0 */
 255               	/* stack size = 1 */
 256               	.L__stack_usage = 1
 257 0010 C82F      		mov r28,r24
1752:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 258               		.loc 1 1752 0
 259 0012 60E0      		ldi r22,0
 260 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 261 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 262               	.LVL18:
 263 0018 0E94 0000 		call PrintFromPROGMEM
 264               	.LVL19:
1753:stk500boot.c  **** 	sendchar(thePortLetter);
 265               		.loc 1 1753 0
 266 001c 8C2F      		mov r24,r28
 267 001e 0E94 0000 		call sendchar
 268               	.LVL20:
 269               	/* epilogue start */
1754:stk500boot.c  **** 	PrintNewLine();
1755:stk500boot.c  **** }
 270               		.loc 1 1755 0
 271 0022 CF91      		pop r28
 272               	.LVL21:
1754:stk500boot.c  **** 	PrintNewLine();
 273               		.loc 1 1754 0
 274 0024 0C94 0000 		jmp PrintNewLine
 275               	.LVL22:
 276               		.cfi_endproc
 277               	.LFE29:
 279               		.text
 280               	.global	PrintFromPROGMEMln
 282               	PrintFromPROGMEMln:
 283               	.LFB20:
1321:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 284               		.loc 1 1321 0
 285               		.cfi_startproc
 286               	.LVL23:
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 0 */
 290               	.L__stack_usage = 0
1322:stk500boot.c  **** 
 291               		.loc 1 1322 0
 292 006a 0E94 0000 		call PrintFromPROGMEM
 293               	.LVL24:
1324:stk500boot.c  **** }
 294               		.loc 1 1324 0
 295 006e 0C94 0000 		jmp PrintNewLine
 296               	.LVL25:
 297               		.cfi_endproc
 298               	.LFE20:
 300               	.global	PrintString
 302               	PrintString:
 303               	.LFB21:
1330:stk500boot.c  **** char	theChar;
 304               		.loc 1 1330 0
 305               		.cfi_startproc
 306               	.LVL26:
 307 0072 CF93      		push r28
 308               	.LCFI3:
 309               		.cfi_def_cfa_offset 4
 310               		.cfi_offset 28, -3
 311 0074 DF93      		push r29
 312               	.LCFI4:
 313               		.cfi_def_cfa_offset 5
 314               		.cfi_offset 29, -4
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 2 */
 318               	.L__stack_usage = 2
 319 0076 EC01      		movw r28,r24
 320               	.LVL27:
 321               	.L22:
1338:stk500boot.c  **** 		if (theChar != 0)
 322               		.loc 1 1338 0
 323 0078 8991      		ld r24,Y+
 324               	.LVL28:
1339:stk500boot.c  **** 		{
 325               		.loc 1 1339 0
 326 007a 8823      		tst r24
 327 007c 01F0      		breq .L20
1341:stk500boot.c  **** 		}
 328               		.loc 1 1341 0
 329 007e 0E94 0000 		call sendchar
 330               	.LVL29:
 331 0082 00C0      		rjmp .L22
 332               	.LVL30:
 333               	.L20:
 334               	/* epilogue start */
1345:stk500boot.c  **** 
 335               		.loc 1 1345 0
 336 0084 DF91      		pop r29
 337 0086 CF91      		pop r28
 338               	.LVL31:
 339 0088 0895      		ret
 340               		.cfi_endproc
 341               	.LFE21:
 343               	.global	PrintHexByte
 345               	PrintHexByte:
 346               	.LFB22:
1349:stk500boot.c  **** char	theChar;
 347               		.loc 1 1349 0
 348               		.cfi_startproc
 349               	.LVL32:
 350 008a CF93      		push r28
 351               	.LCFI5:
 352               		.cfi_def_cfa_offset 4
 353               		.cfi_offset 28, -3
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 1 */
 357               	.L__stack_usage = 1
 358 008c C82F      		mov r28,r24
1352:stk500boot.c  **** 	if (theChar > 0x39)
 359               		.loc 1 1352 0
 360 008e 982F      		mov r25,r24
 361 0090 9295      		swap r25
 362 0092 9F70      		andi r25,lo8(15)
 363 0094 80E3      		ldi r24,lo8(48)
 364               	.LVL33:
 365 0096 890F      		add r24,r25
 366               	.LVL34:
1353:stk500boot.c  **** 	{
 367               		.loc 1 1353 0
 368 0098 8A33      		cpi r24,lo8(58)
 369 009a 00F0      		brlo .L24
1355:stk500boot.c  **** 	}
 370               		.loc 1 1355 0
 371 009c 87E3      		ldi r24,lo8(55)
 372               	.LVL35:
 373 009e 890F      		add r24,r25
 374               	.LVL36:
 375               	.L24:
1357:stk500boot.c  **** 
 376               		.loc 1 1357 0
 377 00a0 0E94 0000 		call sendchar
 378               	.LVL37:
1359:stk500boot.c  **** 	if (theChar > 0x39)
 379               		.loc 1 1359 0
 380 00a4 CF70      		andi r28,lo8(15)
 381               	.LVL38:
 382 00a6 80E3      		ldi r24,lo8(48)
 383 00a8 8C0F      		add r24,r28
 384               	.LVL39:
1360:stk500boot.c  **** 	{
 385               		.loc 1 1360 0
 386 00aa 8A33      		cpi r24,lo8(58)
 387 00ac 00F0      		brlo .L25
1362:stk500boot.c  **** 	}
 388               		.loc 1 1362 0
 389 00ae 87E3      		ldi r24,lo8(55)
 390               	.LVL40:
 391 00b0 8C0F      		add r24,r28
 392               	.LVL41:
 393               	.L25:
 394               	/* epilogue start */
1365:stk500boot.c  **** 
 395               		.loc 1 1365 0
 396 00b2 CF91      		pop r28
1364:stk500boot.c  **** }
 397               		.loc 1 1364 0
 398 00b4 0C94 0000 		jmp sendchar
 399               	.LVL42:
 400               		.cfi_endproc
 401               	.LFE22:
 403               		.section	.text.unlikely
 405               	DumpHex.constprop.0:
 406               	.LFB34:
1478:stk500boot.c  **** {
 407               		.loc 1 1478 0
 408               		.cfi_startproc
 409               	.LVL43:
 410 0028 2F92      		push r2
 411               	.LCFI6:
 412               		.cfi_def_cfa_offset 4
 413               		.cfi_offset 2, -3
 414 002a 3F92      		push r3
 415               	.LCFI7:
 416               		.cfi_def_cfa_offset 5
 417               		.cfi_offset 3, -4
 418 002c 4F92      		push r4
 419               	.LCFI8:
 420               		.cfi_def_cfa_offset 6
 421               		.cfi_offset 4, -5
 422 002e 5F92      		push r5
 423               	.LCFI9:
 424               		.cfi_def_cfa_offset 7
 425               		.cfi_offset 5, -6
 426 0030 6F92      		push r6
 427               	.LCFI10:
 428               		.cfi_def_cfa_offset 8
 429               		.cfi_offset 6, -7
 430 0032 7F92      		push r7
 431               	.LCFI11:
 432               		.cfi_def_cfa_offset 9
 433               		.cfi_offset 7, -8
 434 0034 8F92      		push r8
 435               	.LCFI12:
 436               		.cfi_def_cfa_offset 10
 437               		.cfi_offset 8, -9
 438 0036 9F92      		push r9
 439               	.LCFI13:
 440               		.cfi_def_cfa_offset 11
 441               		.cfi_offset 9, -10
 442 0038 AF92      		push r10
 443               	.LCFI14:
 444               		.cfi_def_cfa_offset 12
 445               		.cfi_offset 10, -11
 446 003a BF92      		push r11
 447               	.LCFI15:
 448               		.cfi_def_cfa_offset 13
 449               		.cfi_offset 11, -12
 450 003c CF92      		push r12
 451               	.LCFI16:
 452               		.cfi_def_cfa_offset 14
 453               		.cfi_offset 12, -13
 454 003e DF92      		push r13
 455               	.LCFI17:
 456               		.cfi_def_cfa_offset 15
 457               		.cfi_offset 13, -14
 458 0040 EF92      		push r14
 459               	.LCFI18:
 460               		.cfi_def_cfa_offset 16
 461               		.cfi_offset 14, -15
 462 0042 FF92      		push r15
 463               	.LCFI19:
 464               		.cfi_def_cfa_offset 17
 465               		.cfi_offset 15, -16
 466 0044 0F93      		push r16
 467               	.LCFI20:
 468               		.cfi_def_cfa_offset 18
 469               		.cfi_offset 16, -17
 470 0046 1F93      		push r17
 471               	.LCFI21:
 472               		.cfi_def_cfa_offset 19
 473               		.cfi_offset 17, -18
 474 0048 CF93      		push r28
 475               	.LCFI22:
 476               		.cfi_def_cfa_offset 20
 477               		.cfi_offset 28, -19
 478 004a DF93      		push r29
 479               	.LCFI23:
 480               		.cfi_def_cfa_offset 21
 481               		.cfi_offset 29, -20
 482 004c CDB7      		in r28,__SP_L__
 483 004e DEB7      		in r29,__SP_H__
 484               	.LCFI24:
 485               		.cfi_def_cfa_register 28
 486 0050 6397      		sbiw r28,19
 487               	.LCFI25:
 488               		.cfi_def_cfa_offset 40
 489 0052 0FB6      		in __tmp_reg__,__SREG__
 490 0054 F894      		cli
 491 0056 DEBF      		out __SP_H__,r29
 492 0058 0FBE      		out __SREG__,__tmp_reg__
 493 005a CDBF      		out __SP_L__,r28
 494               	/* prologue: function */
 495               	/* frame size = 19 */
 496               	/* stack size = 37 */
 497               	.L__stack_usage = 37
 498 005c 082F      		mov r16,r24
 499 005e 6A01      		movw r12,r20
 500 0060 7B01      		movw r14,r22
 501               	.LVL44:
1478:stk500boot.c  **** {
 502               		.loc 1 1478 0
 503 0062 80E1      		ldi r24,lo8(16)
 504 0064 382E      		mov r3,r24
 505               	.LVL45:
1488:stk500boot.c  **** 	myAddressPointer	=	startAddress;
 506               		.loc 1 1488 0
 507 0066 10E0      		ldi r17,0
 508 0068 4E01      		movw r8,r28
 509 006a 81E1      		ldi r24,17
 510 006c 880E      		add r8,r24
 511 006e 911C      		adc r9,__zero_reg__
 512               	.LVL46:
 513               	.L35:
1492:stk500boot.c  **** 		{
 514               		.loc 1 1492 0
 515 0070 91E0      		ldi r25,1
 516 0072 C916      		cp r12,r25
 517 0074 D104      		cpc r13,__zero_reg__
 518 0076 E906      		cpc r14,r25
 519 0078 F104      		cpc r15,__zero_reg__
 520 007a 00F0      		brlo .L27
1494:stk500boot.c  **** 		}
 521               		.loc 1 1494 0
 522 007c 8E2D      		mov r24,r14
 523 007e 0E94 0000 		call PrintHexByte
 524               	.LVL47:
 525               	.L27:
1496:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 526               		.loc 1 1496 0
 527 0082 8D2D      		mov r24,r13
 528 0084 0E94 0000 		call PrintHexByte
 529               	.LVL48:
1497:stk500boot.c  **** 		sendchar(0x20);
 530               		.loc 1 1497 0
 531 0088 8C2D      		mov r24,r12
 532 008a 0E94 0000 		call PrintHexByte
 533               	.LVL49:
1498:stk500boot.c  **** 		sendchar('-');
 534               		.loc 1 1498 0
 535 008e 80E2      		ldi r24,lo8(32)
 536 0090 0E94 0000 		call sendchar
 537               	.LVL50:
1499:stk500boot.c  **** 		sendchar(0x20);
 538               		.loc 1 1499 0
 539 0094 8DE2      		ldi r24,lo8(45)
 540 0096 0E94 0000 		call sendchar
 541               	.LVL51:
1500:stk500boot.c  **** 
 542               		.loc 1 1500 0
 543 009a 80E2      		ldi r24,lo8(32)
 544 009c 0E94 0000 		call sendchar
 545               	.LVL52:
1502:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 546               		.loc 1 1502 0
 547 00a0 1982      		std Y+1,__zero_reg__
 548               	.LVL53:
 549 00a2 FE01      		movw r30,r28
 550 00a4 3196      		adiw r30,1
 551 00a6 5F01      		movw r10,r30
 552 00a8 2601      		movw r4,r12
 553 00aa 3701      		movw r6,r14
 554 00ac 2E2E      		mov r2,r30
 555 00ae BB8A      		std Y+19,r11
 556               	.LVL54:
 557               	.L34:
1505:stk500boot.c  **** 			{
 558               		.loc 1 1505 0
 559 00b0 0130      		cpi r16,lo8(1)
 560 00b2 01F0      		breq .L29
 561 00b4 00F0      		brlo .L30
 562 00b6 0230      		cpi r16,lo8(2)
 563 00b8 01F4      		brne .L28
1520:stk500boot.c  **** 					break;
 564               		.loc 1 1520 0
 565 00ba F201      		movw r30,r4
 566 00bc 1081      		ld r17,Z
 567               	.LVL55:
 568 00be 00C0      		rjmp .L28
 569               	.L30:
 570               	.LVL56:
 571               	.LBB81:
1509:stk500boot.c  **** 				#else
 572               		.loc 1 1509 0
 573               	/* #APP */
 574               	 ;  1509 "stk500boot.c" 1
 575 00c0 6BBE      		out 59, r6
 576 00c2 F201      		movw r30, r4
 577 00c4 1791      		elpm r17, Z+
 578               		
 579               	 ;  0 "" 2
 580               	.LVL57:
 581               	/* #NOAPP */
 582 00c6 00C0      		rjmp .L28
 583               	.LVL58:
 584               	.L29:
 585               	.LBE81:
1516:stk500boot.c  **** 					break;
 586               		.loc 1 1516 0
 587 00c8 C201      		movw r24,r4
 588 00ca 0E94 0000 		call eeprom_read_byte
 589               	.LVL59:
 590 00ce 182F      		mov r17,r24
 591               	.LVL60:
 592               	.L28:
1524:stk500boot.c  **** 			sendchar(0x20);
 593               		.loc 1 1524 0
 594 00d0 812F      		mov r24,r17
 595 00d2 0E94 0000 		call PrintHexByte
 596               	.LVL61:
1525:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 597               		.loc 1 1525 0
 598 00d6 80E2      		ldi r24,lo8(32)
 599 00d8 0E94 0000 		call sendchar
 600               	.LVL62:
1526:stk500boot.c  **** 			{
 601               		.loc 1 1526 0
 602 00dc 80EE      		ldi r24,lo8(-32)
 603 00de 810F      		add r24,r17
 604 00e0 8F35      		cpi r24,lo8(95)
 605 00e2 00F4      		brsh .L32
1528:stk500boot.c  **** 			}
 606               		.loc 1 1528 0
 607 00e4 F501      		movw r30,r10
 608 00e6 1083      		st Z,r17
 609 00e8 00C0      		rjmp .L33
 610               	.L32:
1532:stk500boot.c  **** 			}
 611               		.loc 1 1532 0
 612 00ea 8EE2      		ldi r24,lo8(46)
 613 00ec F501      		movw r30,r10
 614 00ee 8083      		st Z,r24
 615               	.L33:
1535:stk500boot.c  **** 		}
 616               		.loc 1 1535 0
 617 00f0 9FEF      		ldi r25,-1
 618 00f2 491A      		sub r4,r25
 619 00f4 590A      		sbc r5,r25
 620 00f6 690A      		sbc r6,r25
 621 00f8 790A      		sbc r7,r25
 622               	.LVL63:
 623 00fa EFEF      		ldi r30,-1
 624 00fc AE1A      		sub r10,r30
 625 00fe BE0A      		sbc r11,r30
1503:stk500boot.c  **** 		{
 626               		.loc 1 1503 0
 627 0100 A814      		cp r10,r8
 628 0102 B904      		cpc r11,r9
 629 0104 01F4      		brne .L34
 630 0106 F0E1      		ldi r31,16
 631 0108 CF0E      		add r12,r31
 632 010a D11C      		adc r13,__zero_reg__
 633 010c E11C      		adc r14,__zero_reg__
 634 010e F11C      		adc r15,__zero_reg__
1537:stk500boot.c  **** 		PrintString(asciiDump);
 635               		.loc 1 1537 0
 636 0110 198A      		std Y+17,__zero_reg__
1538:stk500boot.c  **** 		PrintNewLine();
 637               		.loc 1 1538 0
 638 0112 822D      		mov r24,r2
 639 0114 9B89      		ldd r25,Y+19
 640 0116 0E94 0000 		call PrintString
 641               	.LVL64:
1539:stk500boot.c  **** 
 642               		.loc 1 1539 0
 643 011a 0E94 0000 		call PrintNewLine
 644               	.LVL65:
 645 011e 3A94      		dec r3
 646               	.LVL66:
1490:stk500boot.c  **** 	{
 647               		.loc 1 1490 0
 648 0120 3110      		cpse r3,__zero_reg__
 649 0122 00C0      		rjmp .L35
 650               	/* epilogue start */
1543:stk500boot.c  **** 
 651               		.loc 1 1543 0
 652 0124 6396      		adiw r28,19
 653 0126 0FB6      		in __tmp_reg__,__SREG__
 654 0128 F894      		cli
 655 012a DEBF      		out __SP_H__,r29
 656 012c 0FBE      		out __SREG__,__tmp_reg__
 657 012e CDBF      		out __SP_L__,r28
 658 0130 DF91      		pop r29
 659 0132 CF91      		pop r28
 660 0134 1F91      		pop r17
 661               	.LVL67:
 662 0136 0F91      		pop r16
 663               	.LVL68:
 664 0138 FF90      		pop r15
 665 013a EF90      		pop r14
 666 013c DF90      		pop r13
 667 013e CF90      		pop r12
 668               	.LVL69:
 669 0140 BF90      		pop r11
 670 0142 AF90      		pop r10
 671 0144 9F90      		pop r9
 672 0146 8F90      		pop r8
 673 0148 7F90      		pop r7
 674 014a 6F90      		pop r6
 675 014c 5F90      		pop r5
 676 014e 4F90      		pop r4
 677 0150 3F90      		pop r3
 678               	.LVL70:
 679 0152 2F90      		pop r2
 680 0154 0895      		ret
 681               		.cfi_endproc
 682               	.LFE34:
 684               		.text
 685               	.global	PrintDecInt
 687               	PrintDecInt:
 688               	.LFB23:
1369:stk500boot.c  **** int	theChar;
 689               		.loc 1 1369 0
 690               		.cfi_startproc
 691               	.LVL71:
 692 00b8 0F93      		push r16
 693               	.LCFI26:
 694               		.cfi_def_cfa_offset 4
 695               		.cfi_offset 16, -3
 696 00ba 1F93      		push r17
 697               	.LCFI27:
 698               		.cfi_def_cfa_offset 5
 699               		.cfi_offset 17, -4
 700 00bc CF93      		push r28
 701               	.LCFI28:
 702               		.cfi_def_cfa_offset 6
 703               		.cfi_offset 28, -5
 704 00be DF93      		push r29
 705               	.LCFI29:
 706               		.cfi_def_cfa_offset 7
 707               		.cfi_offset 29, -6
 708               	/* prologue: function */
 709               	/* frame size = 0 */
 710               	/* stack size = 4 */
 711               	.L__stack_usage = 4
 712 00c0 EC01      		movw r28,r24
 713 00c2 8B01      		movw r16,r22
 714               	.LVL72:
1375:stk500boot.c  **** 	{
 715               		.loc 1 1375 0
 716 00c4 8536      		cpi r24,101
 717 00c6 9105      		cpc r25,__zero_reg__
 718 00c8 04F4      		brge .L39
1375:stk500boot.c  **** 	{
 719               		.loc 1 1375 0 is_stmt 0 discriminator 1
 720 00ca 6330      		cpi r22,3
 721 00cc 7105      		cpc r23,__zero_reg__
 722 00ce 04F0      		brlt .L40
 723               	.L39:
 724               	.LVL73:
1378:stk500boot.c  **** 	}
 725               		.loc 1 1378 0 is_stmt 1
 726 00d0 CE01      		movw r24,r28
 727               	.LVL74:
 728 00d2 64E6      		ldi r22,lo8(100)
 729 00d4 70E0      		ldi r23,0
 730               	.LVL75:
 731 00d6 0E94 0000 		call __divmodhi4
 732               	.LVL76:
 733 00da 80E3      		ldi r24,lo8(48)
 734 00dc 860F      		add r24,r22
 735 00de 0E94 0000 		call sendchar
 736               	.LVL77:
 737               	.L40:
1381:stk500boot.c  **** 	{
 738               		.loc 1 1381 0
 739 00e2 CB30      		cpi r28,11
 740 00e4 D105      		cpc r29,__zero_reg__
 741 00e6 04F4      		brge .L41
1381:stk500boot.c  **** 	{
 742               		.loc 1 1381 0 is_stmt 0 discriminator 1
 743 00e8 0230      		cpi r16,2
 744 00ea 1105      		cpc r17,__zero_reg__
 745 00ec 04F0      		brlt .L42
 746               	.L41:
 747               	.LVL78:
1384:stk500boot.c  **** 	}
 748               		.loc 1 1384 0 is_stmt 1
 749 00ee CE01      		movw r24,r28
 750 00f0 64E6      		ldi r22,lo8(100)
 751 00f2 70E0      		ldi r23,0
 752 00f4 0E94 0000 		call __divmodhi4
 753 00f8 6AE0      		ldi r22,lo8(10)
 754 00fa 70E0      		ldi r23,0
 755 00fc 0E94 0000 		call __divmodhi4
 756 0100 80E3      		ldi r24,lo8(48)
 757 0102 860F      		add r24,r22
 758 0104 0E94 0000 		call sendchar
 759               	.LVL79:
 760               	.L42:
1387:stk500boot.c  **** }
 761               		.loc 1 1387 0
 762 0108 CE01      		movw r24,r28
 763 010a 6AE0      		ldi r22,lo8(10)
 764 010c 70E0      		ldi r23,0
 765 010e 0E94 0000 		call __divmodhi4
 766 0112 805D      		subi r24,lo8(-(48))
 767               	/* epilogue start */
1388:stk500boot.c  **** 
 768               		.loc 1 1388 0
 769 0114 DF91      		pop r29
 770 0116 CF91      		pop r28
 771               	.LVL80:
 772 0118 1F91      		pop r17
 773 011a 0F91      		pop r16
 774               	.LVL81:
1387:stk500boot.c  **** }
 775               		.loc 1 1387 0
 776 011c 0C94 0000 		jmp sendchar
 777               	.LVL82:
 778               		.cfi_endproc
 779               	.LFE23:
 781               		.section	.text.startup,"ax",@progbits
 782               	.global	main
 784               	main:
 785               	.LFB17:
 532:stk500boot.c  **** 	address_t		address			=	0;
 786               		.loc 1 532 0
 787               		.cfi_startproc
 788 0000 CF93      		push r28
 789               	.LCFI30:
 790               		.cfi_def_cfa_offset 4
 791               		.cfi_offset 28, -3
 792 0002 DF93      		push r29
 793               	.LCFI31:
 794               		.cfi_def_cfa_offset 5
 795               		.cfi_offset 29, -4
 796 0004 CDB7      		in r28,__SP_L__
 797 0006 DEB7      		in r29,__SP_H__
 798               	.LCFI32:
 799               		.cfi_def_cfa_register 28
 800 0008 CD52      		subi r28,45
 801 000a D140      		sbci r29,1
 802               	.LCFI33:
 803               		.cfi_def_cfa_offset 306
 804 000c 0FB6      		in __tmp_reg__,__SREG__
 805 000e F894      		cli
 806 0010 DEBF      		out __SP_H__,r29
 807 0012 0FBE      		out __SREG__,__tmp_reg__
 808 0014 CDBF      		out __SP_L__,r28
 809               	/* prologue: function */
 810               	/* frame size = 301 */
 811               	/* stack size = 303 */
 812               	.L__stack_usage = 303
 813               	.LVL83:
 553:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 814               		.loc 1 553 0
 815               	/* #APP */
 816               	 ;  553 "stk500boot.c" 1
 817               		.set __stack, 8703
 818               	 ;  0 "" 2
 554:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 819               		.loc 1 554 0
 820               	 ;  554 "stk500boot.c" 1
 821 0016 01E2      		ldi	16, 33
 822               	 ;  0 "" 2
 555:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 823               		.loc 1 555 0
 824               	 ;  555 "stk500boot.c" 1
 825 0018 0EBF      		out 62,16
 826               	 ;  0 "" 2
 556:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 827               		.loc 1 556 0
 828               	 ;  556 "stk500boot.c" 1
 829 001a 0FEF      		ldi	16, 255
 830               	 ;  0 "" 2
 557:stk500boot.c  **** 
 831               		.loc 1 557 0
 832               	 ;  557 "stk500boot.c" 1
 833 001c 0DBF      		out 61,16
 834               	 ;  0 "" 2
 564:stk500boot.c  **** 
 835               		.loc 1 564 0
 836               	/* #NOAPP */
 837 001e 94B7      		in r25,0x34
 838               	.LVL84:
 566:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 839               		.loc 1 566 0
 840               	/* #APP */
 841               	 ;  566 "stk500boot.c" 1
 842 0020 F894      		cli
 843               	 ;  0 "" 2
 567:stk500boot.c  **** 	
 844               		.loc 1 567 0
 845               	 ;  567 "stk500boot.c" 1
 846 0022 A895      		wdr
 847               	 ;  0 "" 2
 570:stk500boot.c  **** 	
 848               		.loc 1 570 0
 849               	/* #NOAPP */
 850 0024 84B7      		in r24,0x34
 851 0026 877F      		andi r24,lo8(-9)
 852 0028 84BF      		out 0x34,r24
 572:stk500boot.c  **** 	WDTCSR	=	0;
 853               		.loc 1 572 0
 854 002a 8091 6000 		lds r24,96
 855 002e 8861      		ori r24,lo8(24)
 856 0030 8093 6000 		sts 96,r24
 573:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 857               		.loc 1 573 0
 858 0034 1092 6000 		sts 96,__zero_reg__
 574:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 859               		.loc 1 574 0
 860               	/* #APP */
 861               	 ;  574 "stk500boot.c" 1
 862 0038 7894      		sei
 863               	 ;  0 "" 2
 576:stk500boot.c  **** 	{
 864               		.loc 1 576 0
 865               	/* #NOAPP */
 866 003a 93FF      		sbrs r25,3
 867 003c 00C0      		rjmp .L44
 578:stk500boot.c  **** 	}
 868               		.loc 1 578 0
 869 003e E091 0000 		lds r30,app_start
 870 0042 F091 0000 		lds r31,app_start+1
 871 0046 1995      		eicall
 872               	.LVL85:
 873               	.L44:
 600:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 874               		.loc 1 600 0
 875 0048 9A9A      		sbi 0x13,2
 602:stk500boot.c  **** 
 876               		.loc 1 602 0
 877 004a A29A      		sbi 0x14,2
 620:stk500boot.c  **** #endif
 878               		.loc 1 620 0
 879 004c 8091 C000 		lds r24,192
 880 0050 8260      		ori r24,lo8(2)
 881 0052 8093 C000 		sts 192,r24
 622:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 882               		.loc 1 622 0
 883 0056 80E1      		ldi r24,lo8(16)
 884 0058 8093 C400 		sts 196,r24
 623:stk500boot.c  **** 
 885               		.loc 1 623 0
 886 005c 88E1      		ldi r24,lo8(24)
 887 005e 8093 C100 		sts 193,r24
 625:stk500boot.c  **** 
 888               		.loc 1 625 0
 889               	/* #APP */
 890               	 ;  625 "stk500boot.c" 1
 891 0062 0000      		nop
 892               	 ;  0 "" 2
 893               	/* #NOAPP */
 894 0064 00E0      		ldi r16,0
 895 0066 10E0      		ldi r17,0
 896 0068 C12C      		mov r12,__zero_reg__
 897 006a D12C      		mov r13,__zero_reg__
 898 006c 7601      		movw r14,r12
 655:stk500boot.c  **** 			{
 899               		.loc 1 655 0
 900 006e A7EC      		ldi r26,lo8(-57)
 901 0070 8A2E      		mov r8,r26
 902 0072 ABE1      		ldi r26,lo8(27)
 903 0074 9A2E      		mov r9,r26
 904 0076 A12C      		mov r10,__zero_reg__
 905 0078 B12C      		mov r11,__zero_reg__
 658:stk500boot.c  **** 			}
 906               		.loc 1 658 0
 907 007a B4E0      		ldi r27,lo8(4)
 908 007c 7B2E      		mov r7,r27
 909               	.LVL86:
 910               	.L45:
 911               	.LBB160:
 912               	.LBB161:
 477:stk500boot.c  **** }
 913               		.loc 1 477 0
 914 007e 8091 C000 		lds r24,192
 915               	.LBE161:
 916               	.LBE160:
 646:stk500boot.c  **** 		{
 917               		.loc 1 646 0
 918 0082 87FD      		sbrc r24,7
 919 0084 00C0      		rjmp .L270
 646:stk500boot.c  **** 		{
 920               		.loc 1 646 0 is_stmt 0 discriminator 1
 921 0086 0115      		cp r16,__zero_reg__
 922 0088 1105      		cpc r17,__zero_reg__
 923 008a 01F4      		brne .L270
 924               	.LVL87:
 925               	.LBB162:
 926               	.LBB163:
 927               		.loc 2 187 0 is_stmt 1
 928 008c 25E0      		ldi r18,lo8(5)
 929 008e 2A95      	1:	dec r18
 930 0090 01F4      		brne 1b
 931 0092 0000      		nop
 932               	.LVL88:
 933               	.LBE163:
 934               	.LBE162:
 649:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 935               		.loc 1 649 0
 936 0094 3FEF      		ldi r19,-1
 937 0096 C31A      		sub r12,r19
 938 0098 D30A      		sbc r13,r19
 939 009a E30A      		sbc r14,r19
 940 009c F30A      		sbc r15,r19
 941               	.LVL89:
 652:stk500boot.c  **** 			}
 942               		.loc 1 652 0
 943 009e 91E0      		ldi r25,lo8(1)
 944 00a0 80E0      		ldi r24,0
 945 00a2 41E2      		ldi r20,33
 946 00a4 C416      		cp r12,r20
 947 00a6 4EE4      		ldi r20,78
 948 00a8 D406      		cpc r13,r20
 949 00aa E104      		cpc r14,__zero_reg__
 950 00ac F104      		cpc r15,__zero_reg__
 951 00ae 00F4      		brsh .L46
 952 00b0 90E0      		ldi r25,0
 953               	.L46:
 954 00b2 092F      		mov r16,r25
 955               	.LVL90:
 956 00b4 182F      		mov r17,r24
 655:stk500boot.c  **** 			{
 957               		.loc 1 655 0
 958 00b6 C701      		movw r24,r14
 959 00b8 B601      		movw r22,r12
 960 00ba A501      		movw r20,r10
 961 00bc 9401      		movw r18,r8
 962 00be 0E94 0000 		call __udivmodsi4
 963 00c2 672B      		or r22,r23
 964 00c4 682B      		or r22,r24
 965 00c6 692B      		or r22,r25
 966 00c8 01F4      		brne .L45
 658:stk500boot.c  **** 			}
 967               		.loc 1 658 0
 968 00ca 84B3      		in r24,0x14
 969 00cc 8725      		eor r24,r7
 970 00ce 84BB      		out 0x14,r24
 971 00d0 00C0      		rjmp .L45
 972               	.LVL91:
 973               	.L270:
 662:stk500boot.c  **** 	}
 974               		.loc 1 662 0
 975 00d2 0F5F      		subi r16,-1
 976 00d4 1F4F      		sbci r17,-1
 977               	.LVL92:
 666:stk500boot.c  **** 	{
 978               		.loc 1 666 0
 979 00d6 0130      		cpi r16,1
 980 00d8 1105      		cpc r17,__zero_reg__
 981 00da 01F0      		breq .+4
 982 00dc 0C94 0000 		jmp .L52
 983 00e0 C85D      		subi r28,lo8(-296)
 984 00e2 DE4F      		sbci r29,hi8(-296)
 985 00e4 1982      		std Y+1,__zero_reg__
 986 00e6 1882      		st Y,__zero_reg__
 987 00e8 C852      		subi r28,lo8(296)
 988 00ea D140      		sbci r29,hi8(296)
 989 00ec E12C      		mov r14,__zero_reg__
 990 00ee F12C      		mov r15,__zero_reg__
 991 00f0 612C      		mov r6,__zero_reg__
 992 00f2 B12C      		mov r11,__zero_reg__
 993 00f4 CA5D      		subi r28,lo8(-294)
 994 00f6 DE4F      		sbci r29,hi8(-294)
 995 00f8 1982      		std Y+1,__zero_reg__
 996 00fa 1882      		st Y,__zero_reg__
 997 00fc C652      		subi r28,lo8(294)
 998 00fe D140      		sbci r29,hi8(294)
 999 0100 CE5D      		subi r28,lo8(-290)
 1000 0102 DE4F      		sbci r29,hi8(-290)
 1001 0104 1882      		st Y,__zero_reg__
 1002 0106 1982      		std Y+1,__zero_reg__
 1003 0108 1A82      		std Y+2,__zero_reg__
 1004 010a 1B82      		std Y+3,__zero_reg__
 1005 010c C252      		subi r28,lo8(290)
 1006 010e D140      		sbci r29,hi8(290)
 1007 0110 212C      		mov r2,__zero_reg__
 1008 0112 312C      		mov r3,__zero_reg__
 1009 0114 2101      		movw r4,r2
 1010               	.LVL93:
 1011               	.L195:
 625:stk500boot.c  **** 
 1012               		.loc 1 625 0
 1013 0116 20E0      		ldi r18,0
 1014 0118 30E0      		ldi r19,0
 1015 011a 80E0      		ldi r24,0
 1016               	.LVL94:
 1017               	.L196:
 677:stk500boot.c  **** 				{
 1018               		.loc 1 677 0
 1019 011c 0130      		cpi r16,1
 1020 011e 1105      		cpc r17,__zero_reg__
 1021 0120 01F0      		breq .L275
 1022               	.L56:
 625:stk500boot.c  **** 
 1023               		.loc 1 625 0
 1024 0122 41E0      		ldi r20,lo8(1)
 1025 0124 52E1      		ldi r21,lo8(18)
 1026 0126 6AE7      		ldi r22,lo8(122)
 1027 0128 70E0      		ldi r23,0
 1028               	.L55:
 1029               	.LVL95:
 1030               	.LBB164:
 1031               	.LBB165:
 500:stk500boot.c  **** 	{
 1032               		.loc 1 500 0
 1033 012a 9091 C000 		lds r25,192
 1034 012e 97FD      		sbrc r25,7
 1035 0130 00C0      		rjmp .L275
 1036               	.LVL96:
 1037 0132 4150      		subi r20,1
 1038 0134 5109      		sbc r21,__zero_reg__
 1039 0136 6109      		sbc r22,__zero_reg__
 1040 0138 7109      		sbc r23,__zero_reg__
 1041               	.LVL97:
 504:stk500boot.c  **** 		{
 1042               		.loc 1 504 0
 1043 013a 01F4      		brne .L55
 1044               	.LVL98:
 1045               	.LBB166:
 1046               	.LBB167:
 508:stk500boot.c  **** 		#else
 1047               		.loc 1 508 0
 1048               	/* #APP */
 1049               	 ;  508 "stk500boot.c" 1
 1050 013c 6BBF      		out 59, r22
 1051 013e FA01      		movw r30, r20
 1052 0140 4791      		elpm r20, Z+
 1053 0142 5691      		elpm r21, Z
 1054               		
 1055               	 ;  0 "" 2
 1056               	.LVL99:
 1057               	/* #NOAPP */
 1058               	.LBE167:
 512:stk500boot.c  **** 			{
 1059               		.loc 1 512 0
 1060 0144 4F3F      		cpi r20,-1
 1061 0146 5F4F      		sbci r21,-1
 1062 0148 01F0      		breq .L56
 514:stk500boot.c  **** 						"clr	r30		\n\t"
 1063               		.loc 1 514 0
 1064               	/* #APP */
 1065               	 ;  514 "stk500boot.c" 1
 1066 014a EE27      		clr	r30		
 1067 014c FF27      		clr	r31		
 1068 014e 0994      		ijmp	
 1069               		
 1070               	 ;  0 "" 2
 1071               	/* #NOAPP */
 1072 0150 00C0      		rjmp .L56
 1073               	.LVL100:
 1074               	.L275:
 1075               	.LBE166:
 523:stk500boot.c  **** }
 1076               		.loc 1 523 0
 1077 0152 9091 C600 		lds r25,198
 1078               	.LVL101:
 1079               	.LBE165:
 1080               	.LBE164:
 690:stk500boot.c  **** 
 1081               		.loc 1 690 0
 1082 0156 C85D      		subi r28,lo8(-296)
 1083 0158 DE4F      		sbci r29,hi8(-296)
 1084 015a A881      		ld r26,Y
 1085 015c B981      		ldd r27,Y+1
 1086 015e C852      		subi r28,lo8(296)
 1087 0160 D140      		sbci r29,hi8(296)
 1088 0162 1196      		adiw r26,1
 1089 0164 C85D      		subi r28,lo8(-296)
 1090 0166 DE4F      		sbci r29,hi8(-296)
 1091 0168 B983      		std Y+1,r27
 1092 016a A883      		st Y,r26
 1093 016c C852      		subi r28,lo8(296)
 1094 016e D140      		sbci r29,hi8(296)
 1095               	.LVL102:
 692:stk500boot.c  **** 				{
 1096               		.loc 1 692 0
 1097 0170 9132      		cpi r25,lo8(33)
 1098 0172 01F0      		breq .+2
 1099 0174 00C0      		rjmp .L58
 692:stk500boot.c  **** 				{
 1100               		.loc 1 692 0 is_stmt 0 discriminator 1
 1101 0176 1A97      		sbiw r26,10
 1102 0178 00F0      		brlo .+2
 1103 017a 00C0      		rjmp .L201
 694:stk500boot.c  **** 					if (exPointCntr == 3)
 1104               		.loc 1 694 0 is_stmt 1
 1105 017c BFEF      		ldi r27,-1
 1106 017e EB1A      		sub r14,r27
 1107 0180 FB0A      		sbc r15,r27
 1108               	.LVL103:
 695:stk500boot.c  **** 					{
 1109               		.loc 1 695 0
 1110 0182 E3E0      		ldi r30,3
 1111 0184 EE16      		cp r14,r30
 1112 0186 F104      		cpc r15,__zero_reg__
 1113 0188 01F0      		breq .+2
 1114 018a 00C0      		rjmp .L59
 1115 018c F5E0      		ldi r31,lo8(5)
 1116 018e EF2E      		mov r14,r31
 1117 0190 F12C      		mov r15,__zero_reg__
 1118               	.LVL104:
 1119               	.L62:
 625:stk500boot.c  **** 
 1120               		.loc 1 625 0
 1121 0192 09E1      		ldi r16,lo8(25)
 1122 0194 10E0      		ldi r17,0
 1123               	.LVL105:
 1124               	.L61:
 1125               	.LBB168:
 1126               	.LBB169:
1756:stk500boot.c  **** 
1757:stk500boot.c  **** //************************************************************************
1758:stk500boot.c  **** static void	ListAvailablePorts(void)
1759:stk500boot.c  **** {
1760:stk500boot.c  **** 
1761:stk500boot.c  **** #ifdef DDRA
1762:stk500boot.c  **** 	PrintAvailablePort('A');
1763:stk500boot.c  **** #endif
1764:stk500boot.c  **** 
1765:stk500boot.c  **** #ifdef DDRB
1766:stk500boot.c  **** 	PrintAvailablePort('B');
1767:stk500boot.c  **** #endif
1768:stk500boot.c  **** 
1769:stk500boot.c  **** #ifdef DDRC
1770:stk500boot.c  **** 	PrintAvailablePort('C');
1771:stk500boot.c  **** #endif
1772:stk500boot.c  **** 
1773:stk500boot.c  **** #ifdef DDRD
1774:stk500boot.c  **** 	PrintAvailablePort('D');
1775:stk500boot.c  **** #endif
1776:stk500boot.c  **** 
1777:stk500boot.c  **** #ifdef DDRE
1778:stk500boot.c  **** 	PrintAvailablePort('E');
1779:stk500boot.c  **** #endif
1780:stk500boot.c  **** 
1781:stk500boot.c  **** #ifdef DDRF
1782:stk500boot.c  **** 	PrintAvailablePort('F');
1783:stk500boot.c  **** #endif
1784:stk500boot.c  **** 
1785:stk500boot.c  **** #ifdef DDRG
1786:stk500boot.c  **** 	PrintAvailablePort('G');
1787:stk500boot.c  **** #endif
1788:stk500boot.c  **** 
1789:stk500boot.c  **** #ifdef DDRH
1790:stk500boot.c  **** 	PrintAvailablePort('H');
1791:stk500boot.c  **** #endif
1792:stk500boot.c  **** 
1793:stk500boot.c  **** #ifdef DDRI
1794:stk500boot.c  **** 	PrintAvailablePort('I');
1795:stk500boot.c  **** #endif
1796:stk500boot.c  **** 
1797:stk500boot.c  **** #ifdef DDRJ
1798:stk500boot.c  **** 	PrintAvailablePort('J');
1799:stk500boot.c  **** #endif
1800:stk500boot.c  **** 
1801:stk500boot.c  **** #ifdef DDRK
1802:stk500boot.c  **** 	PrintAvailablePort('K');
1803:stk500boot.c  **** #endif
1804:stk500boot.c  **** 
1805:stk500boot.c  **** #ifdef DDRL
1806:stk500boot.c  **** 	PrintAvailablePort('L');
1807:stk500boot.c  **** #endif
1808:stk500boot.c  **** 
1809:stk500boot.c  **** }
1810:stk500boot.c  **** 
1811:stk500boot.c  **** //************************************************************************
1812:stk500boot.c  **** static void	AVR_PortOutput(void)
1813:stk500boot.c  **** {
1814:stk500boot.c  **** char	portLetter;
1815:stk500boot.c  **** char	getCharFlag;
1816:stk500boot.c  **** 
1817:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1818:stk500boot.c  **** 
1819:stk500boot.c  **** 	portLetter	=	recchar();
1820:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1821:stk500boot.c  **** 	sendchar(portLetter);
1822:stk500boot.c  **** 	PrintNewLine();
1823:stk500boot.c  **** 
1824:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1825:stk500boot.c  **** 	{
1826:stk500boot.c  **** 		getCharFlag	=	true;
1827:stk500boot.c  **** 		switch(portLetter)
1828:stk500boot.c  **** 		{
1829:stk500boot.c  **** 		#ifdef DDRA
1830:stk500boot.c  **** 			case 'A':
1831:stk500boot.c  **** 				DDRA	=	0xff;
1832:stk500boot.c  **** 				while (!Serial_Available())
1833:stk500boot.c  **** 				{
1834:stk500boot.c  **** 					PORTA	^=	0xff;
1835:stk500boot.c  **** 					delay_ms(200);
1836:stk500boot.c  **** 				}
1837:stk500boot.c  **** 				PORTA	=	0;
1838:stk500boot.c  **** 				break;
1839:stk500boot.c  **** 		#endif
1840:stk500boot.c  **** 
1841:stk500boot.c  **** 		#ifdef DDRB
1842:stk500boot.c  **** 			case 'B':
1843:stk500boot.c  **** 				DDRB	=	0xff;
1844:stk500boot.c  **** 				while (!Serial_Available())
1845:stk500boot.c  **** 				{
1846:stk500boot.c  **** 					PORTB	^=	0xff;
1847:stk500boot.c  **** 					delay_ms(200);
1848:stk500boot.c  **** 				}
1849:stk500boot.c  **** 				PORTB	=	0;
1850:stk500boot.c  **** 				break;
1851:stk500boot.c  **** 		#endif
1852:stk500boot.c  **** 
1853:stk500boot.c  **** 		#ifdef DDRC
1854:stk500boot.c  **** 			case 'C':
1855:stk500boot.c  **** 				DDRC	=	0xff;
1856:stk500boot.c  **** 				while (!Serial_Available())
1857:stk500boot.c  **** 				{
1858:stk500boot.c  **** 					PORTC	^=	0xff;
1859:stk500boot.c  **** 					delay_ms(200);
1860:stk500boot.c  **** 				}
1861:stk500boot.c  **** 				PORTC	=	0;
1862:stk500boot.c  **** 				break;
1863:stk500boot.c  **** 		#endif
1864:stk500boot.c  **** 
1865:stk500boot.c  **** 		#ifdef DDRD
1866:stk500boot.c  **** 			case 'D':
1867:stk500boot.c  **** 				DDRD	=	0xff;
1868:stk500boot.c  **** 				while (!Serial_Available())
1869:stk500boot.c  **** 				{
1870:stk500boot.c  **** 					PORTD	^=	0xff;
1871:stk500boot.c  **** 					delay_ms(200);
1872:stk500boot.c  **** 				}
1873:stk500boot.c  **** 				PORTD	=	0;
1874:stk500boot.c  **** 				break;
1875:stk500boot.c  **** 		#endif
1876:stk500boot.c  **** 
1877:stk500boot.c  **** 		#ifdef DDRE
1878:stk500boot.c  **** 			case 'E':
1879:stk500boot.c  **** 				DDRE	=	0xff;
1880:stk500boot.c  **** 				while (!Serial_Available())
1881:stk500boot.c  **** 				{
1882:stk500boot.c  **** 					PORTE	^=	0xff;
1883:stk500boot.c  **** 					delay_ms(200);
1884:stk500boot.c  **** 				}
1885:stk500boot.c  **** 				PORTE	=	0;
1886:stk500boot.c  **** 				break;
1887:stk500boot.c  **** 		#endif
1888:stk500boot.c  **** 
1889:stk500boot.c  **** 		#ifdef DDRF
1890:stk500boot.c  **** 			case 'F':
1891:stk500boot.c  **** 				DDRF	=	0xff;
1892:stk500boot.c  **** 				while (!Serial_Available())
1893:stk500boot.c  **** 				{
1894:stk500boot.c  **** 					PORTF	^=	0xff;
1895:stk500boot.c  **** 					delay_ms(200);
1896:stk500boot.c  **** 				}
1897:stk500boot.c  **** 				PORTF	=	0;
1898:stk500boot.c  **** 				break;
1899:stk500boot.c  **** 		#endif
1900:stk500boot.c  **** 
1901:stk500boot.c  **** 		#ifdef DDRG
1902:stk500boot.c  **** 			case 'G':
1903:stk500boot.c  **** 				DDRG	=	0xff;
1904:stk500boot.c  **** 				while (!Serial_Available())
1905:stk500boot.c  **** 				{
1906:stk500boot.c  **** 					PORTG	^=	0xff;
1907:stk500boot.c  **** 					delay_ms(200);
1908:stk500boot.c  **** 				}
1909:stk500boot.c  **** 				PORTG	=	0;
1910:stk500boot.c  **** 				break;
1911:stk500boot.c  **** 		#endif
1912:stk500boot.c  **** 
1913:stk500boot.c  **** 		#ifdef DDRH
1914:stk500boot.c  **** 			case 'H':
1915:stk500boot.c  **** 				DDRH	=	0xff;
1916:stk500boot.c  **** 				while (!Serial_Available())
1917:stk500boot.c  **** 				{
1918:stk500boot.c  **** 					PORTH	^=	0xff;
1919:stk500boot.c  **** 					delay_ms(200);
1920:stk500boot.c  **** 				}
1921:stk500boot.c  **** 				PORTH	=	0;
1922:stk500boot.c  **** 				break;
1923:stk500boot.c  **** 		#endif
1924:stk500boot.c  **** 
1925:stk500boot.c  **** 		#ifdef DDRI
1926:stk500boot.c  **** 			case 'I':
1927:stk500boot.c  **** 				DDRI	=	0xff;
1928:stk500boot.c  **** 				while (!Serial_Available())
1929:stk500boot.c  **** 				{
1930:stk500boot.c  **** 					PORTI	^=	0xff;
1931:stk500boot.c  **** 					delay_ms(200);
1932:stk500boot.c  **** 				}
1933:stk500boot.c  **** 				PORTI	=	0;
1934:stk500boot.c  **** 				break;
1935:stk500boot.c  **** 		#endif
1936:stk500boot.c  **** 
1937:stk500boot.c  **** 		#ifdef DDRJ
1938:stk500boot.c  **** 			case 'J':
1939:stk500boot.c  **** 				DDRJ	=	0xff;
1940:stk500boot.c  **** 				while (!Serial_Available())
1941:stk500boot.c  **** 				{
1942:stk500boot.c  **** 					PORTJ	^=	0xff;
1943:stk500boot.c  **** 					delay_ms(200);
1944:stk500boot.c  **** 				}
1945:stk500boot.c  **** 				PORTJ	=	0;
1946:stk500boot.c  **** 				break;
1947:stk500boot.c  **** 		#endif
1948:stk500boot.c  **** 
1949:stk500boot.c  **** 		#ifdef DDRK
1950:stk500boot.c  **** 			case 'K':
1951:stk500boot.c  **** 				DDRK	=	0xff;
1952:stk500boot.c  **** 				while (!Serial_Available())
1953:stk500boot.c  **** 				{
1954:stk500boot.c  **** 					PORTK	^=	0xff;
1955:stk500boot.c  **** 					delay_ms(200);
1956:stk500boot.c  **** 				}
1957:stk500boot.c  **** 				PORTK	=	0;
1958:stk500boot.c  **** 				break;
1959:stk500boot.c  **** 		#endif
1960:stk500boot.c  **** 
1961:stk500boot.c  **** 		#ifdef DDRL
1962:stk500boot.c  **** 			case 'L':
1963:stk500boot.c  **** 				DDRL	=	0xff;
1964:stk500boot.c  **** 				while (!Serial_Available())
1965:stk500boot.c  **** 				{
1966:stk500boot.c  **** 					PORTL	^=	0xff;
1967:stk500boot.c  **** 					delay_ms(200);
1968:stk500boot.c  **** 				}
1969:stk500boot.c  **** 				PORTL	=	0;
1970:stk500boot.c  **** 				break;
1971:stk500boot.c  **** 		#endif
1972:stk500boot.c  **** 
1973:stk500boot.c  **** 			default:
1974:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
1975:stk500boot.c  **** 				getCharFlag	=	false;
1976:stk500boot.c  **** 				break;
1977:stk500boot.c  **** 		}
1978:stk500boot.c  **** 		if (getCharFlag)
1979:stk500boot.c  **** 		{
1980:stk500boot.c  **** 			recchar();
1981:stk500boot.c  **** 		}
1982:stk500boot.c  **** 	}
1983:stk500boot.c  **** 	else
1984:stk500boot.c  **** 	{
1985:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
1986:stk500boot.c  **** 	}
1987:stk500boot.c  **** }
1988:stk500boot.c  **** 
1989:stk500boot.c  **** 
1990:stk500boot.c  **** //*******************************************************************
1991:stk500boot.c  **** static void PrintHelp(void)
1992:stk500boot.c  **** {
1993:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
1994:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
1995:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
1996:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
1997:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
1998:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
1999:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
2000:stk500boot.c  **** 
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
2002:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2003:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2004:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2005:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2006:stk500boot.c  **** }
2007:stk500boot.c  **** 
2008:stk500boot.c  **** //************************************************************************
2009:stk500boot.c  **** static void	RunMonitor(void)
2010:stk500boot.c  **** {
2011:stk500boot.c  **** char			keepGoing;
2012:stk500boot.c  **** unsigned char	theChar;
2013:stk500boot.c  **** int				ii, jj;
2014:stk500boot.c  **** 
2015:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2016:stk500boot.c  **** 	{
2017:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2018:stk500boot.c  **** 		{
2019:stk500boot.c  **** 			sendchar('!');
 1127               		.loc 1 2019 0
 1128 0196 81E2      		ldi r24,lo8(33)
 1129 0198 0E94 0000 		call sendchar
 1130               	.LVL106:
 1131 019c 0150      		subi r16,1
 1132 019e 1109      		sbc r17,__zero_reg__
 1133               	.LVL107:
2017:stk500boot.c  **** 		{
 1134               		.loc 1 2017 0
 1135 01a0 01F4      		brne .L61
2020:stk500boot.c  **** 		}
2021:stk500boot.c  **** 		PrintNewLine();
 1136               		.loc 1 2021 0
 1137 01a2 0E94 0000 		call PrintNewLine
 1138               	.LVL108:
 1139 01a6 F1E0      		ldi r31,1
 1140 01a8 EF1A      		sub r14,r31
 1141 01aa F108      		sbc r15,__zero_reg__
 1142               	.LVL109:
2015:stk500boot.c  **** 	{
 1143               		.loc 1 2015 0
 1144 01ac 01F4      		brne .L62
2022:stk500boot.c  **** 	}
2023:stk500boot.c  **** 
2024:stk500boot.c  **** 	gRamIndex			=	0;
 1145               		.loc 1 2024 0
 1146 01ae 1092 0000 		sts gRamIndex,__zero_reg__
 1147 01b2 1092 0000 		sts gRamIndex+1,__zero_reg__
 1148 01b6 1092 0000 		sts gRamIndex+2,__zero_reg__
 1149 01ba 1092 0000 		sts gRamIndex+3,__zero_reg__
2025:stk500boot.c  **** 	gFlashIndex			=	0;
 1150               		.loc 1 2025 0
 1151 01be 1092 0000 		sts gFlashIndex,__zero_reg__
 1152 01c2 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1153 01c6 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1154 01ca 1092 0000 		sts gFlashIndex+3,__zero_reg__
2026:stk500boot.c  **** 	gEepromIndex		=	0;
 1155               		.loc 1 2026 0
 1156 01ce 1092 0000 		sts gEepromIndex,__zero_reg__
 1157 01d2 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1158 01d6 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1159 01da 1092 0000 		sts gEepromIndex+3,__zero_reg__
2027:stk500boot.c  **** 
2028:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1160               		.loc 1 2028 0
 1161 01de 60E0      		ldi r22,0
 1162 01e0 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1163 01e2 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1164 01e4 0E94 0000 		call PrintFromPROGMEMln
 1165               	.LVL110:
 1166               	.LBB170:
 1167               	.LBB171:
1891:stk500boot.c  **** 				while (!Serial_Available())
 1168               		.loc 1 1891 0
 1169 01e8 7724      		clr r7
 1170 01ea 7A94      		dec r7
 1171               	.LVL111:
 1172               	.L198:
 1173               	.LBE171:
 1174               	.LBE170:
2029:stk500boot.c  **** 
2030:stk500boot.c  **** 	keepGoing	=	1;
2031:stk500boot.c  **** 	while (keepGoing)
2032:stk500boot.c  **** 	{
2033:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
 1175               		.loc 1 2033 0
 1176 01ec 60E0      		ldi r22,0
 1177 01ee 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 1178 01f0 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 1179 01f2 0E94 0000 		call PrintFromPROGMEM
 1180               	.LVL112:
2034:stk500boot.c  **** 		theChar	=	recchar();
 1181               		.loc 1 2034 0
 1182 01f6 0E94 0000 		call recchar
 1183               	.LVL113:
 1184 01fa 182F      		mov r17,r24
 1185               	.LVL114:
2035:stk500boot.c  **** 		if (theChar >= 0x60)
 1186               		.loc 1 2035 0
 1187 01fc 8036      		cpi r24,lo8(96)
 1188 01fe 00F0      		brlo .L64
2036:stk500boot.c  **** 		{
2037:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
 1189               		.loc 1 2037 0
 1190 0200 1F75      		andi r17,lo8(95)
 1191               	.LVL115:
 1192               	.L64:
2038:stk500boot.c  **** 		}
2039:stk500boot.c  **** 
2040:stk500boot.c  **** 		if (theChar >= 0x20)
 1193               		.loc 1 2040 0
 1194 0202 1032      		cpi r17,lo8(32)
 1195 0204 00F0      		brlo .L65
2041:stk500boot.c  **** 		{
2042:stk500boot.c  **** 			sendchar(theChar);
 1196               		.loc 1 2042 0
 1197 0206 812F      		mov r24,r17
 1198 0208 0E94 0000 		call sendchar
 1199               	.LVL116:
2043:stk500boot.c  **** 			sendchar(0x20);
 1200               		.loc 1 2043 0
 1201 020c 80E2      		ldi r24,lo8(32)
 1202 020e 0E94 0000 		call sendchar
 1203               	.LVL117:
 1204               	.L65:
2044:stk500boot.c  **** 		}
2045:stk500boot.c  **** 
2046:stk500boot.c  **** 		switch(theChar)
 1205               		.loc 1 2046 0
 1206 0212 1634      		cpi r17,lo8(70)
 1207 0214 01F4      		brne .+2
 1208 0216 00C0      		rjmp .L67
 1209 0218 00F0      		brlo .+2
 1210 021a 00C0      		rjmp .L68
 1211 021c 1034      		cpi r17,lo8(64)
 1212 021e 01F4      		brne .+2
 1213 0220 00C0      		rjmp .L69
 1214 0222 00F0      		brlo .+2
 1215 0224 00C0      		rjmp .L70
 1216 0226 1033      		cpi r17,lo8(48)
 1217 0228 01F4      		brne .+2
 1218 022a 00C0      		rjmp .L71
 1219 022c 1F33      		cpi r17,lo8(63)
 1220 022e 01F0      		breq .+2
 1221 0230 00C0      		rjmp .L66
2047:stk500boot.c  **** 		{
2048:stk500boot.c  **** 			case '0':
2049:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
2050:stk500boot.c  **** 				gFlashIndex		=	0;
2051:stk500boot.c  **** 				gRamIndex		=	0;
2052:stk500boot.c  **** 				gEepromIndex	=	0;
2053:stk500boot.c  **** 				break;
2054:stk500boot.c  **** 
2055:stk500boot.c  **** 			case '?':
2056:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
 1222               		.loc 1 2056 0
 1223 0232 62E0      		ldi r22,lo8(2)
 1224 0234 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1225 0236 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1226 0238 0E94 0000 		call PrintFromPROGMEMln
 1227               	.LVL118:
 1228               	.LBB196:
 1229               	.LBB197:
1398:stk500boot.c  **** 
 1230               		.loc 1 1398 0
 1231 023c 60E0      		ldi r22,0
 1232 023e 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1233 0240 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1234 0242 0E94 0000 		call PrintFromPROGMEMln
 1235               	.LVL119:
1400:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1236               		.loc 1 1400 0
 1237 0246 60E0      		ldi r22,0
 1238 0248 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1239 024a 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1240 024c 0E94 0000 		call PrintFromPROGMEM
 1241               	.LVL120:
1401:stk500boot.c  **** 
 1242               		.loc 1 1401 0
 1243 0250 60E0      		ldi r22,0
 1244 0252 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1245 0254 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1246 0256 0E94 0000 		call PrintFromPROGMEMln
 1247               	.LVL121:
1403:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1248               		.loc 1 1403 0
 1249 025a 60E0      		ldi r22,0
 1250 025c 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1251 025e 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1252 0260 0E94 0000 		call PrintFromPROGMEM
 1253               	.LVL122:
1404:stk500boot.c  **** 
 1254               		.loc 1 1404 0
 1255 0264 60E0      		ldi r22,0
 1256 0266 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1257 0268 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1258 026a 0E94 0000 		call PrintFromPROGMEMln
 1259               	.LVL123:
1406:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1260               		.loc 1 1406 0
 1261 026e 60E0      		ldi r22,0
 1262 0270 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1263 0272 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1264 0274 0E94 0000 		call PrintFromPROGMEM
 1265               	.LVL124:
 1266               	.LBB198:
 1267               	.LBB199:
1387:stk500boot.c  **** }
 1268               		.loc 1 1387 0
 1269 0278 86E3      		ldi r24,lo8(54)
 1270 027a 0E94 0000 		call sendchar
 1271               	.LVL125:
 1272               	.LBE199:
 1273               	.LBE198:
1408:stk500boot.c  **** 
 1274               		.loc 1 1408 0
 1275 027e 0E94 0000 		call PrintNewLine
 1276               	.LVL126:
1410:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1277               		.loc 1 1410 0
 1278 0282 60E0      		ldi r22,0
 1279 0284 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1280 0286 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1281 0288 0E94 0000 		call PrintFromPROGMEM
 1282               	.LVL127:
1411:stk500boot.c  **** 
 1283               		.loc 1 1411 0
 1284 028c 60E0      		ldi r22,0
 1285 028e 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1286 0290 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1287 0292 0E94 0000 		call PrintFromPROGMEMln
 1288               	.LVL128:
1414:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1289               		.loc 1 1414 0
 1290 0296 60E0      		ldi r22,0
 1291 0298 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1292 029a 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1293 029c 0E94 0000 		call PrintFromPROGMEM
 1294               	.LVL129:
1415:stk500boot.c  **** 
 1295               		.loc 1 1415 0
 1296 02a0 60E0      		ldi r22,0
 1297 02a2 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1298 02a4 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1299 02a6 0E94 0000 		call PrintFromPROGMEMln
 1300               	.LVL130:
1418:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
 1301               		.loc 1 1418 0
 1302 02aa 60E0      		ldi r22,0
 1303 02ac 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1304 02ae 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1305 02b0 0E94 0000 		call PrintFromPROGMEM
 1306               	.LVL131:
1420:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1307               		.loc 1 1420 0
 1308 02b4 8EE1      		ldi r24,lo8(30)
 1309 02b6 0E94 0000 		call PrintHexByte
 1310               	.LVL132:
1421:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1311               		.loc 1 1421 0
 1312 02ba 88E9      		ldi r24,lo8(-104)
 1313 02bc 0E94 0000 		call PrintHexByte
 1314               	.LVL133:
1422:stk500boot.c  **** 	PrintNewLine();
 1315               		.loc 1 1422 0
 1316 02c0 81E0      		ldi r24,lo8(1)
 1317 02c2 0E94 0000 		call PrintHexByte
 1318               	.LVL134:
1423:stk500boot.c  **** #endif
 1319               		.loc 1 1423 0
 1320 02c6 0E94 0000 		call PrintNewLine
 1321               	.LVL135:
1429:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1322               		.loc 1 1429 0
 1323 02ca 60E0      		ldi r22,0
 1324 02cc 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1325 02ce 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1326 02d0 0E94 0000 		call PrintFromPROGMEM
 1327               	.LVL136:
 1328               	.LBB200:
1430:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1329               		.loc 1 1430 0
 1330 02d4 29E0      		ldi r18,lo8(9)
 1331 02d6 E0E0      		ldi r30,0
 1332 02d8 F0E0      		ldi r31,0
 1333               	/* #APP */
 1334               	 ;  1430 "stk500boot.c" 1
 1335 02da 2093 5700 		sts 87, r18
 1336 02de 8491      		lpm r24, Z
 1337               		
 1338               	 ;  0 "" 2
 1339               	.LVL137:
 1340               	/* #NOAPP */
 1341               	.LBE200:
1431:stk500boot.c  **** 	PrintNewLine();
 1342               		.loc 1 1431 0
 1343 02e0 0E94 0000 		call PrintHexByte
 1344               	.LVL138:
1432:stk500boot.c  **** 
 1345               		.loc 1 1432 0
 1346 02e4 0E94 0000 		call PrintNewLine
 1347               	.LVL139:
1434:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1348               		.loc 1 1434 0
 1349 02e8 60E0      		ldi r22,0
 1350 02ea 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1351 02ec 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1352 02ee 0E94 0000 		call PrintFromPROGMEM
 1353               	.LVL140:
 1354               	.LBB201:
1435:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1355               		.loc 1 1435 0
 1356 02f2 29E0      		ldi r18,lo8(9)
 1357 02f4 E3E0      		ldi r30,lo8(3)
 1358 02f6 F0E0      		ldi r31,0
 1359               	/* #APP */
 1360               	 ;  1435 "stk500boot.c" 1
 1361 02f8 2093 5700 		sts 87, r18
 1362 02fc 8491      		lpm r24, Z
 1363               		
 1364               	 ;  0 "" 2
 1365               	.LVL141:
 1366               	/* #NOAPP */
 1367               	.LBE201:
1436:stk500boot.c  **** 	PrintNewLine();
 1368               		.loc 1 1436 0
 1369 02fe 0E94 0000 		call PrintHexByte
 1370               	.LVL142:
1437:stk500boot.c  **** 
 1371               		.loc 1 1437 0
 1372 0302 0E94 0000 		call PrintNewLine
 1373               	.LVL143:
1439:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1374               		.loc 1 1439 0
 1375 0306 60E0      		ldi r22,0
 1376 0308 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1377 030a 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1378 030c 0E94 0000 		call PrintFromPROGMEM
 1379               	.LVL144:
 1380               	.LBB202:
1440:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1381               		.loc 1 1440 0
 1382 0310 E2E0      		ldi r30,lo8(2)
 1383 0312 F0E0      		ldi r31,0
 1384 0314 39E0      		ldi r19,lo8(9)
 1385               	/* #APP */
 1386               	 ;  1440 "stk500boot.c" 1
 1387 0316 3093 5700 		sts 87, r19
 1388 031a 8491      		lpm r24, Z
 1389               		
 1390               	 ;  0 "" 2
 1391               	.LVL145:
 1392               	/* #NOAPP */
 1393               	.LBE202:
1441:stk500boot.c  **** 	PrintNewLine();
 1394               		.loc 1 1441 0
 1395 031c 0E94 0000 		call PrintHexByte
 1396               	.LVL146:
1442:stk500boot.c  **** 
 1397               		.loc 1 1442 0
 1398 0320 0E94 0000 		call PrintNewLine
 1399               	.LVL147:
1444:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1400               		.loc 1 1444 0
 1401 0324 60E0      		ldi r22,0
 1402 0326 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1403 0328 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1404 032a 0E94 0000 		call PrintFromPROGMEM
 1405               	.LVL148:
 1406               	.LBB203:
1445:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1407               		.loc 1 1445 0
 1408 032e E1E0      		ldi r30,lo8(1)
 1409 0330 F0E0      		ldi r31,0
 1410 0332 49E0      		ldi r20,lo8(9)
 1411               	/* #APP */
 1412               	 ;  1445 "stk500boot.c" 1
 1413 0334 4093 5700 		sts 87, r20
 1414 0338 8491      		lpm r24, Z
 1415               		
 1416               	 ;  0 "" 2
 1417               	.LVL149:
 1418               	/* #NOAPP */
 1419               	.LBE203:
1446:stk500boot.c  **** 	PrintNewLine();
 1420               		.loc 1 1446 0
 1421 033a 0E94 0000 		call PrintHexByte
 1422               	.LVL150:
1447:stk500boot.c  **** 
 1423               		.loc 1 1447 0
 1424 033e 0E94 0000 		call PrintNewLine
 1425               	.LVL151:
 1426 0342 00C0      		rjmp .L198
 1427               	.LVL152:
 1428               	.L70:
 1429               	.LBE197:
 1430               	.LBE196:
2046:stk500boot.c  **** 		{
 1431               		.loc 1 2046 0
 1432 0344 1234      		cpi r17,lo8(66)
 1433 0346 01F4      		brne .+2
 1434 0348 00C0      		rjmp .L73
 1435 034a 1534      		cpi r17,lo8(69)
 1436 034c 01F4      		brne .+2
 1437 034e 00C0      		rjmp .L74
 1438 0350 00C0      		rjmp .L66
 1439               	.L68:
 1440 0352 1135      		cpi r17,lo8(81)
 1441 0354 01F4      		brne .+2
 1442 0356 00C0      		rjmp .L75
 1443 0358 00F4      		brsh .L76
 1444 035a 1834      		cpi r17,lo8(72)
 1445 035c 01F4      		brne .+2
 1446 035e 00C0      		rjmp .L77
 1447 0360 1C34      		cpi r17,lo8(76)
 1448 0362 01F0      		breq .+2
 1449 0364 00C0      		rjmp .L66
2057:stk500boot.c  **** 				PrintCPUstats();
2058:stk500boot.c  **** 				break;
2059:stk500boot.c  **** 
2060:stk500boot.c  **** 			case '@':
2061:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
2062:stk500boot.c  **** 				EEPROMtest();
2063:stk500boot.c  **** 				break;
2064:stk500boot.c  **** 
2065:stk500boot.c  **** 			case 'B':
2066:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
2067:stk500boot.c  **** 				BlinkLED();
2068:stk500boot.c  **** 				break;
2069:stk500boot.c  **** 
2070:stk500boot.c  **** 			case 'E':
2071:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
2072:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
2073:stk500boot.c  **** 				gEepromIndex	+=	256;
2074:stk500boot.c  **** 				if (gEepromIndex > E2END)
2075:stk500boot.c  **** 				{
2076:stk500boot.c  **** 					gEepromIndex	=	0;
2077:stk500boot.c  **** 				}
2078:stk500boot.c  **** 				break;
2079:stk500boot.c  **** 		
2080:stk500boot.c  **** 			case 'F':
2081:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
2082:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2083:stk500boot.c  **** 				gFlashIndex	+=	256;
2084:stk500boot.c  **** 				break;
2085:stk500boot.c  **** 
2086:stk500boot.c  **** 			case 'H':
2087:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
2088:stk500boot.c  **** 				PrintHelp();
2089:stk500boot.c  **** 				break;
2090:stk500boot.c  **** 
2091:stk500boot.c  **** 			case 'L':
2092:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1450               		.loc 1 2092 0
 1451 0366 62E0      		ldi r22,lo8(2)
 1452 0368 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1453 036a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1454 036c 0E94 0000 		call PrintFromPROGMEMln
 1455               	.LVL153:
 1456               	.LBB204:
 1457               	.LBB205:
1762:stk500boot.c  **** #endif
 1458               		.loc 1 1762 0
 1459 0370 81E4      		ldi r24,lo8(65)
 1460 0372 0E94 0000 		call PrintAvailablePort
 1461               	.LVL154:
1766:stk500boot.c  **** #endif
 1462               		.loc 1 1766 0
 1463 0376 82E4      		ldi r24,lo8(66)
 1464 0378 0E94 0000 		call PrintAvailablePort
 1465               	.LVL155:
1770:stk500boot.c  **** #endif
 1466               		.loc 1 1770 0
 1467 037c 83E4      		ldi r24,lo8(67)
 1468 037e 0E94 0000 		call PrintAvailablePort
 1469               	.LVL156:
1774:stk500boot.c  **** #endif
 1470               		.loc 1 1774 0
 1471 0382 84E4      		ldi r24,lo8(68)
 1472 0384 0E94 0000 		call PrintAvailablePort
 1473               	.LVL157:
1778:stk500boot.c  **** #endif
 1474               		.loc 1 1778 0
 1475 0388 85E4      		ldi r24,lo8(69)
 1476 038a 0E94 0000 		call PrintAvailablePort
 1477               	.LVL158:
1782:stk500boot.c  **** #endif
 1478               		.loc 1 1782 0
 1479 038e 86E4      		ldi r24,lo8(70)
 1480 0390 0E94 0000 		call PrintAvailablePort
 1481               	.LVL159:
1786:stk500boot.c  **** #endif
 1482               		.loc 1 1786 0
 1483 0394 87E4      		ldi r24,lo8(71)
 1484 0396 0E94 0000 		call PrintAvailablePort
 1485               	.LVL160:
1790:stk500boot.c  **** #endif
 1486               		.loc 1 1790 0
 1487 039a 88E4      		ldi r24,lo8(72)
 1488 039c 0E94 0000 		call PrintAvailablePort
 1489               	.LVL161:
1798:stk500boot.c  **** #endif
 1490               		.loc 1 1798 0
 1491 03a0 8AE4      		ldi r24,lo8(74)
 1492 03a2 0E94 0000 		call PrintAvailablePort
 1493               	.LVL162:
1802:stk500boot.c  **** #endif
 1494               		.loc 1 1802 0
 1495 03a6 8BE4      		ldi r24,lo8(75)
 1496 03a8 0E94 0000 		call PrintAvailablePort
 1497               	.LVL163:
1806:stk500boot.c  **** #endif
 1498               		.loc 1 1806 0
 1499 03ac 8CE4      		ldi r24,lo8(76)
 1500 03ae 0E94 0000 		call PrintAvailablePort
 1501               	.LVL164:
 1502 03b2 00C0      		rjmp .L198
 1503               	.L76:
 1504               	.LBE205:
 1505               	.LBE204:
2046:stk500boot.c  **** 		{
 1506               		.loc 1 2046 0
 1507 03b4 1635      		cpi r17,lo8(86)
 1508 03b6 01F4      		brne .+2
 1509 03b8 00C0      		rjmp .L79
 1510 03ba 1935      		cpi r17,lo8(89)
 1511 03bc 01F4      		brne .+2
 1512 03be 00C0      		rjmp .L80
 1513 03c0 1235      		cpi r17,lo8(82)
 1514 03c2 01F0      		breq .+2
 1515 03c4 00C0      		rjmp .L66
2093:stk500boot.c  **** 				ListAvailablePorts();
2094:stk500boot.c  **** 				break;
2095:stk500boot.c  **** 
2096:stk500boot.c  **** 			case 'Q':
2097:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
2098:stk500boot.c  **** 				keepGoing	=	false;
2099:stk500boot.c  **** 				break;
2100:stk500boot.c  **** 
2101:stk500boot.c  **** 			case 'R':
2102:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1516               		.loc 1 2102 0
 1517 03c6 62E0      		ldi r22,lo8(2)
 1518 03c8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1519 03ca 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1520 03cc 0E94 0000 		call PrintFromPROGMEMln
 1521               	.LVL165:
2103:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1522               		.loc 1 2103 0
 1523 03d0 4091 0000 		lds r20,gRamIndex
 1524 03d4 5091 0000 		lds r21,gRamIndex+1
 1525 03d8 6091 0000 		lds r22,gRamIndex+2
 1526 03dc 7091 0000 		lds r23,gRamIndex+3
 1527 03e0 82E0      		ldi r24,lo8(2)
 1528 03e2 0E94 0000 		call DumpHex.constprop.0
 1529               	.LVL166:
2104:stk500boot.c  **** 				gRamIndex	+=	256;
 1530               		.loc 1 2104 0
 1531 03e6 8091 0000 		lds r24,gRamIndex
 1532 03ea 9091 0000 		lds r25,gRamIndex+1
 1533 03ee A091 0000 		lds r26,gRamIndex+2
 1534 03f2 B091 0000 		lds r27,gRamIndex+3
 1535 03f6 9F5F      		subi r25,-1
 1536 03f8 AF4F      		sbci r26,-1
 1537 03fa BF4F      		sbci r27,-1
 1538 03fc 8093 0000 		sts gRamIndex,r24
 1539 0400 9093 0000 		sts gRamIndex+1,r25
 1540 0404 A093 0000 		sts gRamIndex+2,r26
 1541 0408 B093 0000 		sts gRamIndex+3,r27
 1542 040c 00C0      		rjmp .L198
 1543               	.L71:
2049:stk500boot.c  **** 				gFlashIndex		=	0;
 1544               		.loc 1 2049 0
 1545 040e 62E0      		ldi r22,lo8(2)
 1546 0410 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1547 0412 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1548 0414 0E94 0000 		call PrintFromPROGMEMln
 1549               	.LVL167:
2050:stk500boot.c  **** 				gRamIndex		=	0;
 1550               		.loc 1 2050 0
 1551 0418 1092 0000 		sts gFlashIndex,__zero_reg__
 1552 041c 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1553 0420 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1554 0424 1092 0000 		sts gFlashIndex+3,__zero_reg__
2051:stk500boot.c  **** 				gEepromIndex	=	0;
 1555               		.loc 1 2051 0
 1556 0428 1092 0000 		sts gRamIndex,__zero_reg__
 1557 042c 1092 0000 		sts gRamIndex+1,__zero_reg__
 1558 0430 1092 0000 		sts gRamIndex+2,__zero_reg__
 1559 0434 1092 0000 		sts gRamIndex+3,__zero_reg__
 1560 0438 00C0      		rjmp .L277
 1561               	.L69:
2061:stk500boot.c  **** 				EEPROMtest();
 1562               		.loc 1 2061 0
 1563 043a 62E0      		ldi r22,lo8(2)
 1564 043c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1565 043e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1566 0440 0E94 0000 		call PrintFromPROGMEMln
 1567               	.LVL168:
 1568               	.LBB206:
 1569               	.LBB207:
1556:stk500boot.c  **** 	PrintNewLine();
 1570               		.loc 1 1556 0
 1571 0444 60E0      		ldi r22,0
 1572 0446 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1573 0448 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1574 044a 0E94 0000 		call PrintFromPROGMEMln
 1575               	.LVL169:
1557:stk500boot.c  **** 	ii			=	0;
 1576               		.loc 1 1557 0
 1577 044e 0E94 0000 		call PrintNewLine
 1578               	.LVL170:
1558:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1579               		.loc 1 1558 0
 1580 0452 00E0      		ldi r16,0
 1581 0454 10E0      		ldi r17,0
 1582               	.LVL171:
 1583               	.L83:
 1584               	.LBB208:
1560:stk500boot.c  **** #else
 1585               		.loc 1 1560 0
 1586 0456 C801      		movw r24,r16
 1587 0458 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1588 045a 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1589 045c A0E0      		ldi r26,0
 1590 045e B0E0      		ldi r27,0
 1591               	/* #APP */
 1592               	 ;  1560 "stk500boot.c" 1
 1593 0460 ABBF      		out 59, r26
 1594 0462 FC01      		movw r30, r24
 1595 0464 F790      		elpm r15, Z+
 1596               		
 1597               	 ;  0 "" 2
 1598               	.LVL172:
 1599               	/* #NOAPP */
 1600               	.LBE208:
 1601 0466 5AE2      		ldi r21,lo8(42)
 1602 0468 F516      		cp r15,r21
 1603 046a 01F0      		breq .L86
 1604 046c 0115      		cp r16,__zero_reg__
 1605 046e 62E0      		ldi r22,2
 1606 0470 1607      		cpc r17,r22
 1607 0472 01F0      		breq .L86
1565:stk500boot.c  **** 		if (theChar == 0)
 1608               		.loc 1 1565 0
 1609 0474 6F2D      		mov r22,r15
 1610 0476 C801      		movw r24,r16
 1611 0478 0E94 0000 		call eeprom_write_byte
 1612               	.LVL173:
1566:stk500boot.c  **** 		{
 1613               		.loc 1 1566 0
 1614 047c F110      		cpse r15,__zero_reg__
 1615 047e 00C0      		rjmp .L84
1568:stk500boot.c  **** 		}
 1616               		.loc 1 1568 0
 1617 0480 60E0      		ldi r22,0
 1618 0482 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1619 0484 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1620 0486 0E94 0000 		call PrintFromPROGMEM
 1621               	.LVL174:
 1622 048a 00C0      		rjmp .L85
 1623               	.L84:
1572:stk500boot.c  **** 		}
 1624               		.loc 1 1572 0
 1625 048c 8F2D      		mov r24,r15
 1626 048e 0E94 0000 		call sendchar
 1627               	.LVL175:
 1628               	.L85:
1574:stk500boot.c  **** 	}
 1629               		.loc 1 1574 0
 1630 0492 0F5F      		subi r16,-1
 1631 0494 1F4F      		sbci r17,-1
 1632               	.LVL176:
 1633 0496 00C0      		rjmp .L83
 1634               	.LVL177:
 1635               	.L86:
1578:stk500boot.c  **** 	PrintNewLine();
 1636               		.loc 1 1578 0
 1637 0498 0E94 0000 		call PrintNewLine
 1638               	.LVL178:
1579:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1639               		.loc 1 1579 0
 1640 049c 0E94 0000 		call PrintNewLine
 1641               	.LVL179:
1580:stk500boot.c  **** 	PrintNewLine();
 1642               		.loc 1 1580 0
 1643 04a0 60E0      		ldi r22,0
 1644 04a2 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1645 04a4 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1646 04a6 0E94 0000 		call PrintFromPROGMEMln
 1647               	.LVL180:
1581:stk500boot.c  **** 	errorCount	=	0;
 1648               		.loc 1 1581 0
 1649 04aa 0E94 0000 		call PrintNewLine
 1650               	.LVL181:
1582:stk500boot.c  **** 	ii			=	0;
 1651               		.loc 1 1582 0
 1652 04ae E12C      		mov r14,__zero_reg__
 1653 04b0 F12C      		mov r15,__zero_reg__
1583:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1654               		.loc 1 1583 0
 1655 04b2 00E0      		ldi r16,0
 1656 04b4 10E0      		ldi r17,0
 1657               	.LVL182:
 1658               	.L88:
 1659               	.LBB209:
1585:stk500boot.c  **** #else
 1660               		.loc 1 1585 0
 1661 04b6 C801      		movw r24,r16
 1662 04b8 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1663 04ba 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1664 04bc A0E0      		ldi r26,0
 1665 04be B0E0      		ldi r27,0
 1666               	/* #APP */
 1667               	 ;  1585 "stk500boot.c" 1
 1668 04c0 ABBF      		out 59, r26
 1669 04c2 FC01      		movw r30, r24
 1670 04c4 D790      		elpm r13, Z+
 1671               		
 1672               	 ;  0 "" 2
 1673               	.LVL183:
 1674               	/* #NOAPP */
 1675               	.LBE209:
 1676 04c6 8AE2      		ldi r24,lo8(42)
 1677 04c8 D816      		cp r13,r24
 1678 04ca 01F0      		breq .L92
 1679 04cc 0115      		cp r16,__zero_reg__
 1680 04ce 92E0      		ldi r25,2
 1681 04d0 1907      		cpc r17,r25
 1682 04d2 01F0      		breq .L92
1590:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1683               		.loc 1 1590 0
 1684 04d4 C801      		movw r24,r16
 1685 04d6 0E94 0000 		call eeprom_read_byte
 1686               	.LVL184:
 1687 04da C82E      		mov r12,r24
 1688               	.LVL185:
1591:stk500boot.c  **** 		{
 1689               		.loc 1 1591 0
 1690 04dc 8111      		cpse r24,__zero_reg__
 1691 04de 00C0      		rjmp .L89
1593:stk500boot.c  **** 		}
 1692               		.loc 1 1593 0
 1693 04e0 60E0      		ldi r22,0
 1694 04e2 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1695 04e4 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1696 04e6 0E94 0000 		call PrintFromPROGMEM
 1697               	.LVL186:
 1698 04ea 00C0      		rjmp .L90
 1699               	.L89:
1597:stk500boot.c  **** 		}
 1700               		.loc 1 1597 0
 1701 04ec 0E94 0000 		call sendchar
 1702               	.LVL187:
 1703               	.L90:
1599:stk500boot.c  **** 		{
 1704               		.loc 1 1599 0
 1705 04f0 CD14      		cp r12,r13
 1706 04f2 01F0      		breq .L91
1601:stk500boot.c  **** 		}
 1707               		.loc 1 1601 0
 1708 04f4 7FEF      		ldi r23,-1
 1709 04f6 E71A      		sub r14,r23
 1710 04f8 F70A      		sbc r15,r23
 1711               	.LVL188:
 1712               	.L91:
1603:stk500boot.c  **** 	}
 1713               		.loc 1 1603 0
 1714 04fa 0F5F      		subi r16,-1
 1715 04fc 1F4F      		sbci r17,-1
 1716               	.LVL189:
 1717 04fe 00C0      		rjmp .L88
 1718               	.LVL190:
 1719               	.L92:
1605:stk500boot.c  **** 	PrintNewLine();
 1720               		.loc 1 1605 0
 1721 0500 0E94 0000 		call PrintNewLine
 1722               	.LVL191:
1606:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1723               		.loc 1 1606 0
 1724 0504 0E94 0000 		call PrintNewLine
 1725               	.LVL192:
1607:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1726               		.loc 1 1607 0
 1727 0508 60E0      		ldi r22,0
 1728 050a 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1729 050c 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1730 050e 0E94 0000 		call PrintFromPROGMEM
 1731               	.LVL193:
1608:stk500boot.c  **** 	PrintNewLine();
 1732               		.loc 1 1608 0
 1733 0512 61E0      		ldi r22,lo8(1)
 1734 0514 70E0      		ldi r23,0
 1735 0516 C701      		movw r24,r14
 1736 0518 0E94 0000 		call PrintDecInt
 1737               	.LVL194:
1609:stk500boot.c  **** 	PrintNewLine();
 1738               		.loc 1 1609 0
 1739 051c 0E94 0000 		call PrintNewLine
 1740               	.LVL195:
1610:stk500boot.c  **** 
 1741               		.loc 1 1610 0
 1742 0520 0E94 0000 		call PrintNewLine
 1743               	.LVL196:
 1744               	.L277:
1612:stk500boot.c  **** 
 1745               		.loc 1 1612 0
 1746 0524 1092 0000 		sts gEepromIndex,__zero_reg__
 1747 0528 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1748 052c 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1749 0530 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1750 0534 00C0      		rjmp .L198
 1751               	.L73:
 1752               	.LBE207:
 1753               	.LBE206:
2066:stk500boot.c  **** 				BlinkLED();
 1754               		.loc 1 2066 0
 1755 0536 62E0      		ldi r22,lo8(2)
 1756 0538 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1757 053a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1758 053c 0E94 0000 		call PrintFromPROGMEMln
 1759               	.LVL197:
 1760               	.LBB210:
 1761               	.LBB211:
1457:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1762               		.loc 1 1457 0
 1763 0540 9A9A      		sbi 0x13,2
1458:stk500boot.c  **** 
 1764               		.loc 1 1458 0
 1765 0542 A29A      		sbi 0x14,2
 1766               	.L94:
 1767               	.LBB212:
 1768               	.LBB213:
 477:stk500boot.c  **** }
 1769               		.loc 1 477 0
 1770 0544 8091 C000 		lds r24,192
 1771               	.LBE213:
 1772               	.LBE212:
1460:stk500boot.c  **** 	{
 1773               		.loc 1 1460 0
 1774 0548 87FD      		sbrc r24,7
 1775 054a 00C0      		rjmp .L121
1462:stk500boot.c  **** 		delay_ms(100);
 1776               		.loc 1 1462 0
 1777 054c A298      		cbi 0x14,2
1463:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1778               		.loc 1 1463 0
 1779 054e 84E6      		ldi r24,lo8(100)
 1780 0550 90E0      		ldi r25,0
 1781 0552 0E94 0000 		call delay_ms
 1782               	.LVL198:
1464:stk500boot.c  **** 		delay_ms(100);
 1783               		.loc 1 1464 0
 1784 0556 A29A      		sbi 0x14,2
1465:stk500boot.c  **** 	}
 1785               		.loc 1 1465 0
 1786 0558 84E6      		ldi r24,lo8(100)
 1787 055a 90E0      		ldi r25,0
 1788 055c 0E94 0000 		call delay_ms
 1789               	.LVL199:
 1790 0560 00C0      		rjmp .L94
 1791               	.LVL200:
 1792               	.L286:
 1793               	.LBE211:
 1794               	.LBE210:
 1795               	.LBB215:
 1796               	.LBB194:
1837:stk500boot.c  **** 				break;
 1797               		.loc 1 1837 0
 1798 0562 12B8      		out 0x2,__zero_reg__
 1799               	.LVL201:
 1800               	.L121:
 1801               	.LBE194:
 1802               	.LBE215:
 1803               	.LBB216:
 1804               	.LBB214:
1467:stk500boot.c  **** }
 1805               		.loc 1 1467 0
 1806 0564 0E94 0000 		call recchar
 1807               	.LVL202:
 1808 0568 00C0      		rjmp .L198
 1809               	.LVL203:
 1810               	.L74:
 1811               	.LBE214:
 1812               	.LBE216:
2071:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1813               		.loc 1 2071 0
 1814 056a 62E0      		ldi r22,lo8(2)
 1815 056c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1816 056e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1817 0570 0E94 0000 		call PrintFromPROGMEMln
 1818               	.LVL204:
2072:stk500boot.c  **** 				gEepromIndex	+=	256;
 1819               		.loc 1 2072 0
 1820 0574 4091 0000 		lds r20,gEepromIndex
 1821 0578 5091 0000 		lds r21,gEepromIndex+1
 1822 057c 6091 0000 		lds r22,gEepromIndex+2
 1823 0580 7091 0000 		lds r23,gEepromIndex+3
 1824 0584 81E0      		ldi r24,lo8(1)
 1825 0586 0E94 0000 		call DumpHex.constprop.0
 1826               	.LVL205:
2073:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1827               		.loc 1 2073 0
 1828 058a 8091 0000 		lds r24,gEepromIndex
 1829 058e 9091 0000 		lds r25,gEepromIndex+1
 1830 0592 A091 0000 		lds r26,gEepromIndex+2
 1831 0596 B091 0000 		lds r27,gEepromIndex+3
 1832 059a 9F5F      		subi r25,-1
 1833 059c AF4F      		sbci r26,-1
 1834 059e BF4F      		sbci r27,-1
 1835 05a0 8093 0000 		sts gEepromIndex,r24
 1836 05a4 9093 0000 		sts gEepromIndex+1,r25
 1837 05a8 A093 0000 		sts gEepromIndex+2,r26
 1838 05ac B093 0000 		sts gEepromIndex+3,r27
2074:stk500boot.c  **** 				{
 1839               		.loc 1 2074 0
 1840 05b0 8115      		cp r24,__zero_reg__
 1841 05b2 9041      		sbci r25,16
 1842 05b4 A105      		cpc r26,__zero_reg__
 1843 05b6 B105      		cpc r27,__zero_reg__
 1844 05b8 00F4      		brsh .+2
 1845 05ba 00C0      		rjmp .L198
 1846 05bc 00C0      		rjmp .L277
 1847               	.L67:
2081:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1848               		.loc 1 2081 0
 1849 05be 62E0      		ldi r22,lo8(2)
 1850 05c0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1851 05c2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1852 05c4 0E94 0000 		call PrintFromPROGMEMln
 1853               	.LVL206:
2082:stk500boot.c  **** 				gFlashIndex	+=	256;
 1854               		.loc 1 2082 0
 1855 05c8 4091 0000 		lds r20,gFlashIndex
 1856 05cc 5091 0000 		lds r21,gFlashIndex+1
 1857 05d0 6091 0000 		lds r22,gFlashIndex+2
 1858 05d4 7091 0000 		lds r23,gFlashIndex+3
 1859 05d8 80E0      		ldi r24,0
 1860 05da 0E94 0000 		call DumpHex.constprop.0
 1861               	.LVL207:
2083:stk500boot.c  **** 				break;
 1862               		.loc 1 2083 0
 1863 05de 8091 0000 		lds r24,gFlashIndex
 1864 05e2 9091 0000 		lds r25,gFlashIndex+1
 1865 05e6 A091 0000 		lds r26,gFlashIndex+2
 1866 05ea B091 0000 		lds r27,gFlashIndex+3
 1867 05ee 9F5F      		subi r25,-1
 1868 05f0 AF4F      		sbci r26,-1
 1869 05f2 BF4F      		sbci r27,-1
 1870 05f4 8093 0000 		sts gFlashIndex,r24
 1871 05f8 9093 0000 		sts gFlashIndex+1,r25
 1872 05fc A093 0000 		sts gFlashIndex+2,r26
 1873 0600 B093 0000 		sts gFlashIndex+3,r27
 1874 0604 00C0      		rjmp .L198
 1875               	.L77:
2087:stk500boot.c  **** 				PrintHelp();
 1876               		.loc 1 2087 0
 1877 0606 62E0      		ldi r22,lo8(2)
 1878 0608 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1879 060a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1880 060c 0E94 0000 		call PrintFromPROGMEMln
 1881               	.LVL208:
 1882               	.LBB217:
 1883               	.LBB218:
1993:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 1884               		.loc 1 1993 0
 1885 0610 60E0      		ldi r22,0
 1886 0612 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1887 0614 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1888 0616 0E94 0000 		call PrintFromPROGMEMln
 1889               	.LVL209:
1994:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 1890               		.loc 1 1994 0
 1891 061a 60E0      		ldi r22,0
 1892 061c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1893 061e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1894 0620 0E94 0000 		call PrintFromPROGMEMln
 1895               	.LVL210:
1995:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 1896               		.loc 1 1995 0
 1897 0624 60E0      		ldi r22,0
 1898 0626 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1899 0628 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1900 062a 0E94 0000 		call PrintFromPROGMEMln
 1901               	.LVL211:
1996:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 1902               		.loc 1 1996 0
 1903 062e 60E0      		ldi r22,0
 1904 0630 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1905 0632 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1906 0634 0E94 0000 		call PrintFromPROGMEMln
 1907               	.LVL212:
1997:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 1908               		.loc 1 1997 0
 1909 0638 60E0      		ldi r22,0
 1910 063a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1911 063c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1912 063e 0E94 0000 		call PrintFromPROGMEMln
 1913               	.LVL213:
1998:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 1914               		.loc 1 1998 0
 1915 0642 60E0      		ldi r22,0
 1916 0644 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1917 0646 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1918 0648 0E94 0000 		call PrintFromPROGMEMln
 1919               	.LVL214:
1999:stk500boot.c  **** 
 1920               		.loc 1 1999 0
 1921 064c 60E0      		ldi r22,0
 1922 064e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1923 0650 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1924 0652 0E94 0000 		call PrintFromPROGMEMln
 1925               	.LVL215:
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 1926               		.loc 1 2001 0
 1927 0656 60E0      		ldi r22,0
 1928 0658 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1929 065a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1930 065c 0E94 0000 		call PrintFromPROGMEMln
 1931               	.LVL216:
2002:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 1932               		.loc 1 2002 0
 1933 0660 60E0      		ldi r22,0
 1934 0662 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1935 0664 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1936 0666 0E94 0000 		call PrintFromPROGMEMln
 1937               	.LVL217:
2003:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 1938               		.loc 1 2003 0
 1939 066a 60E0      		ldi r22,0
 1940 066c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1941 066e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1942 0670 0E94 0000 		call PrintFromPROGMEMln
 1943               	.LVL218:
2004:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 1944               		.loc 1 2004 0
 1945 0674 60E0      		ldi r22,0
 1946 0676 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1947 0678 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1948 067a 0E94 0000 		call PrintFromPROGMEMln
 1949               	.LVL219:
2005:stk500boot.c  **** }
 1950               		.loc 1 2005 0
 1951 067e 60E0      		ldi r22,0
 1952 0680 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1953 0682 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1954 0684 00C0      		rjmp .L276
 1955               	.L75:
 1956               	.LBE218:
 1957               	.LBE217:
2097:stk500boot.c  **** 				keepGoing	=	false;
 1958               		.loc 1 2097 0
 1959 0686 62E0      		ldi r22,lo8(2)
 1960 0688 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1961 068a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1962 068c 0E94 0000 		call PrintFromPROGMEMln
 1963               	.LVL220:
 1964               	.LBE169:
 1965               	.LBE168:
 698:stk500boot.c  **** 						isLeave			=	1;
 1966               		.loc 1 698 0
 1967 0690 E12C      		mov r14,__zero_reg__
 1968 0692 F12C      		mov r15,__zero_reg__
 699:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 1969               		.loc 1 699 0
 1970 0694 7724      		clr r7
 1971 0696 7394      		inc r7
 1972 0698 00C0      		rjmp .L97
 1973               	.LVL221:
 1974               	.L79:
 1975               	.LBB227:
 1976               	.LBB226:
2105:stk500boot.c  **** 				break;
2106:stk500boot.c  **** 
2107:stk500boot.c  **** 			case 'V':
2108:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
 1977               		.loc 1 2108 0
 1978 069a 62E0      		ldi r22,lo8(2)
 1979 069c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1980 069e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1981 06a0 0E94 0000 		call PrintFromPROGMEMln
 1982               	.LVL222:
 1983               	.LBB219:
 1984               	.LBB220:
1648:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 1985               		.loc 1 1648 0
 1986 06a4 60E0      		ldi r22,0
 1987 06a6 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1988 06a8 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1989 06aa 0E94 0000 		call PrintFromPROGMEMln
 1990               	.LVL223:
1649:stk500boot.c  **** 	//					 V#   ADDR   op code
 1991               		.loc 1 1649 0
 1992 06ae 60E0      		ldi r22,0
 1993 06b0 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 1994 06b2 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 1995 06b4 0E94 0000 		call PrintFromPROGMEMln
 1996               	.LVL224:
1647:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1997               		.loc 1 1647 0
 1998 06b8 00E0      		ldi r16,0
 1999 06ba 10E0      		ldi r17,0
1646:stk500boot.c  **** 	vectorIndex		=	0;
 2000               		.loc 1 1646 0
 2001 06bc C25E      		subi r28,lo8(-286)
 2002 06be DE4F      		sbci r29,hi8(-286)
 2003 06c0 1882      		st Y,__zero_reg__
 2004 06c2 1982      		std Y+1,__zero_reg__
 2005 06c4 1A82      		std Y+2,__zero_reg__
 2006 06c6 1B82      		std Y+3,__zero_reg__
 2007 06c8 CE51      		subi r28,lo8(286)
 2008 06ca D140      		sbci r29,hi8(286)
 2009               	.LVL225:
 2010               	.L101:
1654:stk500boot.c  **** 		//					 01 - 0000 = 12 34
 2011               		.loc 1 1654 0
 2012 06cc C25E      		subi r28,lo8(-286)
 2013 06ce DE4F      		sbci r29,hi8(-286)
 2014 06d0 2881      		ld r18,Y
 2015 06d2 3981      		ldd r19,Y+1
 2016 06d4 4A81      		ldd r20,Y+2
 2017 06d6 5B81      		ldd r21,Y+3
 2018 06d8 CE51      		subi r28,lo8(286)
 2019 06da D140      		sbci r29,hi8(286)
 2020 06dc 5695      		lsr r21
 2021 06de 4795      		ror r20
 2022 06e0 3795      		ror r19
 2023 06e2 2795      		ror r18
 2024 06e4 C65D      		subi r28,lo8(-298)
 2025 06e6 DE4F      		sbci r29,hi8(-298)
 2026 06e8 2883      		st Y,r18
 2027 06ea 3983      		std Y+1,r19
 2028 06ec 4A83      		std Y+2,r20
 2029 06ee 5B83      		std Y+3,r21
 2030 06f0 CA52      		subi r28,lo8(298)
 2031 06f2 D140      		sbci r29,hi8(298)
 2032               	.LVL226:
1656:stk500boot.c  **** 		sendchar(0x20);
 2033               		.loc 1 1656 0
 2034 06f4 0F5F      		subi r16,-1
 2035 06f6 1F4F      		sbci r17,-1
 2036               	.LVL227:
 2037 06f8 62E0      		ldi r22,lo8(2)
 2038 06fa 70E0      		ldi r23,0
 2039 06fc C801      		movw r24,r16
 2040 06fe 0E94 0000 		call PrintDecInt
 2041               	.LVL228:
1657:stk500boot.c  **** 		sendchar('-');
 2042               		.loc 1 1657 0
 2043 0702 80E2      		ldi r24,lo8(32)
 2044 0704 0E94 0000 		call sendchar
 2045               	.LVL229:
1658:stk500boot.c  **** 		sendchar(0x20);
 2046               		.loc 1 1658 0
 2047 0708 8DE2      		ldi r24,lo8(45)
 2048 070a 0E94 0000 		call sendchar
 2049               	.LVL230:
1659:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2050               		.loc 1 1659 0
 2051 070e 80E2      		ldi r24,lo8(32)
 2052 0710 0E94 0000 		call sendchar
 2053               	.LVL231:
1660:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2054               		.loc 1 1660 0
 2055 0714 80E0      		ldi r24,0
 2056 0716 0E94 0000 		call PrintHexByte
 2057               	.LVL232:
1661:stk500boot.c  **** 		sendchar(0x20);
 2058               		.loc 1 1661 0
 2059 071a C65D      		subi r28,lo8(-298)
 2060 071c DE4F      		sbci r29,hi8(-298)
 2061 071e 8881      		ld r24,Y
 2062 0720 CA52      		subi r28,lo8(298)
 2063 0722 D140      		sbci r29,hi8(298)
 2064 0724 0E94 0000 		call PrintHexByte
 2065               	.LVL233:
1662:stk500boot.c  **** 		sendchar('=');
 2066               		.loc 1 1662 0
 2067 0728 80E2      		ldi r24,lo8(32)
 2068 072a 0E94 0000 		call sendchar
 2069               	.LVL234:
1663:stk500boot.c  **** 		sendchar(0x20);
 2070               		.loc 1 1663 0
 2071 072e 8DE3      		ldi r24,lo8(61)
 2072 0730 0E94 0000 		call sendchar
 2073               	.LVL235:
1664:stk500boot.c  **** 
 2074               		.loc 1 1664 0
 2075 0734 80E2      		ldi r24,lo8(32)
 2076 0736 0E94 0000 		call sendchar
 2077               	.LVL236:
 2078               	.LBB221:
1669:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2079               		.loc 1 1669 0
 2080 073a C25E      		subi r28,lo8(-286)
 2081 073c DE4F      		sbci r29,hi8(-286)
 2082 073e 4881      		ld r20,Y
 2083 0740 5981      		ldd r21,Y+1
 2084 0742 6A81      		ldd r22,Y+2
 2085 0744 7B81      		ldd r23,Y+3
 2086 0746 CE51      		subi r28,lo8(286)
 2087 0748 D140      		sbci r29,hi8(286)
 2088               	/* #APP */
 2089               	 ;  1669 "stk500boot.c" 1
 2090 074a 6BBF      		out 59, r22
 2091 074c FA01      		movw r30, r20
 2092 074e F790      		elpm r15, Z+
 2093               		
 2094               	 ;  0 "" 2
 2095               	.LVL237:
 2096               	/* #NOAPP */
 2097               	.LBE221:
 2098               	.LBB222:
1670:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2099               		.loc 1 1670 0
 2100 0750 DB01      		movw r26,r22
 2101 0752 CA01      		movw r24,r20
 2102 0754 0196      		adiw r24,1
 2103 0756 A11D      		adc r26,__zero_reg__
 2104 0758 B11D      		adc r27,__zero_reg__
 2105               	.LVL238:
 2106               	/* #APP */
 2107               	 ;  1670 "stk500boot.c" 1
 2108 075a ABBF      		out 59, r26
 2109 075c FC01      		movw r30, r24
 2110 075e D790      		elpm r13, Z+
 2111               		
 2112               	 ;  0 "" 2
 2113               	.LVL239:
 2114               	/* #NOAPP */
 2115               	.LBE222:
 2116               	.LBB223:
1671:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2117               		.loc 1 1671 0
 2118 0760 DB01      		movw r26,r22
 2119 0762 CA01      		movw r24,r20
 2120               	.LVL240:
 2121 0764 0296      		adiw r24,2
 2122 0766 A11D      		adc r26,__zero_reg__
 2123 0768 B11D      		adc r27,__zero_reg__
 2124               	.LVL241:
 2125               	/* #APP */
 2126               	 ;  1671 "stk500boot.c" 1
 2127 076a ABBF      		out 59, r26
 2128 076c FC01      		movw r30, r24
 2129 076e E790      		elpm r14, Z+
 2130               		
 2131               	 ;  0 "" 2
 2132               	.LVL242:
 2133               	/* #NOAPP */
 2134               	.LBE223:
 2135               	.LBB224:
1672:stk500boot.c  **** 	#else
 2136               		.loc 1 1672 0
 2137 0770 DB01      		movw r26,r22
 2138 0772 CA01      		movw r24,r20
 2139               	.LVL243:
 2140 0774 0396      		adiw r24,3
 2141 0776 A11D      		adc r26,__zero_reg__
 2142 0778 B11D      		adc r27,__zero_reg__
 2143               	/* #APP */
 2144               	 ;  1672 "stk500boot.c" 1
 2145 077a ABBF      		out 59, r26
 2146 077c FC01      		movw r30, r24
 2147 077e C790      		elpm r12, Z+
 2148               		
 2149               	 ;  0 "" 2
 2150               	/* #NOAPP */
 2151 0780 4C5F      		subi r20,-4
 2152 0782 5F4F      		sbci r21,-1
 2153 0784 6F4F      		sbci r22,-1
 2154 0786 7F4F      		sbci r23,-1
 2155 0788 C25E      		subi r28,lo8(-286)
 2156 078a DE4F      		sbci r29,hi8(-286)
 2157 078c 4883      		st Y,r20
 2158 078e 5983      		std Y+1,r21
 2159 0790 6A83      		std Y+2,r22
 2160 0792 7B83      		std Y+3,r23
 2161 0794 CE51      		subi r28,lo8(286)
 2162 0796 D140      		sbci r29,hi8(286)
 2163               	.LVL244:
 2164               	.LBE224:
1679:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2165               		.loc 1 1679 0
 2166 0798 8D2C      		mov r8,r13
 2167 079a 912C      		mov r9,__zero_reg__
 2168 079c A12C      		mov r10,__zero_reg__
 2169 079e B12C      		mov r11,__zero_reg__
 2170 07a0 BA2C      		mov r11,r10
 2171 07a2 A92C      		mov r10,r9
 2172 07a4 982C      		mov r9,r8
 2173 07a6 8824      		clr r8
 2174 07a8 8F0C      		add r8,r15
 2175 07aa 911C      		adc r9,__zero_reg__
 2176 07ac A11C      		adc r10,__zero_reg__
 2177 07ae B11C      		adc r11,__zero_reg__
 2178               	.LVL245:
1683:stk500boot.c  **** 		sendchar(0x20);
 2179               		.loc 1 1683 0
 2180 07b0 8D2D      		mov r24,r13
 2181 07b2 0E94 0000 		call PrintHexByte
 2182               	.LVL246:
1684:stk500boot.c  **** 		PrintHexByte(byte1);
 2183               		.loc 1 1684 0
 2184 07b6 80E2      		ldi r24,lo8(32)
 2185 07b8 0E94 0000 		call sendchar
 2186               	.LVL247:
1685:stk500boot.c  **** 		sendchar(0x20);
 2187               		.loc 1 1685 0
 2188 07bc 8F2D      		mov r24,r15
 2189 07be 0E94 0000 		call PrintHexByte
 2190               	.LVL248:
1686:stk500boot.c  **** 		PrintHexByte(byte4);
 2191               		.loc 1 1686 0
 2192 07c2 80E2      		ldi r24,lo8(32)
 2193 07c4 0E94 0000 		call sendchar
 2194               	.LVL249:
1687:stk500boot.c  **** 		sendchar(0x20);
 2195               		.loc 1 1687 0
 2196 07c8 8C2D      		mov r24,r12
 2197 07ca 0E94 0000 		call PrintHexByte
 2198               	.LVL250:
1688:stk500boot.c  **** 		PrintHexByte(byte3);
 2199               		.loc 1 1688 0
 2200 07ce 80E2      		ldi r24,lo8(32)
 2201 07d0 0E94 0000 		call sendchar
 2202               	.LVL251:
1689:stk500boot.c  **** 		sendchar(0x20);
 2203               		.loc 1 1689 0
 2204 07d4 8E2D      		mov r24,r14
 2205 07d6 0E94 0000 		call PrintHexByte
 2206               	.LVL252:
1690:stk500boot.c  **** 	
 2207               		.loc 1 1690 0
 2208 07da 80E2      		ldi r24,lo8(32)
 2209 07dc 0E94 0000 		call sendchar
 2210               	.LVL253:
1692:stk500boot.c  **** 		{
 2211               		.loc 1 1692 0
 2212 07e0 5FEF      		ldi r21,-1
 2213 07e2 8516      		cp r8,r21
 2214 07e4 9506      		cpc r9,r21
 2215 07e6 A104      		cpc r10,__zero_reg__
 2216 07e8 B104      		cpc r11,__zero_reg__
 2217 07ea 01F4      		brne .L98
1694:stk500boot.c  **** 		}
 2218               		.loc 1 1694 0
 2219 07ec 60E0      		ldi r22,0
 2220 07ee 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2221 07f0 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2222 07f2 0E94 0000 		call PrintFromPROGMEM
 2223               	.LVL254:
 2224 07f6 00C0      		rjmp .L99
 2225               	.L98:
1696:stk500boot.c  **** 		{
 2226               		.loc 1 1696 0
 2227 07f8 D501      		movw r26,r10
 2228 07fa C401      		movw r24,r8
 2229 07fc 8827      		clr r24
 2230 07fe 907C      		andi r25,192
 2231 0800 AA27      		clr r26
 2232 0802 BB27      		clr r27
 2233 0804 8115      		cp r24,__zero_reg__
 2234 0806 904C      		sbci r25,-64
 2235 0808 A105      		cpc r26,__zero_reg__
 2236 080a B105      		cpc r27,__zero_reg__
 2237 080c 01F4      		brne .L100
1699:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2238               		.loc 1 1699 0
 2239 080e 7FE3      		ldi r23,63
 2240 0810 9722      		and r9,r23
 2241 0812 AA24      		clr r10
 2242 0814 BB24      		clr r11
 2243               	.LVL255:
1700:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2244               		.loc 1 1700 0
 2245 0816 C65D      		subi r28,lo8(-298)
 2246 0818 DE4F      		sbci r29,hi8(-298)
 2247 081a C880      		ld r12,Y
 2248 081c D980      		ldd r13,Y+1
 2249 081e EA80      		ldd r14,Y+2
 2250 0820 FB80      		ldd r15,Y+3
 2251 0822 CA52      		subi r28,lo8(298)
 2252 0824 D140      		sbci r29,hi8(298)
 2253               	.LVL256:
 2254 0826 C80C      		add r12,r8
 2255 0828 D91C      		adc r13,r9
 2256 082a EA1C      		adc r14,r10
 2257 082c FB1C      		adc r15,r11
 2258               	.LVL257:
1701:stk500boot.c  **** 
 2259               		.loc 1 1701 0
 2260 082e CC0C      		lsl r12
 2261 0830 DD1C      		rol r13
 2262 0832 EE1C      		rol r14
 2263 0834 FF1C      		rol r15
 2264               	.LVL258:
1703:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2265               		.loc 1 1703 0
 2266 0836 60E0      		ldi r22,0
 2267 0838 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2268 083a 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2269 083c 0E94 0000 		call PrintFromPROGMEM
 2270               	.LVL259:
1704:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2271               		.loc 1 1704 0
 2272 0840 892D      		mov r24,r9
 2273 0842 0E94 0000 		call PrintHexByte
 2274               	.LVL260:
1705:stk500boot.c  **** 			sendchar(0x20);
 2275               		.loc 1 1705 0
 2276 0846 882D      		mov r24,r8
 2277 0848 0E94 0000 		call PrintHexByte
 2278               	.LVL261:
1706:stk500boot.c  **** 			sendchar('>');
 2279               		.loc 1 1706 0
 2280 084c 80E2      		ldi r24,lo8(32)
 2281 084e 0E94 0000 		call sendchar
 2282               	.LVL262:
1707:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2283               		.loc 1 1707 0
 2284 0852 8EE3      		ldi r24,lo8(62)
 2285 0854 0E94 0000 		call sendchar
 2286               	.LVL263:
1708:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2287               		.loc 1 1708 0
 2288 0858 80E0      		ldi r24,0
 2289 085a 0E94 0000 		call PrintHexByte
 2290               	.LVL264:
1709:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2291               		.loc 1 1709 0
 2292 085e 8D2D      		mov r24,r13
 2293 0860 0E94 0000 		call PrintHexByte
 2294               	.LVL265:
1710:stk500boot.c  **** 	
 2295               		.loc 1 1710 0
 2296 0864 8C2D      		mov r24,r12
 2297 0866 00C0      		rjmp .L278
 2298               	.LVL266:
 2299               	.L100:
1713:stk500boot.c  **** 		{
 2300               		.loc 1 1713 0
 2301 0868 8EE0      		ldi r24,14
 2302 086a 8822      		and r8,r24
 2303 086c E894      		clt
 2304 086e 90F8      		bld r9,0
 2305 0870 AA24      		clr r10
 2306 0872 BB24      		clr r11
 2307               	.LVL267:
 2308 0874 9CE0      		ldi r25,12
 2309 0876 8916      		cp r8,r25
 2310 0878 94E9      		ldi r25,-108
 2311 087a 9906      		cpc r9,r25
 2312 087c A104      		cpc r10,__zero_reg__
 2313 087e B104      		cpc r11,__zero_reg__
 2314 0880 01F0      		breq .+2
 2315 0882 00C0      		rjmp .L99
1716:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2316               		.loc 1 1716 0
 2317 0884 4F2D      		mov r20,r15
 2318 0886 4170      		andi r20,lo8(1)
 2319 0888 50E0      		ldi r21,0
 2320 088a 60E0      		ldi r22,0
 2321 088c 70E0      		ldi r23,0
 2322 088e DA01      		movw r26,r20
 2323 0890 9927      		clr r25
 2324 0892 8827      		clr r24
 2325 0894 4C2D      		mov r20,r12
 2326 0896 50E0      		ldi r21,0
 2327 0898 60E0      		ldi r22,0
 2328 089a 70E0      		ldi r23,0
 2329 089c 762F      		mov r23,r22
 2330 089e 652F      		mov r22,r21
 2331 08a0 542F      		mov r21,r20
 2332 08a2 4427      		clr r20
 2333 08a4 4E0D      		add r20,r14
 2334 08a6 511D      		adc r21,__zero_reg__
 2335 08a8 611D      		adc r22,__zero_reg__
 2336 08aa 711D      		adc r23,__zero_reg__
 2337 08ac 480F      		add r20,r24
 2338 08ae 591F      		adc r21,r25
 2339 08b0 6A1F      		adc r22,r26
 2340 08b2 7B1F      		adc r23,r27
 2341 08b4 8F2D      		mov r24,r15
 2342 08b6 807F      		andi r24,lo8(-16)
 2343 08b8 90E0      		ldi r25,0
 2344 08ba A0E0      		ldi r26,0
 2345 08bc B0E0      		ldi r27,0
 2346 08be 31E1      		ldi r19,17
 2347               		1:
 2348 08c0 880F      		lsl r24
 2349 08c2 991F      		rol r25
 2350 08c4 AA1F      		rol r26
 2351 08c6 BB1F      		rol r27
 2352 08c8 3A95      		dec r19
 2353 08ca 01F4      		brne 1b
 2354 08cc 840F      		add r24,r20
 2355 08ce 951F      		adc r25,r21
 2356 08d0 A61F      		adc r26,r22
 2357 08d2 B71F      		adc r27,r23
 2358 08d4 2D2D      		mov r18,r13
 2359 08d6 2170      		andi r18,lo8(1)
 2360 08d8 C22E      		mov r12,r18
 2361               	.LVL268:
 2362 08da D12C      		mov r13,__zero_reg__
 2363               	.LVL269:
 2364 08dc E12C      		mov r14,__zero_reg__
 2365 08de F12C      		mov r15,__zero_reg__
 2366               	.LVL270:
 2367 08e0 45E1      		ldi r20,21
 2368               		1:
 2369 08e2 CC0C      		lsl r12
 2370 08e4 DD1C      		rol r13
 2371 08e6 EE1C      		rol r14
 2372 08e8 FF1C      		rol r15
 2373 08ea 4A95      		dec r20
 2374 08ec 01F4      		brne 1b
 2375 08ee C80E      		add r12,r24
 2376 08f0 D91E      		adc r13,r25
 2377 08f2 EA1E      		adc r14,r26
 2378 08f4 FB1E      		adc r15,r27
 2379               	.LVL271:
1721:stk500boot.c  **** 							
 2380               		.loc 1 1721 0
 2381 08f6 4601      		movw r8,r12
 2382 08f8 5701      		movw r10,r14
 2383 08fa 880C      		lsl r8
 2384 08fc 991C      		rol r9
 2385 08fe AA1C      		rol r10
 2386 0900 BB1C      		rol r11
1723:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2387               		.loc 1 1723 0
 2388 0902 60E0      		ldi r22,0
 2389 0904 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2390 0906 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2391 0908 0E94 0000 		call PrintFromPROGMEM
 2392               	.LVL272:
1724:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2393               		.loc 1 1724 0
 2394 090c 8E2D      		mov r24,r14
 2395 090e 0E94 0000 		call PrintHexByte
 2396               	.LVL273:
1725:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2397               		.loc 1 1725 0
 2398 0912 8D2D      		mov r24,r13
 2399 0914 0E94 0000 		call PrintHexByte
 2400               	.LVL274:
1726:stk500boot.c  **** 			sendchar(0x20);
 2401               		.loc 1 1726 0
 2402 0918 8C2D      		mov r24,r12
 2403 091a 0E94 0000 		call PrintHexByte
 2404               	.LVL275:
1727:stk500boot.c  **** 			sendchar('>');
 2405               		.loc 1 1727 0
 2406 091e 80E2      		ldi r24,lo8(32)
 2407 0920 0E94 0000 		call sendchar
 2408               	.LVL276:
1728:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2409               		.loc 1 1728 0
 2410 0924 8EE3      		ldi r24,lo8(62)
 2411 0926 0E94 0000 		call sendchar
 2412               	.LVL277:
1729:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2413               		.loc 1 1729 0
 2414 092a 8A2D      		mov r24,r10
 2415 092c 0E94 0000 		call PrintHexByte
 2416               	.LVL278:
1730:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2417               		.loc 1 1730 0
 2418 0930 892D      		mov r24,r9
 2419 0932 0E94 0000 		call PrintHexByte
 2420               	.LVL279:
1731:stk500boot.c  **** 		}
 2421               		.loc 1 1731 0
 2422 0936 882D      		mov r24,r8
 2423               	.LVL280:
 2424               	.L278:
 2425 0938 0E94 0000 		call PrintHexByte
 2426               	.LVL281:
 2427               	.L99:
1743:stk500boot.c  **** 
 2428               		.loc 1 1743 0
 2429 093c 0E94 0000 		call PrintNewLine
 2430               	.LVL282:
1652:stk500boot.c  **** 	{
 2431               		.loc 1 1652 0
 2432 0940 0933      		cpi r16,57
 2433 0942 1105      		cpc r17,__zero_reg__
 2434 0944 01F0      		breq .+2
 2435 0946 00C0      		rjmp .L101
 2436 0948 00C0      		rjmp .L198
 2437               	.LVL283:
 2438               	.L80:
 2439               	.LBE220:
 2440               	.LBE219:
2109:stk500boot.c  **** 				VectorDisplay();
2110:stk500boot.c  **** 				break;
2111:stk500boot.c  **** 
2112:stk500boot.c  **** 			case 'Y':
2113:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
 2441               		.loc 1 2113 0
 2442 094a 62E0      		ldi r22,lo8(2)
 2443 094c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2444 094e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2445 0950 0E94 0000 		call PrintFromPROGMEMln
 2446               	.LVL284:
 2447               	.LBB225:
 2448               	.LBB195:
1817:stk500boot.c  **** 
 2449               		.loc 1 1817 0
 2450 0954 60E0      		ldi r22,0
 2451 0956 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2452 0958 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2453 095a 0E94 0000 		call PrintFromPROGMEM
 2454               	.LVL285:
1819:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2455               		.loc 1 1819 0
 2456 095e 0E94 0000 		call recchar
 2457               	.LVL286:
1820:stk500boot.c  **** 	sendchar(portLetter);
 2458               		.loc 1 1820 0
 2459 0962 182F      		mov r17,r24
 2460               	.LVL287:
 2461 0964 1F75      		andi r17,lo8(95)
 2462               	.LVL288:
1821:stk500boot.c  **** 	PrintNewLine();
 2463               		.loc 1 1821 0
 2464 0966 812F      		mov r24,r17
 2465 0968 0E94 0000 		call sendchar
 2466               	.LVL289:
1822:stk500boot.c  **** 
 2467               		.loc 1 1822 0
 2468 096c 0E94 0000 		call PrintNewLine
 2469               	.LVL290:
1824:stk500boot.c  **** 	{
 2470               		.loc 1 1824 0
 2471 0970 8FEB      		ldi r24,lo8(-65)
 2472 0972 810F      		add r24,r17
 2473 0974 8A31      		cpi r24,lo8(26)
 2474 0976 00F0      		brlo .+2
 2475 0978 00C0      		rjmp .L103
 2476               	.LVL291:
1827:stk500boot.c  **** 		{
 2477               		.loc 1 1827 0
 2478 097a 1634      		cpi r17,lo8(70)
 2479 097c 01F4      		brne .+2
 2480 097e 00C0      		rjmp .L105
 2481 0980 00F4      		brsh .L106
 2482 0982 1334      		cpi r17,lo8(67)
 2483 0984 01F4      		brne .+2
 2484 0986 00C0      		rjmp .L107
 2485 0988 00F4      		brsh .L108
 2486 098a 1134      		cpi r17,lo8(65)
 2487 098c 01F0      		breq .L109
 2488 098e 1234      		cpi r17,lo8(66)
 2489 0990 01F0      		breq .+2
 2490 0992 00C0      		rjmp .L104
1843:stk500boot.c  **** 				while (!Serial_Available())
 2491               		.loc 1 1843 0
 2492 0994 74B8      		out 0x4,r7
 2493 0996 00C0      		rjmp .L122
 2494               	.L108:
1827:stk500boot.c  **** 		{
 2495               		.loc 1 1827 0
 2496 0998 1434      		cpi r17,lo8(68)
 2497 099a 01F4      		brne .+2
 2498 099c 00C0      		rjmp .L111
 2499 099e 1534      		cpi r17,lo8(69)
 2500 09a0 01F0      		breq .+2
 2501 09a2 00C0      		rjmp .L104
1879:stk500boot.c  **** 				while (!Serial_Available())
 2502               		.loc 1 1879 0
 2503 09a4 7DB8      		out 0xd,r7
 2504 09a6 00C0      		rjmp .L128
 2505               	.L106:
1827:stk500boot.c  **** 		{
 2506               		.loc 1 1827 0
 2507 09a8 1A34      		cpi r17,lo8(74)
 2508 09aa 01F4      		brne .+2
 2509 09ac 00C0      		rjmp .L113
 2510 09ae 00F4      		brsh .L114
 2511 09b0 1734      		cpi r17,lo8(71)
 2512 09b2 01F4      		brne .+2
 2513 09b4 00C0      		rjmp .L115
 2514 09b6 1834      		cpi r17,lo8(72)
 2515 09b8 01F0      		breq .+2
 2516 09ba 00C0      		rjmp .L104
1915:stk500boot.c  **** 				while (!Serial_Available())
 2517               		.loc 1 1915 0
 2518 09bc 7092 0101 		sts 257,r7
 2519 09c0 00C0      		rjmp .L134
 2520               	.L114:
1827:stk500boot.c  **** 		{
 2521               		.loc 1 1827 0
 2522 09c2 1B34      		cpi r17,lo8(75)
 2523 09c4 01F4      		brne .+2
 2524 09c6 00C0      		rjmp .L117
 2525 09c8 1C34      		cpi r17,lo8(76)
 2526 09ca 01F0      		breq .+2
 2527 09cc 00C0      		rjmp .L104
1963:stk500boot.c  **** 				while (!Serial_Available())
 2528               		.loc 1 1963 0
 2529 09ce 7092 0A01 		sts 266,r7
 2530 09d2 00C0      		rjmp .L140
 2531               	.L109:
1831:stk500boot.c  **** 				while (!Serial_Available())
 2532               		.loc 1 1831 0
 2533 09d4 71B8      		out 0x1,r7
 2534               	.L119:
 2535               	.LBB172:
 2536               	.LBB173:
 477:stk500boot.c  **** }
 2537               		.loc 1 477 0
 2538 09d6 8091 C000 		lds r24,192
 2539               	.LBE173:
 2540               	.LBE172:
1832:stk500boot.c  **** 				{
 2541               		.loc 1 1832 0
 2542 09da 87FD      		sbrc r24,7
 2543 09dc 00C0      		rjmp .L286
1834:stk500boot.c  **** 					delay_ms(200);
 2544               		.loc 1 1834 0
 2545 09de 82B1      		in r24,0x2
 2546 09e0 8095      		com r24
 2547 09e2 82B9      		out 0x2,r24
1835:stk500boot.c  **** 				}
 2548               		.loc 1 1835 0
 2549 09e4 88EC      		ldi r24,lo8(-56)
 2550 09e6 90E0      		ldi r25,0
 2551 09e8 0E94 0000 		call delay_ms
 2552               	.LVL292:
 2553 09ec 00C0      		rjmp .L119
 2554               	.L122:
 2555               	.LBB174:
 2556               	.LBB175:
 477:stk500boot.c  **** }
 2557               		.loc 1 477 0
 2558 09ee 8091 C000 		lds r24,192
 2559               	.LBE175:
 2560               	.LBE174:
1844:stk500boot.c  **** 				{
 2561               		.loc 1 1844 0
 2562 09f2 87FD      		sbrc r24,7
 2563 09f4 00C0      		rjmp .L287
1846:stk500boot.c  **** 					delay_ms(200);
 2564               		.loc 1 1846 0
 2565 09f6 85B1      		in r24,0x5
 2566 09f8 8095      		com r24
 2567 09fa 85B9      		out 0x5,r24
1847:stk500boot.c  **** 				}
 2568               		.loc 1 1847 0
 2569 09fc 88EC      		ldi r24,lo8(-56)
 2570 09fe 90E0      		ldi r25,0
 2571 0a00 0E94 0000 		call delay_ms
 2572               	.LVL293:
 2573 0a04 00C0      		rjmp .L122
 2574               	.L287:
1849:stk500boot.c  **** 				break;
 2575               		.loc 1 1849 0
 2576 0a06 15B8      		out 0x5,__zero_reg__
 2577 0a08 00C0      		rjmp .L121
 2578               	.L107:
1855:stk500boot.c  **** 				while (!Serial_Available())
 2579               		.loc 1 1855 0
 2580 0a0a 77B8      		out 0x7,r7
 2581               	.L124:
 2582               	.LBB176:
 2583               	.LBB177:
 477:stk500boot.c  **** }
 2584               		.loc 1 477 0
 2585 0a0c 8091 C000 		lds r24,192
 2586               	.LBE177:
 2587               	.LBE176:
1856:stk500boot.c  **** 				{
 2588               		.loc 1 1856 0
 2589 0a10 87FD      		sbrc r24,7
 2590 0a12 00C0      		rjmp .L288
1858:stk500boot.c  **** 					delay_ms(200);
 2591               		.loc 1 1858 0
 2592 0a14 88B1      		in r24,0x8
 2593 0a16 8095      		com r24
 2594 0a18 88B9      		out 0x8,r24
1859:stk500boot.c  **** 				}
 2595               		.loc 1 1859 0
 2596 0a1a 88EC      		ldi r24,lo8(-56)
 2597 0a1c 90E0      		ldi r25,0
 2598 0a1e 0E94 0000 		call delay_ms
 2599               	.LVL294:
 2600 0a22 00C0      		rjmp .L124
 2601               	.L288:
1861:stk500boot.c  **** 				break;
 2602               		.loc 1 1861 0
 2603 0a24 18B8      		out 0x8,__zero_reg__
 2604 0a26 00C0      		rjmp .L121
 2605               	.L111:
1867:stk500boot.c  **** 				while (!Serial_Available())
 2606               		.loc 1 1867 0
 2607 0a28 7AB8      		out 0xa,r7
 2608               	.L126:
 2609               	.LBB178:
 2610               	.LBB179:
 477:stk500boot.c  **** }
 2611               		.loc 1 477 0
 2612 0a2a 8091 C000 		lds r24,192
 2613               	.LBE179:
 2614               	.LBE178:
1868:stk500boot.c  **** 				{
 2615               		.loc 1 1868 0
 2616 0a2e 87FD      		sbrc r24,7
 2617 0a30 00C0      		rjmp .L289
1870:stk500boot.c  **** 					delay_ms(200);
 2618               		.loc 1 1870 0
 2619 0a32 8BB1      		in r24,0xb
 2620 0a34 8095      		com r24
 2621 0a36 8BB9      		out 0xb,r24
1871:stk500boot.c  **** 				}
 2622               		.loc 1 1871 0
 2623 0a38 88EC      		ldi r24,lo8(-56)
 2624 0a3a 90E0      		ldi r25,0
 2625 0a3c 0E94 0000 		call delay_ms
 2626               	.LVL295:
 2627 0a40 00C0      		rjmp .L126
 2628               	.L289:
1873:stk500boot.c  **** 				break;
 2629               		.loc 1 1873 0
 2630 0a42 1BB8      		out 0xb,__zero_reg__
 2631 0a44 00C0      		rjmp .L121
 2632               	.L128:
 2633               	.LBB180:
 2634               	.LBB181:
 477:stk500boot.c  **** }
 2635               		.loc 1 477 0
 2636 0a46 8091 C000 		lds r24,192
 2637               	.LBE181:
 2638               	.LBE180:
1880:stk500boot.c  **** 				{
 2639               		.loc 1 1880 0
 2640 0a4a 87FD      		sbrc r24,7
 2641 0a4c 00C0      		rjmp .L290
1882:stk500boot.c  **** 					delay_ms(200);
 2642               		.loc 1 1882 0
 2643 0a4e 8EB1      		in r24,0xe
 2644 0a50 8095      		com r24
 2645 0a52 8EB9      		out 0xe,r24
1883:stk500boot.c  **** 				}
 2646               		.loc 1 1883 0
 2647 0a54 88EC      		ldi r24,lo8(-56)
 2648 0a56 90E0      		ldi r25,0
 2649 0a58 0E94 0000 		call delay_ms
 2650               	.LVL296:
 2651 0a5c 00C0      		rjmp .L128
 2652               	.L290:
1885:stk500boot.c  **** 				break;
 2653               		.loc 1 1885 0
 2654 0a5e 1EB8      		out 0xe,__zero_reg__
 2655 0a60 00C0      		rjmp .L121
 2656               	.L105:
1891:stk500boot.c  **** 				while (!Serial_Available())
 2657               		.loc 1 1891 0
 2658 0a62 70BA      		out 0x10,r7
 2659               	.L130:
 2660               	.LBB182:
 2661               	.LBB183:
 477:stk500boot.c  **** }
 2662               		.loc 1 477 0
 2663 0a64 8091 C000 		lds r24,192
 2664               	.LBE183:
 2665               	.LBE182:
1892:stk500boot.c  **** 				{
 2666               		.loc 1 1892 0
 2667 0a68 87FD      		sbrc r24,7
 2668 0a6a 00C0      		rjmp .L291
1894:stk500boot.c  **** 					delay_ms(200);
 2669               		.loc 1 1894 0
 2670 0a6c 81B3      		in r24,0x11
 2671 0a6e 8095      		com r24
 2672 0a70 81BB      		out 0x11,r24
1895:stk500boot.c  **** 				}
 2673               		.loc 1 1895 0
 2674 0a72 88EC      		ldi r24,lo8(-56)
 2675 0a74 90E0      		ldi r25,0
 2676 0a76 0E94 0000 		call delay_ms
 2677               	.LVL297:
 2678 0a7a 00C0      		rjmp .L130
 2679               	.L291:
1897:stk500boot.c  **** 				break;
 2680               		.loc 1 1897 0
 2681 0a7c 11BA      		out 0x11,__zero_reg__
 2682 0a7e 00C0      		rjmp .L121
 2683               	.L115:
1903:stk500boot.c  **** 				while (!Serial_Available())
 2684               		.loc 1 1903 0
 2685 0a80 73BA      		out 0x13,r7
 2686               	.L132:
 2687               	.LBB184:
 2688               	.LBB185:
 477:stk500boot.c  **** }
 2689               		.loc 1 477 0
 2690 0a82 8091 C000 		lds r24,192
 2691               	.LBE185:
 2692               	.LBE184:
1904:stk500boot.c  **** 				{
 2693               		.loc 1 1904 0
 2694 0a86 87FD      		sbrc r24,7
 2695 0a88 00C0      		rjmp .L292
1906:stk500boot.c  **** 					delay_ms(200);
 2696               		.loc 1 1906 0
 2697 0a8a 84B3      		in r24,0x14
 2698 0a8c 8095      		com r24
 2699 0a8e 84BB      		out 0x14,r24
1907:stk500boot.c  **** 				}
 2700               		.loc 1 1907 0
 2701 0a90 88EC      		ldi r24,lo8(-56)
 2702 0a92 90E0      		ldi r25,0
 2703 0a94 0E94 0000 		call delay_ms
 2704               	.LVL298:
 2705 0a98 00C0      		rjmp .L132
 2706               	.L292:
1909:stk500boot.c  **** 				break;
 2707               		.loc 1 1909 0
 2708 0a9a 14BA      		out 0x14,__zero_reg__
 2709 0a9c 00C0      		rjmp .L121
 2710               	.L134:
 2711               	.LBB186:
 2712               	.LBB187:
 477:stk500boot.c  **** }
 2713               		.loc 1 477 0
 2714 0a9e 8091 C000 		lds r24,192
 2715               	.LBE187:
 2716               	.LBE186:
1916:stk500boot.c  **** 				{
 2717               		.loc 1 1916 0
 2718 0aa2 87FD      		sbrc r24,7
 2719 0aa4 00C0      		rjmp .L293
1918:stk500boot.c  **** 					delay_ms(200);
 2720               		.loc 1 1918 0
 2721 0aa6 8091 0201 		lds r24,258
 2722 0aaa 8095      		com r24
 2723 0aac 8093 0201 		sts 258,r24
1919:stk500boot.c  **** 				}
 2724               		.loc 1 1919 0
 2725 0ab0 88EC      		ldi r24,lo8(-56)
 2726 0ab2 90E0      		ldi r25,0
 2727 0ab4 0E94 0000 		call delay_ms
 2728               	.LVL299:
 2729 0ab8 00C0      		rjmp .L134
 2730               	.L293:
1921:stk500boot.c  **** 				break;
 2731               		.loc 1 1921 0
 2732 0aba 1092 0201 		sts 258,__zero_reg__
 2733 0abe 00C0      		rjmp .L121
 2734               	.L113:
1939:stk500boot.c  **** 				while (!Serial_Available())
 2735               		.loc 1 1939 0
 2736 0ac0 7092 0401 		sts 260,r7
 2737               	.L136:
 2738               	.LBB188:
 2739               	.LBB189:
 477:stk500boot.c  **** }
 2740               		.loc 1 477 0
 2741 0ac4 8091 C000 		lds r24,192
 2742               	.LBE189:
 2743               	.LBE188:
1940:stk500boot.c  **** 				{
 2744               		.loc 1 1940 0
 2745 0ac8 87FD      		sbrc r24,7
 2746 0aca 00C0      		rjmp .L294
1942:stk500boot.c  **** 					delay_ms(200);
 2747               		.loc 1 1942 0
 2748 0acc 8091 0501 		lds r24,261
 2749 0ad0 8095      		com r24
 2750 0ad2 8093 0501 		sts 261,r24
1943:stk500boot.c  **** 				}
 2751               		.loc 1 1943 0
 2752 0ad6 88EC      		ldi r24,lo8(-56)
 2753 0ad8 90E0      		ldi r25,0
 2754 0ada 0E94 0000 		call delay_ms
 2755               	.LVL300:
 2756 0ade 00C0      		rjmp .L136
 2757               	.L294:
1945:stk500boot.c  **** 				break;
 2758               		.loc 1 1945 0
 2759 0ae0 1092 0501 		sts 261,__zero_reg__
 2760 0ae4 00C0      		rjmp .L121
 2761               	.L117:
1951:stk500boot.c  **** 				while (!Serial_Available())
 2762               		.loc 1 1951 0
 2763 0ae6 7092 0701 		sts 263,r7
 2764               	.L138:
 2765               	.LBB190:
 2766               	.LBB191:
 477:stk500boot.c  **** }
 2767               		.loc 1 477 0
 2768 0aea 8091 C000 		lds r24,192
 2769               	.LBE191:
 2770               	.LBE190:
1952:stk500boot.c  **** 				{
 2771               		.loc 1 1952 0
 2772 0aee 87FD      		sbrc r24,7
 2773 0af0 00C0      		rjmp .L295
1954:stk500boot.c  **** 					delay_ms(200);
 2774               		.loc 1 1954 0
 2775 0af2 8091 0801 		lds r24,264
 2776 0af6 8095      		com r24
 2777 0af8 8093 0801 		sts 264,r24
1955:stk500boot.c  **** 				}
 2778               		.loc 1 1955 0
 2779 0afc 88EC      		ldi r24,lo8(-56)
 2780 0afe 90E0      		ldi r25,0
 2781 0b00 0E94 0000 		call delay_ms
 2782               	.LVL301:
 2783 0b04 00C0      		rjmp .L138
 2784               	.L295:
1957:stk500boot.c  **** 				break;
 2785               		.loc 1 1957 0
 2786 0b06 1092 0801 		sts 264,__zero_reg__
 2787 0b0a 00C0      		rjmp .L121
 2788               	.L140:
 2789               	.LBB192:
 2790               	.LBB193:
 477:stk500boot.c  **** }
 2791               		.loc 1 477 0
 2792 0b0c 8091 C000 		lds r24,192
 2793               	.LBE193:
 2794               	.LBE192:
1964:stk500boot.c  **** 				{
 2795               		.loc 1 1964 0
 2796 0b10 87FD      		sbrc r24,7
 2797 0b12 00C0      		rjmp .L296
1966:stk500boot.c  **** 					delay_ms(200);
 2798               		.loc 1 1966 0
 2799 0b14 8091 0B01 		lds r24,267
 2800 0b18 8095      		com r24
 2801 0b1a 8093 0B01 		sts 267,r24
1967:stk500boot.c  **** 				}
 2802               		.loc 1 1967 0
 2803 0b1e 88EC      		ldi r24,lo8(-56)
 2804 0b20 90E0      		ldi r25,0
 2805 0b22 0E94 0000 		call delay_ms
 2806               	.LVL302:
 2807 0b26 00C0      		rjmp .L140
 2808               	.L296:
1969:stk500boot.c  **** 				break;
 2809               		.loc 1 1969 0
 2810 0b28 1092 0B01 		sts 267,__zero_reg__
 2811 0b2c 00C0      		rjmp .L121
 2812               	.L104:
1974:stk500boot.c  **** 				getCharFlag	=	false;
 2813               		.loc 1 1974 0
 2814 0b2e 60E0      		ldi r22,0
 2815 0b30 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2816 0b32 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2817 0b34 00C0      		rjmp .L276
 2818               	.LVL303:
 2819               	.L103:
1985:stk500boot.c  **** 	}
 2820               		.loc 1 1985 0
 2821 0b36 60E0      		ldi r22,0
 2822 0b38 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2823 0b3a 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2824 0b3c 00C0      		rjmp .L276
 2825               	.LVL304:
 2826               	.L66:
 2827               	.LBE195:
 2828               	.LBE225:
2114:stk500boot.c  **** 				AVR_PortOutput();
2115:stk500boot.c  **** 				break;
2116:stk500boot.c  **** 			
2117:stk500boot.c  **** 			default:
2118:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 2829               		.loc 1 2118 0
 2830 0b3e 60E0      		ldi r22,0
 2831 0b40 80E0      		ldi r24,lo8(gTextMsg_HUH)
 2832 0b42 90E0      		ldi r25,hi8(gTextMsg_HUH)
 2833               	.LVL305:
 2834               	.L276:
 2835 0b44 0E94 0000 		call PrintFromPROGMEMln
 2836               	.LVL306:
 2837 0b48 00C0      		rjmp .L198
 2838               	.LVL307:
 2839               	.L58:
 2840               	.LBE226:
 2841               	.LBE227:
 710:stk500boot.c  **** 				{
 2842               		.loc 1 710 0
 2843 0b4a 8330      		cpi r24,lo8(3)
 2844 0b4c 01F0      		breq .L205
 2845 0b4e 00F4      		brsh .L144
 2846 0b50 8130      		cpi r24,lo8(1)
 2847 0b52 01F0      		breq .L203
 2848 0b54 00F0      		brlo .L272
 2849 0b56 00C0      		rjmp .L297
 2850               	.L144:
 2851 0b58 8530      		cpi r24,lo8(5)
 2852 0b5a 01F0      		breq .L206
 2853 0b5c 00F0      		brlo .L149
 2854 0b5e 8630      		cpi r24,lo8(6)
 2855 0b60 01F0      		breq .+2
 2856 0b62 00C0      		rjmp .L298
 706:stk500boot.c  **** 				}
 2857               		.loc 1 706 0
 2858 0b64 E12C      		mov r14,__zero_reg__
 2859 0b66 F12C      		mov r15,__zero_reg__
 2860 0b68 00C0      		rjmp .L150
 2861               	.L272:
 2862 0b6a E12C      		mov r14,__zero_reg__
 2863 0b6c F12C      		mov r15,__zero_reg__
 713:stk500boot.c  **** 						{
 2864               		.loc 1 713 0
 2865 0b6e 9B31      		cpi r25,lo8(27)
 2866 0b70 01F4      		brne .+2
 2867 0b72 00C0      		rjmp .L208
 2868               	.LVL308:
 2869               	.L152:
 2870 0b74 00E0      		ldi r16,0
 2871 0b76 10E0      		ldi r17,0
 2872 0b78 00C0      		rjmp .L196
 2873               	.LVL309:
 2874               	.L203:
 706:stk500boot.c  **** 				}
 2875               		.loc 1 706 0
 2876 0b7a E12C      		mov r14,__zero_reg__
 2877 0b7c F12C      		mov r15,__zero_reg__
 2878               	.LVL310:
 2879               	.L145:
 724:stk500boot.c  **** 					#else
 2880               		.loc 1 724 0
 2881 0b7e B926      		eor r11,r25
 2882               	.LVL311:
 737:stk500boot.c  **** 
 2883               		.loc 1 737 0
 2884 0b80 692E      		mov r6,r25
 723:stk500boot.c  **** 						checksum		^=	c;
 2885               		.loc 1 723 0
 2886 0b82 82E0      		ldi r24,lo8(2)
 737:stk500boot.c  **** 
 2887               		.loc 1 737 0
 2888 0b84 00C0      		rjmp .L152
 2889               	.LVL312:
 2890               	.L297:
 706:stk500boot.c  **** 				}
 2891               		.loc 1 706 0
 2892 0b86 E12C      		mov r14,__zero_reg__
 2893 0b88 F12C      		mov r15,__zero_reg__
 2894               	.LVL313:
 2895               	.L146:
 740:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2896               		.loc 1 740 0
 2897 0b8a 292F      		mov r18,r25
 2898               	.LVL314:
 2899 0b8c 30E0      		ldi r19,0
 2900 0b8e 322F      		mov r19,r18
 2901 0b90 2227      		clr r18
 2902               	.LVL315:
 742:stk500boot.c  **** 						break;
 2903               		.loc 1 742 0
 2904 0b92 B926      		eor r11,r25
 2905               	.LVL316:
 741:stk500boot.c  **** 						checksum		^=	c;
 2906               		.loc 1 741 0
 2907 0b94 83E0      		ldi r24,lo8(3)
 743:stk500boot.c  **** 
 2908               		.loc 1 743 0
 2909 0b96 00C0      		rjmp .L152
 2910               	.LVL317:
 2911               	.L205:
 706:stk500boot.c  **** 				}
 2912               		.loc 1 706 0
 2913 0b98 E12C      		mov r14,__zero_reg__
 2914 0b9a F12C      		mov r15,__zero_reg__
 2915               	.LVL318:
 2916               	.L143:
 746:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 2917               		.loc 1 746 0
 2918 0b9c 292B      		or r18,r25
 2919               	.LVL319:
 748:stk500boot.c  **** 						break;
 2920               		.loc 1 748 0
 2921 0b9e B926      		eor r11,r25
 2922               	.LVL320:
 747:stk500boot.c  **** 						checksum		^=	c;
 2923               		.loc 1 747 0
 2924 0ba0 84E0      		ldi r24,lo8(4)
 749:stk500boot.c  **** 
 2925               		.loc 1 749 0
 2926 0ba2 00C0      		rjmp .L152
 2927               	.LVL321:
 2928               	.L149:
 752:stk500boot.c  **** 						{
 2929               		.loc 1 752 0
 2930 0ba4 9E30      		cpi r25,lo8(14)
 2931 0ba6 01F0      		breq .+2
 2932 0ba8 00C0      		rjmp .L209
 2933               	.LVL322:
 755:stk500boot.c  **** 							ii				=	0;
 2934               		.loc 1 755 0
 2935 0baa B926      		eor r11,r25
 2936               	.LVL323:
 706:stk500boot.c  **** 				}
 2937               		.loc 1 706 0
 2938 0bac E12C      		mov r14,__zero_reg__
 2939 0bae F12C      		mov r15,__zero_reg__
 756:stk500boot.c  **** 						}
 2940               		.loc 1 756 0
 2941 0bb0 CA5D      		subi r28,lo8(-294)
 2942 0bb2 DE4F      		sbci r29,hi8(-294)
 2943 0bb4 1982      		std Y+1,__zero_reg__
 2944 0bb6 1882      		st Y,__zero_reg__
 2945 0bb8 C652      		subi r28,lo8(294)
 2946 0bba D140      		sbci r29,hi8(294)
 2947 0bbc 00C0      		rjmp .L274
 2948               	.LVL324:
 2949               	.L206:
 706:stk500boot.c  **** 				}
 2950               		.loc 1 706 0
 2951 0bbe E12C      		mov r14,__zero_reg__
 2952 0bc0 F12C      		mov r15,__zero_reg__
 2953               	.LVL325:
 2954               	.L148:
 765:stk500boot.c  **** 						checksum		^=	c;
 2955               		.loc 1 765 0
 2956 0bc2 CA5D      		subi r28,lo8(-294)
 2957 0bc4 DE4F      		sbci r29,hi8(-294)
 2958 0bc6 4881      		ld r20,Y
 2959 0bc8 5981      		ldd r21,Y+1
 2960 0bca C652      		subi r28,lo8(294)
 2961 0bcc D140      		sbci r29,hi8(294)
 2962 0bce 4F5F      		subi r20,-1
 2963 0bd0 5F4F      		sbci r21,-1
 2964               	.LVL326:
 2965 0bd2 E1E0      		ldi r30,lo8(1)
 2966 0bd4 F0E0      		ldi r31,0
 2967 0bd6 EC0F      		add r30,r28
 2968 0bd8 FD1F      		adc r31,r29
 2969 0bda CA5D      		subi r28,lo8(-294)
 2970 0bdc DE4F      		sbci r29,hi8(-294)
 2971 0bde A881      		ld r26,Y
 2972 0be0 B981      		ldd r27,Y+1
 2973 0be2 C652      		subi r28,lo8(294)
 2974 0be4 D140      		sbci r29,hi8(294)
 2975               	.LVL327:
 2976 0be6 EA0F      		add r30,r26
 2977 0be8 FB1F      		adc r31,r27
 2978 0bea 9083      		st Z,r25
 766:stk500boot.c  **** 						if (ii == msgLength )
 2979               		.loc 1 766 0
 2980 0bec B926      		eor r11,r25
 2981               	.LVL328:
 767:stk500boot.c  **** 						{
 2982               		.loc 1 767 0
 2983 0bee 4217      		cp r20,r18
 2984 0bf0 5307      		cpc r21,r19
 2985 0bf2 01F4      		brne .+2
 2986 0bf4 00C0      		rjmp .L210
 2987 0bf6 CA5D      		subi r28,lo8(-294)
 2988 0bf8 DE4F      		sbci r29,hi8(-294)
 2989 0bfa 5983      		std Y+1,r21
 2990 0bfc 4883      		st Y,r20
 2991 0bfe C652      		subi r28,lo8(294)
 2992 0c00 D140      		sbci r29,hi8(294)
 2993               	.LVL329:
 2994               	.L274:
 2995 0c02 85E0      		ldi r24,lo8(5)
 2996 0c04 00C0      		rjmp .L152
 2997               	.LVL330:
 2998               	.L201:
 706:stk500boot.c  **** 				}
 2999               		.loc 1 706 0
 3000 0c06 E12C      		mov r14,__zero_reg__
 3001 0c08 F12C      		mov r15,__zero_reg__
 3002               	.LVL331:
 3003               	.L59:
 710:stk500boot.c  **** 				{
 3004               		.loc 1 710 0
 3005 0c0a 8330      		cpi r24,lo8(3)
 3006 0c0c 01F0      		breq .L143
 3007 0c0e 00F4      		brsh .+2
 3008 0c10 00C0      		rjmp .L299
 3009 0c12 8530      		cpi r24,lo8(5)
 3010 0c14 01F0      		breq .L148
 3011 0c16 00F4      		brsh .+2
 3012 0c18 00C0      		rjmp .L220
 3013 0c1a 8630      		cpi r24,lo8(6)
 3014 0c1c 01F4      		brne .L142
 3015               	.LVL332:
 3016               	.L150:
 774:stk500boot.c  **** 						{
 3017               		.loc 1 774 0
 3018 0c1e 9B11      		cpse r25,r11
 3019 0c20 00C0      		rjmp .L220
 3020 0c22 00C0      		rjmp .L211
 3021               	.LVL333:
 3022               	.L298:
 706:stk500boot.c  **** 				}
 3023               		.loc 1 706 0
 3024 0c24 E12C      		mov r14,__zero_reg__
 3025 0c26 F12C      		mov r15,__zero_reg__
 3026               	.LVL334:
 3027               	.L142:
 675:stk500boot.c  **** 			{
 3028               		.loc 1 675 0
 3029 0c28 8730      		cpi r24,lo8(7)
 3030 0c2a 01F0      		breq .+2
 3031 0c2c 00C0      		rjmp .L152
 3032               	.LVL335:
 3033               	.L211:
 3034 0c2e 712C      		mov r7,__zero_reg__
 3035               	.LVL336:
 3036               	.L97:
 790:stk500boot.c  **** 			{
 3037               		.loc 1 790 0
 3038 0c30 2981      		ldd r18,Y+1
 3039 0c32 2331      		cpi r18,lo8(19)
 3040 0c34 01F4      		brne .+2
 3041 0c36 00C0      		rjmp .L154
 3042 0c38 00F4      		brsh .L155
 3043 0c3a 2630      		cpi r18,lo8(6)
 3044 0c3c 01F4      		brne .+2
 3045 0c3e 00C0      		rjmp .L156
 3046 0c40 00F4      		brsh .L157
 3047 0c42 2230      		cpi r18,lo8(2)
 3048 0c44 01F4      		brne .+2
 3049 0c46 00C0      		rjmp .L285
 3050 0c48 2330      		cpi r18,lo8(3)
 3051 0c4a 01F4      		brne .+2
 3052 0c4c 00C0      		rjmp .L159
 3053 0c4e 2130      		cpi r18,lo8(1)
 3054 0c50 01F0      		breq .+2
 3055 0c52 00C0      		rjmp .L153
 3056               	.LVL337:
 854:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 3057               		.loc 1 854 0
 3058 0c54 1A82      		std Y+2,__zero_reg__
 855:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 3059               		.loc 1 855 0
 3060 0c56 88E0      		ldi r24,lo8(8)
 3061 0c58 8B83      		std Y+3,r24
 856:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 3062               		.loc 1 856 0
 3063 0c5a 81E4      		ldi r24,lo8(65)
 3064 0c5c 8C83      		std Y+4,r24
 857:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 3065               		.loc 1 857 0
 3066 0c5e 86E5      		ldi r24,lo8(86)
 3067 0c60 8D83      		std Y+5,r24
 858:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 3068               		.loc 1 858 0
 3069 0c62 82E5      		ldi r24,lo8(82)
 3070 0c64 8E83      		std Y+6,r24
 859:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 3071               		.loc 1 859 0
 3072 0c66 89E4      		ldi r24,lo8(73)
 3073 0c68 8F83      		std Y+7,r24
 860:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 3074               		.loc 1 860 0
 3075 0c6a 83E5      		ldi r24,lo8(83)
 3076 0c6c 8887      		std Y+8,r24
 861:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 3077               		.loc 1 861 0
 3078 0c6e 80E5      		ldi r24,lo8(80)
 3079 0c70 8987      		std Y+9,r24
 862:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 3080               		.loc 1 862 0
 3081 0c72 8FE5      		ldi r24,lo8(95)
 3082 0c74 8A87      		std Y+10,r24
 863:stk500boot.c  **** 					break;
 3083               		.loc 1 863 0
 3084 0c76 82E3      		ldi r24,lo8(50)
 3085 0c78 8B87      		std Y+11,r24
 853:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 3086               		.loc 1 853 0
 3087 0c7a 0BE0      		ldi r16,lo8(11)
 3088 0c7c 10E0      		ldi r17,0
 864:stk500boot.c  **** 
 3089               		.loc 1 864 0
 3090 0c7e 00C0      		rjmp .L173
 3091               	.LVL338:
 3092               	.L157:
 790:stk500boot.c  **** 			{
 3093               		.loc 1 790 0
 3094 0c80 2131      		cpi r18,lo8(17)
 3095 0c82 01F4      		brne .+2
 3096 0c84 00C0      		rjmp .L212
 3097 0c86 00F0      		brlo .+2
 3098 0c88 00C0      		rjmp .L162
 3099 0c8a 2031      		cpi r18,lo8(16)
 3100 0c8c 01F4      		brne .+2
 3101 0c8e 00C0      		rjmp .L285
 3102 0c90 00C0      		rjmp .L153
 3103               	.L155:
 3104 0c92 2831      		cpi r18,lo8(24)
 3105 0c94 01F4      		brne .+2
 3106 0c96 00C0      		rjmp .L163
 3107 0c98 00F4      		brsh .L164
 3108 0c9a 2531      		cpi r18,lo8(21)
 3109 0c9c 01F4      		brne .+2
 3110 0c9e 00C0      		rjmp .L154
 3111 0ca0 00F4      		brsh .+2
 3112 0ca2 00C0      		rjmp .L165
 3113 0ca4 2631      		cpi r18,lo8(22)
 3114 0ca6 01F4      		brne .+2
 3115 0ca8 00C0      		rjmp .L165
 3116 0caa 00C0      		rjmp .L153
 3117               	.L164:
 3118 0cac 2A31      		cpi r18,lo8(26)
 3119 0cae 01F4      		brne .+2
 3120 0cb0 00C0      		rjmp .L166
 3121 0cb2 00F4      		brsh .+2
 3122 0cb4 00C0      		rjmp .L167
 3123 0cb6 2B31      		cpi r18,lo8(27)
 3124 0cb8 01F4      		brne .+2
 3125 0cba 00C0      		rjmp .L168
 3126 0cbc 2D31      		cpi r18,lo8(29)
 3127 0cbe 01F0      		breq .+2
 3128 0cc0 00C0      		rjmp .L153
 3129               	.LVL339:
 3130               	.LBB228:
 798:stk500boot.c  **** 						{
 3131               		.loc 1 798 0
 3132 0cc2 9D81      		ldd r25,Y+5
 3133 0cc4 9033      		cpi r25,lo8(48)
 3134 0cc6 01F4      		brne .L170
 3135               	.LBB229:
 800:stk500boot.c  **** 
 3136               		.loc 1 800 0
 3137 0cc8 8F81      		ldd r24,Y+7
 3138               	.LVL340:
 802:stk500boot.c  **** 							{
 3139               		.loc 1 802 0
 3140 0cca 8823      		tst r24
 3141 0ccc 01F0      		breq .L213
 806:stk500boot.c  **** 							{
 3142               		.loc 1 806 0
 3143 0cce 8130      		cpi r24,lo8(1)
 3144 0cd0 01F4      		brne .L214
 808:stk500boot.c  **** 							}
 3145               		.loc 1 808 0
 3146 0cd2 88E9      		ldi r24,lo8(-104)
 3147               	.LVL341:
 3148 0cd4 00C0      		rjmp .L171
 3149               	.LVL342:
 3150               	.L170:
 3151               	.LBE229:
 815:stk500boot.c  **** 						{
 3152               		.loc 1 815 0
 3153 0cd6 892F      		mov r24,r25
 3154 0cd8 8075      		andi r24,lo8(80)
 3155 0cda 01F0      		breq .L216
 822:stk500boot.c  **** 							{
 3156               		.loc 1 822 0
 3157 0cdc 9035      		cpi r25,lo8(80)
 3158 0cde 01F4      		brne .L172
 3159               	.LBB230:
 824:stk500boot.c  **** 							}
 3160               		.loc 1 824 0
 3161 0ce0 89E0      		ldi r24,lo8(9)
 3162 0ce2 E0E0      		ldi r30,0
 3163 0ce4 F0E0      		ldi r31,0
 3164 0ce6 00C0      		rjmp .L279
 3165               	.L172:
 3166               	.LBE230:
 826:stk500boot.c  **** 							{
 3167               		.loc 1 826 0
 3168 0ce8 9835      		cpi r25,lo8(88)
 3169 0cea 01F4      		brne .L216
 3170               	.LBB231:
 828:stk500boot.c  **** 							}
 3171               		.loc 1 828 0
 3172 0cec 89E0      		ldi r24,lo8(9)
 3173 0cee E3E0      		ldi r30,lo8(3)
 3174 0cf0 F0E0      		ldi r31,0
 3175               	.L279:
 3176               	/* #APP */
 3177               	 ;  828 "stk500boot.c" 1
 3178 0cf2 8093 5700 		sts 87, r24
 3179 0cf6 8491      		lpm r24, Z
 3180               		
 3181               	 ;  0 "" 2
 3182               	.LVL343:
 3183               	/* #NOAPP */
 3184               	.LBE231:
 3185 0cf8 00C0      		rjmp .L171
 3186               	.LVL344:
 3187               	.L213:
 3188               	.LBB232:
 804:stk500boot.c  **** 							}
 3189               		.loc 1 804 0
 3190 0cfa 8EE1      		ldi r24,lo8(30)
 3191               	.LVL345:
 3192 0cfc 00C0      		rjmp .L171
 3193               	.LVL346:
 3194               	.L214:
 812:stk500boot.c  **** 							}
 3195               		.loc 1 812 0
 3196 0cfe 81E0      		ldi r24,lo8(1)
 3197               	.LVL347:
 3198 0d00 00C0      		rjmp .L171
 3199               	.LVL348:
 3200               	.L216:
 3201               	.LBE232:
 837:stk500boot.c  **** 						}
 3202               		.loc 1 837 0
 3203 0d02 80E0      		ldi r24,0
 3204               	.L171:
 3205               	.LVL349:
 842:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3206               		.loc 1 842 0
 3207 0d04 1A82      		std Y+2,__zero_reg__
 843:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3208               		.loc 1 843 0
 3209 0d06 1B82      		std Y+3,__zero_reg__
 844:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3210               		.loc 1 844 0
 3211 0d08 9C83      		std Y+4,r25
 845:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3212               		.loc 1 845 0
 3213 0d0a 1D82      		std Y+5,__zero_reg__
 846:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3214               		.loc 1 846 0
 3215 0d0c 8E83      		std Y+6,r24
 847:stk500boot.c  **** 						}
 3216               		.loc 1 847 0
 3217 0d0e 1F82      		std Y+7,__zero_reg__
 841:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3218               		.loc 1 841 0
 3219 0d10 07E0      		ldi r16,lo8(7)
 3220 0d12 10E0      		ldi r17,0
 3221 0d14 00C0      		rjmp .L173
 3222               	.LVL350:
 3223               	.L159:
 3224 0d16 EA81      		ldd r30,Y+2
 3225 0d18 E059      		subi r30,lo8(-(112))
 3226 0d1a E330      		cpi r30,lo8(3)
 3227 0d1c 00F4      		brsh .L217
 3228 0d1e F0E0      		ldi r31,0
 3229 0d20 E050      		subi r30,lo8(-(CSWTCH.71))
 3230 0d22 F040      		sbci r31,hi8(-(CSWTCH.71))
 3231 0d24 8081      		ld r24,Z
 3232 0d26 00C0      		rjmp .L174
 3233               	.L217:
 3234               	.LBE228:
 3235               	.LBB233:
 870:stk500boot.c  **** 						{
 3236               		.loc 1 870 0
 3237 0d28 80E0      		ldi r24,0
 3238               	.L174:
 3239               	.LVL351:
 892:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3240               		.loc 1 892 0
 3241 0d2a 1A82      		std Y+2,__zero_reg__
 893:stk500boot.c  **** 					}
 3242               		.loc 1 893 0
 3243 0d2c 8B83      		std Y+3,r24
 3244 0d2e 00C0      		rjmp .L281
 3245               	.LVL352:
 3246               	.L212:
 3247               	.LBE233:
 898:stk500boot.c  **** 					//*	fall thru
 3248               		.loc 1 898 0
 3249 0d30 7724      		clr r7
 3250 0d32 7394      		inc r7
 3251               	.LVL353:
 3252 0d34 00C0      		rjmp .L285
 3253               	.LVL354:
 3254               	.L168:
 3255               	.LBB234:
 909:stk500boot.c  **** 						unsigned char signature;
 3256               		.loc 1 909 0
 3257 0d36 8D81      		ldd r24,Y+5
 3258               	.LVL355:
 912:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3259               		.loc 1 912 0
 3260 0d38 8823      		tst r24
 3261 0d3a 01F0      		breq .L218
 914:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3262               		.loc 1 914 0
 3263 0d3c 8130      		cpi r24,lo8(1)
 3264 0d3e 01F4      		brne .L219
 915:stk500boot.c  **** 						else
 3265               		.loc 1 915 0
 3266 0d40 88E9      		ldi r24,lo8(-104)
 3267               	.LVL356:
 3268 0d42 00C0      		rjmp .L284
 3269               	.LVL357:
 3270               	.L218:
 913:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3271               		.loc 1 913 0
 3272 0d44 8EE1      		ldi r24,lo8(30)
 3273               	.LVL358:
 3274 0d46 00C0      		rjmp .L284
 3275               	.LVL359:
 3276               	.L219:
 917:stk500boot.c  **** 
 3277               		.loc 1 917 0
 3278 0d48 81E0      		ldi r24,lo8(1)
 3279               	.LVL360:
 3280 0d4a 00C0      		rjmp .L284
 3281               	.LVL361:
 3282               	.L166:
 3283               	.LBE234:
 928:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3284               		.loc 1 928 0
 3285 0d4c 1A82      		std Y+2,__zero_reg__
 3286               	.LBB235:
 929:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3287               		.loc 1 929 0
 3288 0d4e E1E0      		ldi r30,lo8(1)
 3289 0d50 F0E0      		ldi r31,0
 3290 0d52 89E0      		ldi r24,lo8(9)
 3291               	/* #APP */
 3292               	 ;  929 "stk500boot.c" 1
 3293 0d54 8093 5700 		sts 87, r24
 3294 0d58 8491      		lpm r24, Z
 3295               		
 3296               	 ;  0 "" 2
 3297               	/* #NOAPP */
 3298               	.L283:
 3299               	.LVL362:
 3300               	.LBE235:
 3301 0d5a 8B83      		std Y+3,r24
 930:stk500boot.c  **** 					break;
 3302               		.loc 1 930 0
 3303 0d5c 1C82      		std Y+4,__zero_reg__
 927:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3304               		.loc 1 927 0
 3305 0d5e 04E0      		ldi r16,lo8(4)
 3306 0d60 10E0      		ldi r17,0
 931:stk500boot.c  **** 
 3307               		.loc 1 931 0
 3308 0d62 00C0      		rjmp .L173
 3309               	.LVL363:
 3310               	.L163:
 3311               	.LBB236:
 937:stk500boot.c  **** 						{
 3312               		.loc 1 937 0
 3313 0d64 8B81      		ldd r24,Y+3
 3314 0d66 8035      		cpi r24,lo8(80)
 3315 0d68 01F4      		brne .L176
 939:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3316               		.loc 1 939 0
 3317 0d6a 8C81      		ldd r24,Y+4
 3318 0d6c 8830      		cpi r24,lo8(8)
 3319 0d6e 01F4      		brne .L177
 3320               	.LBB237:
 940:stk500boot.c  **** 							else
 3321               		.loc 1 940 0
 3322 0d70 E2E0      		ldi r30,lo8(2)
 3323 0d72 F0E0      		ldi r31,0
 3324 0d74 89E0      		ldi r24,lo8(9)
 3325 0d76 00C0      		rjmp .L280
 3326               	.L177:
 3327               	.LBE237:
 3328               	.LBB238:
 942:stk500boot.c  **** 						}
 3329               		.loc 1 942 0
 3330 0d78 89E0      		ldi r24,lo8(9)
 3331 0d7a E0E0      		ldi r30,0
 3332 0d7c F0E0      		ldi r31,0
 3333 0d7e 00C0      		rjmp .L280
 3334               	.L176:
 3335               	.LBE238:
 3336               	.LBB239:
 946:stk500boot.c  **** 						}
 3337               		.loc 1 946 0
 3338 0d80 89E0      		ldi r24,lo8(9)
 3339 0d82 E3E0      		ldi r30,lo8(3)
 3340 0d84 F0E0      		ldi r31,0
 3341               	.L280:
 3342               	/* #APP */
 3343               	 ;  946 "stk500boot.c" 1
 3344 0d86 8093 5700 		sts 87, r24
 3345 0d8a 8491      		lpm r24, Z
 3346               		
 3347               	 ;  0 "" 2
 3348               	.LVL364:
 3349               	/* #NOAPP */
 3350               	.L284:
 3351               	.LBE239:
 949:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 3352               		.loc 1 949 0
 3353 0d8c 1A82      		std Y+2,__zero_reg__
 3354 0d8e 00C0      		rjmp .L283
 3355               	.LVL365:
 3356               	.L167:
 3357               	.LBE236:
 3358               	.LBB240:
 960:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3359               		.loc 1 960 0
 3360 0d90 8D81      		ldd r24,Y+5
 3361               	.LVL366:
 3362               	.LBB241:
 961:stk500boot.c  **** 						boot_spm_busy_wait();
 3363               		.loc 1 961 0
 3364 0d92 836C      		ori r24,lo8(-61)
 3365               	.LVL367:
 3366 0d94 99E0      		ldi r25,lo8(9)
 3367               	/* #APP */
 3368               	 ;  961 "stk500boot.c" 1
 3369 0d96 E1E0      		ldi r30, 1
 3370 0d98 F0E0      		ldi r31, 0
 3371 0d9a 082E      		mov r0, r24
 3372 0d9c 9093 5700 		sts 87, r25
 3373 0da0 E895      		spm
 3374               		
 3375               	 ;  0 "" 2
 3376               	/* #NOAPP */
 3377               	.L179:
 3378               	.LBE241:
 962:stk500boot.c  **** 
 3379               		.loc 1 962 0 discriminator 1
 3380 0da2 07B6      		in __tmp_reg__,0x37
 3381 0da4 00FC      		sbrc __tmp_reg__,0
 3382 0da6 00C0      		rjmp .L179
 3383               	.LVL368:
 965:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3384               		.loc 1 965 0
 3385 0da8 1A82      		std Y+2,__zero_reg__
 966:stk500boot.c  **** 					}
 3386               		.loc 1 966 0
 3387 0daa 1B82      		std Y+3,__zero_reg__
 3388               	.LVL369:
 3389               	.L281:
 964:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3390               		.loc 1 964 0
 3391 0dac 03E0      		ldi r16,lo8(3)
 3392 0dae 10E0      		ldi r17,0
 3393               	.LBE240:
 968:stk500boot.c  **** 	#endif
 3394               		.loc 1 968 0
 3395 0db0 00C0      		rjmp .L173
 3396               	.LVL370:
 3397               	.L162:
 974:stk500boot.c  **** 					break;
 3398               		.loc 1 974 0
 3399 0db2 80EC      		ldi r24,lo8(-64)
 3400 0db4 8A83      		std Y+2,r24
 972:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 3401               		.loc 1 972 0
 3402 0db6 02E0      		ldi r16,lo8(2)
 3403 0db8 10E0      		ldi r17,0
 971:stk500boot.c  **** 					msgLength		=	2;
 3404               		.loc 1 971 0
 3405 0dba CE5D      		subi r28,lo8(-290)
 3406 0dbc DE4F      		sbci r29,hi8(-290)
 3407 0dbe 1882      		st Y,__zero_reg__
 3408 0dc0 1982      		std Y+1,__zero_reg__
 3409 0dc2 1A82      		std Y+2,__zero_reg__
 3410 0dc4 1B82      		std Y+3,__zero_reg__
 3411 0dc6 C252      		subi r28,lo8(290)
 3412 0dc8 D140      		sbci r29,hi8(290)
 975:stk500boot.c  **** 
 3413               		.loc 1 975 0
 3414 0dca 00C0      		rjmp .L173
 3415               	.LVL371:
 3416               	.L156:
 3417 0dcc 6A81      		ldd r22,Y+2
 3418 0dce 7B81      		ldd r23,Y+3
 3419 0dd0 8C81      		ldd r24,Y+4
 3420 0dd2 9D81      		ldd r25,Y+5
 3421 0dd4 0E94 0000 		call __bswapsi2
 979:stk500boot.c  **** 	#else
 3422               		.loc 1 979 0
 3423 0dd8 1B01      		movw r2,r22
 3424 0dda 2C01      		movw r4,r24
 3425               	.LVL372:
 3426 0ddc 220C      		lsl r2
 3427 0dde 331C      		rol r3
 3428 0de0 441C      		rol r4
 3429 0de2 551C      		rol r5
 3430               	.L285:
 3431               	.LVL373:
 984:stk500boot.c  **** 					break;
 3432               		.loc 1 984 0
 3433 0de4 1A82      		std Y+2,__zero_reg__
 3434 0de6 00C0      		rjmp .L282
 3435               	.LVL374:
 3436               	.L154:
 3437 0de8 CA80      		ldd r12,Y+2
 3438 0dea DB80      		ldd r13,Y+3
 3439 0dec DC24      		eor r13,r12
 3440 0dee CD24      		eor r12,r13
 3441 0df0 DC24      		eor r13,r12
 3442               	.LVL375:
 3443               	.LBB242:
 997:stk500boot.c  **** 						{
 3444               		.loc 1 997 0
 3445 0df2 2331      		cpi r18,lo8(19)
 3446 0df4 01F0      		breq .+2
 3447 0df6 00C0      		rjmp .L180
1000:stk500boot.c  **** 							{
 3448               		.loc 1 1000 0
 3449 0df8 CE5D      		subi r28,lo8(-290)
 3450 0dfa DE4F      		sbci r29,hi8(-290)
 3451 0dfc 2881      		ld r18,Y
 3452 0dfe 3981      		ldd r19,Y+1
 3453 0e00 4A81      		ldd r20,Y+2
 3454 0e02 5B81      		ldd r21,Y+3
 3455 0e04 C252      		subi r28,lo8(290)
 3456 0e06 D140      		sbci r29,hi8(290)
 3457 0e08 2115      		cp r18,__zero_reg__
 3458 0e0a 60EC      		ldi r22,-64
 3459 0e0c 3607      		cpc r19,r22
 3460 0e0e 63E0      		ldi r22,3
 3461 0e10 4607      		cpc r20,r22
 3462 0e12 5105      		cpc r21,__zero_reg__
 3463 0e14 00F4      		brsh .L181
1002:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3464               		.loc 1 1002 0
 3465 0e16 83E0      		ldi r24,lo8(3)
 3466               	/* #APP */
 3467               	 ;  1002 "stk500boot.c" 1
 3468 0e18 F901      		movw r30, r18
 3469 0e1a 4093 5B00 		sts  91, r20
 3470 0e1e 8093 5700 		sts 87, r24
 3471 0e22 E895      		spm
 3472               		
 3473               	 ;  0 "" 2
 3474               	/* #NOAPP */
 3475               	.L182:
1003:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3476               		.loc 1 1003 0 discriminator 1
 3477 0e24 07B6      		in __tmp_reg__,0x37
 3478 0e26 00FC      		sbrc __tmp_reg__,0
 3479 0e28 00C0      		rjmp .L182
1004:stk500boot.c  **** 							}
 3480               		.loc 1 1004 0
 3481 0e2a CE5D      		subi r28,lo8(-290)
 3482 0e2c DE4F      		sbci r29,hi8(-290)
 3483 0e2e 8881      		ld r24,Y
 3484 0e30 9981      		ldd r25,Y+1
 3485 0e32 AA81      		ldd r26,Y+2
 3486 0e34 BB81      		ldd r27,Y+3
 3487 0e36 C252      		subi r28,lo8(290)
 3488 0e38 D140      		sbci r29,hi8(290)
 3489 0e3a 9F5F      		subi r25,-1
 3490 0e3c AF4F      		sbci r26,-1
 3491 0e3e BF4F      		sbci r27,-1
 3492 0e40 CE5D      		subi r28,lo8(-290)
 3493 0e42 DE4F      		sbci r29,hi8(-290)
 3494 0e44 8883      		st Y,r24
 3495 0e46 9983      		std Y+1,r25
 3496 0e48 AA83      		std Y+2,r26
 3497 0e4a BB83      		std Y+3,r27
 3498 0e4c C252      		subi r28,lo8(290)
 3499 0e4e D140      		sbci r29,hi8(290)
 3500               	.LVL376:
 3501               	.L181:
 3502 0e50 8B85      		ldd r24,Y+11
 3503 0e52 DE01      		movw r26,r28
 3504 0e54 1196      		adiw r26,1
 3505               	.LBE242:
 3506               	.LBB244:
 917:stk500boot.c  **** 
 3507               		.loc 1 917 0 discriminator 1
 3508 0e56 9201      		movw r18,r4
 3509 0e58 8101      		movw r16,r2
 3510               	.LBE244:
 3511               	.LBB245:
1013:stk500boot.c  **** 
 3512               		.loc 1 1013 0 discriminator 1
 3513 0e5a 41E0      		ldi r20,lo8(1)
 3514               	.LVL377:
 3515               	.L184:
 3516 0e5c 1B96      		adiw r26,11
 3517 0e5e 5C91      		ld r21,X
 3518 0e60 1B97      		sbiw r26,11
 3519 0e62 90E0      		ldi r25,0
 3520 0e64 952B      		or r25,r21
 3521               	/* #APP */
 3522               	 ;  1013 "stk500boot.c" 1
 3523 0e66 0C01      		movw  r0, r24
 3524 0e68 F801      		movw r30, r16
 3525 0e6a 2093 5B00 		sts 91, r18
 3526 0e6e 4093 5700 		sts 87, r20
 3527 0e72 E895      		spm
 3528 0e74 1124      		clr  r1
 3529               		
 3530               	 ;  0 "" 2
1015:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3531               		.loc 1 1015 0 discriminator 1
 3532               	/* #NOAPP */
 3533 0e76 0E5F      		subi r16,-2
 3534 0e78 1F4F      		sbci r17,-1
 3535 0e7a 2F4F      		sbci r18,-1
 3536 0e7c 3F4F      		sbci r19,-1
 3537               	.LVL378:
1016:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3538               		.loc 1 1016 0 discriminator 1
 3539 0e7e 92E0      		ldi r25,2
 3540 0e80 C91A      		sub r12,r25
 3541 0e82 D108      		sbc r13,__zero_reg__
 3542               	.LVL379:
 3543 0e84 1296      		adiw r26,2
 3544               	.LVL380:
1017:stk500boot.c  **** 
 3545               		.loc 1 1017 0 discriminator 1
 3546 0e86 C114      		cp r12,__zero_reg__
 3547 0e88 D104      		cpc r13,__zero_reg__
 3548 0e8a 01F0      		breq .L183
1010:stk500boot.c  **** 
 3549               		.loc 1 1010 0
 3550 0e8c 1A96      		adiw r26,10
 3551 0e8e 8C91      		ld r24,X
 3552 0e90 1A97      		sbiw r26,10
 3553               	.LVL381:
 3554 0e92 00C0      		rjmp .L184
 3555               	.LVL382:
 3556               	.L183:
1019:stk500boot.c  **** 							boot_spm_busy_wait();
 3557               		.loc 1 1019 0
 3558 0e94 A5E0      		ldi r26,lo8(5)
 3559               	.LVL383:
 3560               	/* #APP */
 3561               	 ;  1019 "stk500boot.c" 1
 3562 0e96 F101      		movw r30, r2
 3563 0e98 4092 5B00 		sts 91, r4
 3564 0e9c A093 5700 		sts 87, r26
 3565 0ea0 E895      		spm
 3566               		
 3567               	 ;  0 "" 2
 3568               	/* #NOAPP */
 3569               	.L185:
1020:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3570               		.loc 1 1020 0 discriminator 1
 3571 0ea2 07B6      		in __tmp_reg__,0x37
 3572 0ea4 00FC      		sbrc __tmp_reg__,0
 3573 0ea6 00C0      		rjmp .L185
1021:stk500boot.c  **** 						}
 3574               		.loc 1 1021 0
 3575 0ea8 81E1      		ldi r24,lo8(17)
 3576               	/* #APP */
 3577               	 ;  1021 "stk500boot.c" 1
 3578 0eaa 8093 5700 		sts 87, r24
 3579 0eae E895      		spm
 3580               		
 3581               	 ;  0 "" 2
 3582               	/* #NOAPP */
 3583 0eb0 00C0      		rjmp .L186
 3584               	.LVL384:
 3585               	.L180:
 3586               	.LBB243:
1026:stk500boot.c  **** 							/* write EEPROM */
 3587               		.loc 1 1026 0
 3588 0eb2 D201      		movw r26,r4
 3589 0eb4 C101      		movw r24,r2
 3590 0eb6 B695      		lsr r27
 3591 0eb8 A795      		ror r26
 3592 0eba 9795      		ror r25
 3593 0ebc 8795      		ror r24
 3594 0ebe 5C01      		movw r10,r24
 3595               	.LVL385:
 3596 0ec0 4E01      		movw r8,r28
 3597 0ec2 BBE0      		ldi r27,11
 3598 0ec4 8B0E      		add r8,r27
 3599 0ec6 911C      		adc r9,__zero_reg__
1028:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3600               		.loc 1 1028 0
 3601 0ec8 00E0      		ldi r16,0
 3602 0eca 10E0      		ldi r17,0
 3603               	.LVL386:
 3604               	.L187:
 3605 0ecc 0C15      		cp r16,r12
 3606 0ece 1D05      		cpc r17,r13
 3607 0ed0 01F0      		breq .L300
1029:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 3608               		.loc 1 1029 0
 3609 0ed2 F401      		movw r30,r8
 3610 0ed4 6191      		ld r22,Z+
 3611 0ed6 4F01      		movw r8,r30
 3612 0ed8 C801      		movw r24,r16
 3613 0eda 8A0D      		add r24,r10
 3614 0edc 9B1D      		adc r25,r11
 3615 0ede 0E94 0000 		call eeprom_write_byte
 3616               	.LVL387:
 3617 0ee2 0F5F      		subi r16,-1
 3618 0ee4 1F4F      		sbci r17,-1
 3619               	.LVL388:
 3620 0ee6 00C0      		rjmp .L187
 3621               	.L300:
 3622 0ee8 20E0      		ldi r18,0
 3623 0eea 30E0      		ldi r19,0
 3624 0eec 000F      		lsl r16
 3625 0eee 111F      		rol r17
 3626 0ef0 221F      		rol r18
 3627 0ef2 331F      		rol r19
 3628               	.LVL389:
 3629 0ef4 020D      		add r16,r2
 3630 0ef6 131D      		adc r17,r3
 3631 0ef8 241D      		adc r18,r4
 3632 0efa 351D      		adc r19,r5
 3633               	.L186:
 3634               	.LVL390:
 3635               	.LBE243:
1036:stk500boot.c  **** 					}
 3636               		.loc 1 1036 0
 3637 0efc 1A82      		std Y+2,__zero_reg__
 3638               	.LBE245:
1038:stk500boot.c  **** 
 3639               		.loc 1 1038 0
 3640 0efe 1801      		movw r2,r16
 3641 0f00 2901      		movw r4,r18
 3642               	.LVL391:
 3643 0f02 00C0      		rjmp .L282
 3644               	.LVL392:
 3645               	.L165:
 3646 0f04 8A81      		ldd r24,Y+2
 3647 0f06 9B81      		ldd r25,Y+3
 3648 0f08 9827      		eor r25,r24
 3649 0f0a 8927      		eor r24,r25
 3650 0f0c 9827      		eor r25,r24
 3651               	.LVL393:
 3652               	.LBB246:
1045:stk500boot.c  **** 
 3653               		.loc 1 1045 0
 3654 0f0e 8C01      		movw r16,r24
 3655 0f10 0D5F      		subi r16,-3
 3656 0f12 1F4F      		sbci r17,-1
 3657               	.LVL394:
1047:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3658               		.loc 1 1047 0
 3659 0f14 1A82      		std Y+2,__zero_reg__
1048:stk500boot.c  **** 						{
 3660               		.loc 1 1048 0
 3661 0f16 2431      		cpi r18,lo8(20)
 3662 0f18 01F4      		brne .L189
 3663 0f1a DE01      		movw r26,r28
 3664 0f1c 1196      		adiw r26,1
 3665               	.LVL395:
 3666               	.L190:
 3667               	.LBB247:
 3668               	.LBB248:
1056:stk500boot.c  **** 						#else
 3669               		.loc 1 1056 0 discriminator 1
 3670               	/* #APP */
 3671               	 ;  1056 "stk500boot.c" 1
 3672 0f1e 4BBE      		out 59, r4
 3673 0f20 F101      		movw r30, r2
 3674 0f22 2791      		elpm r18, Z+
 3675 0f24 3691      		elpm r19, Z
 3676               		
 3677               	 ;  0 "" 2
 3678               	.LVL396:
 3679               	/* #NOAPP */
 3680               	.LBE248:
1060:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3681               		.loc 1 1060 0 discriminator 1
 3682 0f26 1296      		adiw r26,2
 3683 0f28 2C93      		st X,r18
 3684 0f2a 1297      		sbiw r26,2
 3685 0f2c FD01      		movw r30,r26
 3686 0f2e 3496      		adiw r30,4
 3687               	.LVL397:
1061:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3688               		.loc 1 1061 0 discriminator 1
 3689 0f30 1396      		adiw r26,3
 3690 0f32 3C93      		st X,r19
 3691 0f34 1397      		sbiw r26,3
1062:stk500boot.c  **** 								size	-=	2;
 3692               		.loc 1 1062 0 discriminator 1
 3693 0f36 22E0      		ldi r18,2
 3694 0f38 220E      		add r2,r18
 3695 0f3a 311C      		adc r3,__zero_reg__
 3696 0f3c 411C      		adc r4,__zero_reg__
 3697 0f3e 511C      		adc r5,__zero_reg__
 3698               	.LVL398:
1063:stk500boot.c  **** 							}while (size);
 3699               		.loc 1 1063 0 discriminator 1
 3700 0f40 0297      		sbiw r24,2
 3701               	.LVL399:
 3702 0f42 1296      		adiw r26,2
1064:stk500boot.c  **** 						}
 3703               		.loc 1 1064 0 discriminator 1
 3704 0f44 0097      		sbiw r24,0
 3705 0f46 01F4      		brne .L190
 3706 0f48 00C0      		rjmp .L191
 3707               	.LVL400:
 3708               	.L189:
 3709 0f4a FE01      		movw r30,r28
 3710 0f4c 3196      		adiw r30,1
 3711 0f4e 9F01      		movw r18,r30
 3712 0f50 280F      		add r18,r24
 3713 0f52 391F      		adc r19,r25
 3714               	.LBE247:
1048:stk500boot.c  **** 						{
 3715               		.loc 1 1048 0 discriminator 1
 3716 0f54 B201      		movw r22,r4
 3717 0f56 A101      		movw r20,r2
 3718               	.LVL401:
 3719               	.L192:
1070:stk500boot.c  **** 								EEARH	=	((address >> 8));
 3720               		.loc 1 1070 0 discriminator 1
 3721 0f58 41BD      		out 0x21,r20
1071:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 3722               		.loc 1 1071 0 discriminator 1
 3723 0f5a 852E      		mov r8,r21
 3724 0f5c 962E      		mov r9,r22
 3725 0f5e A72E      		mov r10,r23
 3726 0f60 BB24      		clr r11
 3727 0f62 82BC      		out 0x22,r8
1072:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 3728               		.loc 1 1072 0 discriminator 1
 3729 0f64 4F5F      		subi r20,-1
 3730 0f66 5F4F      		sbci r21,-1
 3731 0f68 6F4F      		sbci r22,-1
 3732 0f6a 7F4F      		sbci r23,-1
 3733               	.LVL402:
1073:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 3734               		.loc 1 1073 0 discriminator 1
 3735 0f6c F89A      		sbi 0x1f,0
 3736               	.LVL403:
1074:stk500boot.c  **** 								size--;
 3737               		.loc 1 1074 0 discriminator 1
 3738 0f6e A0B5      		in r26,0x20
 3739 0f70 A283      		std Z+2,r26
 3740 0f72 3196      		adiw r30,1
 3741               	.LVL404:
1076:stk500boot.c  **** 						}
 3742               		.loc 1 1076 0 discriminator 1
 3743 0f74 E217      		cp r30,r18
 3744 0f76 F307      		cpc r31,r19
 3745 0f78 01F4      		brne .L192
 3746 0f7a AC01      		movw r20,r24
 3747               	.LVL405:
 3748 0f7c 4150      		subi r20,1
 3749 0f7e 5109      		sbc r21,__zero_reg__
 3750 0f80 60E0      		ldi r22,0
 3751 0f82 70E0      		ldi r23,0
 3752 0f84 4F5F      		subi r20,-1
 3753 0f86 5F4F      		sbci r21,-1
 3754 0f88 6F4F      		sbci r22,-1
 3755 0f8a 7F4F      		sbci r23,-1
 3756 0f8c 240E      		add r2,r20
 3757 0f8e 351E      		adc r3,r21
 3758 0f90 461E      		adc r4,r22
 3759 0f92 571E      		adc r5,r23
 3760 0f94 E3E0      		ldi r30,lo8(3)
 3761 0f96 F0E0      		ldi r31,0
 3762               	.LVL406:
 3763 0f98 EC0F      		add r30,r28
 3764 0f9a FD1F      		adc r31,r29
 3765 0f9c E80F      		add r30,r24
 3766 0f9e F91F      		adc r31,r25
 3767               	.L191:
 3768               	.LVL407:
1078:stk500boot.c  **** 					}
 3769               		.loc 1 1078 0
 3770 0fa0 1082      		st Z,__zero_reg__
 3771               	.LBE246:
1080:stk500boot.c  **** 
 3772               		.loc 1 1080 0
 3773 0fa2 00C0      		rjmp .L173
 3774               	.LVL408:
 3775               	.L153:
1084:stk500boot.c  **** 					break;
 3776               		.loc 1 1084 0
 3777 0fa4 80EC      		ldi r24,lo8(-64)
 3778 0fa6 8A83      		std Y+2,r24
 3779               	.L282:
1083:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3780               		.loc 1 1083 0
 3781 0fa8 02E0      		ldi r16,lo8(2)
 3782 0faa 10E0      		ldi r17,0
 3783               	.LVL409:
 3784               	.L173:
1091:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 3785               		.loc 1 1091 0
 3786 0fac 8BE1      		ldi r24,lo8(27)
 3787 0fae 0E94 0000 		call sendchar
 3788               	.LVL410:
1094:stk500boot.c  **** 			checksum	^=	seqNum;
 3789               		.loc 1 1094 0
 3790 0fb2 862D      		mov r24,r6
 3791 0fb4 0E94 0000 		call sendchar
 3792               	.LVL411:
1098:stk500boot.c  **** 			checksum	^=	c;
 3793               		.loc 1 1098 0
 3794 0fb8 812F      		mov r24,r17
 3795 0fba 0E94 0000 		call sendchar
 3796               	.LVL412:
1102:stk500boot.c  **** 			checksum ^= c;
 3797               		.loc 1 1102 0
 3798 0fbe 802F      		mov r24,r16
 3799 0fc0 0E94 0000 		call sendchar
 3800               	.LVL413:
 3801 0fc4 85E1      		ldi r24,lo8(21)
 3802 0fc6 B62C      		mov r11,r6
 3803 0fc8 B826      		eor r11,r24
 3804 0fca B026      		eor r11,r16
 3805               	.LVL414:
1105:stk500boot.c  **** 			checksum ^= TOKEN;
 3806               		.loc 1 1105 0
 3807 0fcc 8EE0      		ldi r24,lo8(14)
 3808 0fce 0E94 0000 		call sendchar
 3809               	.LVL415:
1106:stk500boot.c  **** 
 3810               		.loc 1 1106 0
 3811 0fd2 B126      		eor r11,r17
 3812               	.LVL416:
 3813 0fd4 AE01      		movw r20,r28
 3814 0fd6 4F5F      		subi r20,-1
 3815 0fd8 5F4F      		sbci r21,-1
 3816 0fda 6A01      		movw r12,r20
 3817 0fdc 040F      		add r16,r20
 3818 0fde 151F      		adc r17,r21
 3819               	.LVL417:
 3820               	.L193:
1109:stk500boot.c  **** 			{
 3821               		.loc 1 1109 0
 3822 0fe0 C016      		cp r12,r16
 3823 0fe2 D106      		cpc r13,r17
 3824 0fe4 01F0      		breq .L301
 3825               	.LVL418:
1111:stk500boot.c  **** 				sendchar(c);
 3826               		.loc 1 1111 0
 3827 0fe6 D601      		movw r26,r12
 3828 0fe8 AD90      		ld r10,X+
 3829               	.LVL419:
 3830 0fea 6D01      		movw r12,r26
 3831               	.LVL420:
1112:stk500boot.c  **** 				checksum ^=c;
 3832               		.loc 1 1112 0
 3833 0fec 8A2D      		mov r24,r10
 3834 0fee 0E94 0000 		call sendchar
 3835               	.LVL421:
1113:stk500boot.c  **** 				msgLength--;
 3836               		.loc 1 1113 0
 3837 0ff2 BA24      		eor r11,r10
 3838               	.LVL422:
 3839 0ff4 00C0      		rjmp .L193
 3840               	.LVL423:
 3841               	.L301:
1116:stk500boot.c  **** 			seqNum++;
 3842               		.loc 1 1116 0
 3843 0ff6 8B2D      		mov r24,r11
 3844 0ff8 0E94 0000 		call sendchar
 3845               	.LVL424:
1117:stk500boot.c  **** 	
 3846               		.loc 1 1117 0
 3847 0ffc 6394      		inc r6
 3848               	.LVL425:
1121:stk500boot.c  **** 		#endif
 3849               		.loc 1 1121 0
 3850 0ffe 84B3      		in r24,0x14
 3851 1000 B4E0      		ldi r27,lo8(4)
 3852 1002 8B27      		eor r24,r27
 3853 1004 84BB      		out 0x14,r24
 3854               	.LVL426:
 3855 1006 00E0      		ldi r16,0
 3856 1008 10E0      		ldi r17,0
 669:stk500boot.c  **** 		{
 3857               		.loc 1 669 0
 3858 100a 7720      		tst r7
 3859 100c 01F4      		brne .+2
 3860 100e 00C0      		rjmp .L195
 3861               	.LVL427:
 3862               	.L52:
1156:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3863               		.loc 1 1156 0
 3864 1010 9A98      		cbi 0x13,2
1157:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 3865               		.loc 1 1157 0
 3866 1012 A298      		cbi 0x14,2
1159:stk500boot.c  **** #endif
 3867               		.loc 1 1159 0
 3868 1014 84E6      		ldi r24,lo8(100)
 3869 1016 90E0      		ldi r25,0
 3870 1018 0E94 0000 		call delay_ms
 3871               	.LVL428:
1163:stk500boot.c  **** 
 3872               		.loc 1 1163 0
 3873               	/* #APP */
 3874               	 ;  1163 "stk500boot.c" 1
 3875 101c 0000      		nop
 3876               	 ;  0 "" 2
1169:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3877               		.loc 1 1169 0
 3878               	/* #NOAPP */
 3879 101e 8091 C000 		lds r24,192
 3880 1022 8D7F      		andi r24,lo8(-3)
 3881 1024 8093 C000 		sts 192,r24
1170:stk500boot.c  **** 
 3882               		.loc 1 1170 0
 3883 1028 81E1      		ldi r24,lo8(17)
 3884               	/* #APP */
 3885               	 ;  1170 "stk500boot.c" 1
 3886 102a 8093 5700 		sts 87, r24
 3887 102e E895      		spm
 3888               		
 3889               	 ;  0 "" 2
1173:stk500boot.c  **** 			"clr	r30		\n\t"
 3890               		.loc 1 1173 0
 3891               	 ;  1173 "stk500boot.c" 1
 3892 1030 EE27      		clr	r30		
 3893 1032 FF27      		clr	r31		
 3894 1034 0994      		ijmp	
 3895               		
 3896               	 ;  0 "" 2
 3897               	/* #NOAPP */
 3898               	.L197:
 3899 1036 00C0      		rjmp .L197
 3900               	.LVL429:
 3901               	.L208:
 716:stk500boot.c  **** 						}
 3902               		.loc 1 716 0
 3903 1038 8BE1      		ldi r24,lo8(27)
 3904 103a B82E      		mov r11,r24
 3905               	.LVL430:
 715:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 3906               		.loc 1 715 0
 3907 103c 81E0      		ldi r24,lo8(1)
 3908 103e 00C0      		rjmp .L152
 3909               	.LVL431:
 3910               	.L209:
 706:stk500boot.c  **** 				}
 3911               		.loc 1 706 0
 3912 1040 E12C      		mov r14,__zero_reg__
 3913 1042 F12C      		mov r15,__zero_reg__
 3914 1044 00C0      		rjmp .L220
 3915               	.LVL432:
 3916               	.L210:
 3917 1046 CA5D      		subi r28,lo8(-294)
 3918 1048 DE4F      		sbci r29,hi8(-294)
 3919 104a 3983      		std Y+1,r19
 3920 104c 2883      		st Y,r18
 3921 104e C652      		subi r28,lo8(294)
 3922 1050 D140      		sbci r29,hi8(294)
 769:stk500boot.c  **** 						}
 3923               		.loc 1 769 0
 3924 1052 86E0      		ldi r24,lo8(6)
 3925               	.LVL433:
 3926 1054 00C0      		rjmp .L152
 3927               	.LVL434:
 3928               	.L299:
 710:stk500boot.c  **** 				{
 3929               		.loc 1 710 0
 3930 1056 8130      		cpi r24,lo8(1)
 3931 1058 01F4      		brne .+2
 3932 105a 00C0      		rjmp .L145
 3933 105c 00F0      		brlo .+2
 3934 105e 00C0      		rjmp .L146
 3935               	.LVL435:
 3936               	.L220:
 3937 1060 80E0      		ldi r24,0
 3938               	.LVL436:
 3939 1062 00C0      		rjmp .L152
 3940               		.cfi_endproc
 3941               	.LFE17:
 3943               		.section	.rodata
 3946               	CSWTCH.71:
 3947 0000 0F        		.byte	15
 3948 0001 02        		.byte	2
 3949 0002 0A        		.byte	10
 3950               	.global	gTextMsg_END
 3951               		.section	.progmem.data,"a",@progbits
 3954               	gTextMsg_END:
 3955 0000 2A00      		.string	"*"
 3956               	.global	gTextMsg_HELP_MSG_Y
 3959               	gTextMsg_HELP_MSG_Y:
 3960 0002 593D 506F 		.string	"Y=Port blink"
 3960      7274 2062 
 3960      6C69 6E6B 
 3960      00
 3961               	.global	gTextMsg_HELP_MSG_V
 3964               	gTextMsg_HELP_MSG_V:
 3965 000f 563D 7368 		.string	"V=show interrupt Vectors"
 3965      6F77 2069 
 3965      6E74 6572 
 3965      7275 7074 
 3965      2056 6563 
 3966               	.global	gTextMsg_HELP_MSG_R
 3969               	gTextMsg_HELP_MSG_R:
 3970 0028 523D 4475 		.string	"R=Dump RAM"
 3970      6D70 2052 
 3970      414D 00
 3971               	.global	gTextMsg_HELP_MSG_Q
 3974               	gTextMsg_HELP_MSG_Q:
 3975 0033 513D 5175 		.string	"Q=Quit"
 3975      6974 00
 3976               	.global	gTextMsg_HELP_MSG_L
 3979               	gTextMsg_HELP_MSG_L:
 3980 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 3980      7374 2049 
 3980      2F4F 2050 
 3980      6F72 7473 
 3980      00
 3981               	.global	gTextMsg_HELP_MSG_H
 3984               	gTextMsg_HELP_MSG_H:
 3985 004b 483D 4865 		.string	"H=Help"
 3985      6C70 00
 3986               	.global	gTextMsg_HELP_MSG_F
 3989               	gTextMsg_HELP_MSG_F:
 3990 0052 463D 4475 		.string	"F=Dump FLASH"
 3990      6D70 2046 
 3990      4C41 5348 
 3990      00
 3991               	.global	gTextMsg_HELP_MSG_E
 3994               	gTextMsg_HELP_MSG_E:
 3995 005f 453D 4475 		.string	"E=Dump EEPROM"
 3995      6D70 2045 
 3995      4550 524F 
 3995      4D00 
 3996               	.global	gTextMsg_HELP_MSG_B
 3999               	gTextMsg_HELP_MSG_B:
 4000 006d 423D 426C 		.string	"B=Blink LED"
 4000      696E 6B20 
 4000      4C45 4400 
 4001               	.global	gTextMsg_HELP_MSG_AT
 4004               	gTextMsg_HELP_MSG_AT:
 4005 0079 403D 4545 		.string	"@=EEPROM test"
 4005      5052 4F4D 
 4005      2074 6573 
 4005      7400 
 4006               	.global	gTextMsg_HELP_MSG_QM
 4009               	gTextMsg_HELP_MSG_QM:
 4010 0087 3F3D 4350 		.string	"?=CPU stats"
 4010      5520 7374 
 4010      6174 7300 
 4011               	.global	gTextMsg_HELP_MSG_0
 4014               	gTextMsg_HELP_MSG_0:
 4015 0093 303D 5A65 		.string	"0=Zero addr"
 4015      726F 2061 
 4015      6464 7200 
 4016               	.global	gTextMsg_PORT
 4019               	gTextMsg_PORT:
 4020 009f 504F 5254 		.string	"PORT"
 4020      00
 4021               	.global	gTextMsg_EEPROMerrorCnt
 4024               	gTextMsg_EEPROMerrorCnt:
 4025 00a4 4545 2065 		.string	"EE err cnt="
 4025      7272 2063 
 4025      6E74 3D00 
 4026               	.global	gTextMsg_ReadingEEprom
 4029               	gTextMsg_ReadingEEprom:
 4030 00b0 5265 6164 		.string	"Reading EE"
 4030      696E 6720 
 4030      4545 00
 4031               	.global	gTextMsg_WriteToEEprom
 4034               	gTextMsg_WriteToEEprom:
 4035 00bb 5772 6974 		.string	"Writting EE"
 4035      7469 6E67 
 4035      2045 4500 
 4036               	.global	gTextMsg_SPACE
 4039               	gTextMsg_SPACE:
 4040 00c7 2000      		.string	" "
 4041               	.global	gTextMsg_MustBeLetter
 4044               	gTextMsg_MustBeLetter:
 4045 00c9 4D75 7374 		.string	"Must be a letter"
 4045      2062 6520 
 4045      6120 6C65 
 4045      7474 6572 
 4045      00
 4046               	.global	gTextMsg_PortNotSupported
 4049               	gTextMsg_PortNotSupported:
 4050 00da 506F 7274 		.string	"Port not supported"
 4050      206E 6F74 
 4050      2073 7570 
 4050      706F 7274 
 4050      6564 00
 4051               	.global	gTextMsg_WHAT_PORT
 4054               	gTextMsg_WHAT_PORT:
 4055 00ed 5768 6174 		.string	"What port:"
 4055      2070 6F72 
 4055      743A 00
 4056               	.global	gTextMsg_jmp
 4059               	gTextMsg_jmp:
 4060 00f8 6A6D 7020 		.string	"jmp "
 4060      00
 4061               	.global	gTextMsg_rjmp
 4064               	gTextMsg_rjmp:
 4065 00fd 726A 6D70 		.string	"rjmp  "
 4065      2020 00
 4066               	.global	gTextMsg_noVector
 4069               	gTextMsg_noVector:
 4070 0104 6E6F 2076 		.string	"no vector"
 4070      6563 746F 
 4070      7200 
 4071               	.global	gTextMsg_VECTOR_HEADER
 4074               	gTextMsg_VECTOR_HEADER:
 4075 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4075      2041 4444 
 4075      5220 2020 
 4075      6F70 2063 
 4075      6F64 6520 
 4076               	.global	gTextMsg_GCC_VERSION_STR
 4079               	gTextMsg_GCC_VERSION_STR:
 4080 0143 352E 342E 		.string	"5.4.0"
 4080      3000 
 4081               	.global	gTextMsg_AVR_LIBC_VER_STR
 4084               	gTextMsg_AVR_LIBC_VER_STR:
 4085 0149 322E 302E 		.string	"2.0.0"
 4085      3000 
 4086               	.global	gTextMsg_GCC_DATE_STR
 4089               	gTextMsg_GCC_DATE_STR:
 4090 014f 5365 7020 		.string	"Sep 16 2019"
 4090      3136 2032 
 4090      3031 3900 
 4091               	.global	gTextMsg_FUSE_BYTE_LOCK
 4094               	gTextMsg_FUSE_BYTE_LOCK:
 4095 015b 4C6F 636B 		.string	"Lock fuse   = "
 4095      2066 7573 
 4095      6520 2020 
 4095      3D20 00
 4096               	.global	gTextMsg_FUSE_BYTE_EXT
 4099               	gTextMsg_FUSE_BYTE_EXT:
 4100 016a 4578 7420 		.string	"Ext fuse    = "
 4100      6675 7365 
 4100      2020 2020 
 4100      3D20 00
 4101               	.global	gTextMsg_FUSE_BYTE_HIGH
 4104               	gTextMsg_FUSE_BYTE_HIGH:
 4105 0179 4869 6768 		.string	"High fuse   = "
 4105      2066 7573 
 4105      6520 2020 
 4105      3D20 00
 4106               	.global	gTextMsg_FUSE_BYTE_LOW
 4109               	gTextMsg_FUSE_BYTE_LOW:
 4110 0188 4C6F 7720 		.string	"Low fuse    = "
 4110      6675 7365 
 4110      2020 2020 
 4110      3D20 00
 4111               	.global	gTextMsg_CPU_SIGNATURE
 4114               	gTextMsg_CPU_SIGNATURE:
 4115 0197 4350 5520 		.string	"CPU ID      = "
 4115      4944 2020 
 4115      2020 2020 
 4115      3D20 00
 4116               	.global	gTextMsg_GCC_VERSION
 4119               	gTextMsg_GCC_VERSION:
 4120 01a6 4743 4320 		.string	"GCC Version = "
 4120      5665 7273 
 4120      696F 6E20 
 4120      3D20 00
 4121               	.global	gTextMsg_AVR_LIBC
 4124               	gTextMsg_AVR_LIBC:
 4125 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4125      4C69 6243 
 4125      2056 6572 
 4125      3D20 00
 4126               	.global	gTextMsg_AVR_ARCH
 4129               	gTextMsg_AVR_ARCH:
 4130 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4130      525F 4152 
 4130      4348 5F5F 
 4130      3D20 00
 4131               	.global	gTextMsg_CPU_Type
 4134               	gTextMsg_CPU_Type:
 4135 01d3 4350 5520 		.string	"CPU Type    = "
 4135      5479 7065 
 4135      2020 2020 
 4135      3D20 00
 4136               	.global	gTextMsg_COMPILED_ON
 4139               	gTextMsg_COMPILED_ON:
 4140 01e2 436F 6D70 		.string	"Compiled on = "
 4140      696C 6564 
 4140      206F 6E20 
 4140      3D20 00
 4141               	.global	gTextMsg_HUH
 4144               	gTextMsg_HUH:
 4145 01f1 4875 683F 		.string	"Huh?"
 4145      00
 4146               	.global	gTextMsg_Prompt
 4149               	gTextMsg_Prompt:
 4150 01f6 426F 6F74 		.string	"Bootloader>"
 4150      6C6F 6164 
 4150      6572 3E00 
 4151               	.global	gTextMsg_Explorer
 4154               	gTextMsg_Explorer:
 4155 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4155      696E 6F20 
 4155      6578 706C 
 4155      6F72 6572 
 4155      2073 746B 
 4156               	.global	gTextMsg_CPU_Name
 4159               	gTextMsg_CPU_Name:
 4160 0223 4154 6D65 		.string	"ATmega2560"
 4160      6761 3235 
 4160      3630 00
 4161               		.comm	gEepromIndex,4,1
 4162               		.comm	gFlashIndex,4,1
 4163               		.comm	gRamIndex,4,1
 4164               	.global	app_start
 4165               		.section .bss
 4168               	app_start:
 4169 0000 0000      		.zero	2
 4170               		.text
 4171               	.Letext0:
 4172               		.file 3 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\st
 4173               		.file 4 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\av
DEFINED SYMBOLS
                            *ABS*:00000000 stk500boot.c
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:2      *ABS*:0000003e __SP_H__
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3      *ABS*:0000003d __SP_L__
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4      *ABS*:0000003f __SREG__
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:7      *ABS*:00000001 __zero_reg__
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:12     .text:00000000 sendchar
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:41     .text.unlikely:00000000 recchar
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:64     .init9:00000000 __jumpMain
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:75     *ABS*:000021ff __stack
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:784    .text.startup:00000000 main
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:114    .text:00000018 delay_ms
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:160    .text:00000036 PrintFromPROGMEM
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:223    .text:0000005e PrintNewLine
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:244    .text.unlikely:0000000e PrintAvailablePort
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4019   .progmem.data:0000009f gTextMsg_PORT
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:282    .text:0000006a PrintFromPROGMEMln
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:302    .text:00000072 PrintString
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:345    .text:0000008a PrintHexByte
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:405    .text.unlikely:00000028 DumpHex.constprop.0
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:687    .text:000000b8 PrintDecInt
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4168   .bss:00000000 app_start
                            *COM*:00000004 gRamIndex
                            *COM*:00000004 gFlashIndex
                            *COM*:00000004 gEepromIndex
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4154   .progmem.data:00000202 gTextMsg_Explorer
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4149   .progmem.data:000001f6 gTextMsg_Prompt
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4009   .progmem.data:00000087 gTextMsg_HELP_MSG_QM
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4139   .progmem.data:000001e2 gTextMsg_COMPILED_ON
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4089   .progmem.data:0000014f gTextMsg_GCC_DATE_STR
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4134   .progmem.data:000001d3 gTextMsg_CPU_Type
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4159   .progmem.data:00000223 gTextMsg_CPU_Name
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4129   .progmem.data:000001c4 gTextMsg_AVR_ARCH
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4119   .progmem.data:000001a6 gTextMsg_GCC_VERSION
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4079   .progmem.data:00000143 gTextMsg_GCC_VERSION_STR
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4124   .progmem.data:000001b5 gTextMsg_AVR_LIBC
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4084   .progmem.data:00000149 gTextMsg_AVR_LIBC_VER_STR
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4114   .progmem.data:00000197 gTextMsg_CPU_SIGNATURE
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4109   .progmem.data:00000188 gTextMsg_FUSE_BYTE_LOW
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4104   .progmem.data:00000179 gTextMsg_FUSE_BYTE_HIGH
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4099   .progmem.data:0000016a gTextMsg_FUSE_BYTE_EXT
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4094   .progmem.data:0000015b gTextMsg_FUSE_BYTE_LOCK
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3979   .progmem.data:0000003a gTextMsg_HELP_MSG_L
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3969   .progmem.data:00000028 gTextMsg_HELP_MSG_R
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4014   .progmem.data:00000093 gTextMsg_HELP_MSG_0
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4004   .progmem.data:00000079 gTextMsg_HELP_MSG_AT
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4034   .progmem.data:000000bb gTextMsg_WriteToEEprom
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4039   .progmem.data:000000c7 gTextMsg_SPACE
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4029   .progmem.data:000000b0 gTextMsg_ReadingEEprom
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4024   .progmem.data:000000a4 gTextMsg_EEPROMerrorCnt
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3999   .progmem.data:0000006d gTextMsg_HELP_MSG_B
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3994   .progmem.data:0000005f gTextMsg_HELP_MSG_E
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3989   .progmem.data:00000052 gTextMsg_HELP_MSG_F
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3984   .progmem.data:0000004b gTextMsg_HELP_MSG_H
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3974   .progmem.data:00000033 gTextMsg_HELP_MSG_Q
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3964   .progmem.data:0000000f gTextMsg_HELP_MSG_V
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3959   .progmem.data:00000002 gTextMsg_HELP_MSG_Y
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4074   .progmem.data:0000010e gTextMsg_VECTOR_HEADER
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4069   .progmem.data:00000104 gTextMsg_noVector
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4064   .progmem.data:000000fd gTextMsg_rjmp
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4059   .progmem.data:000000f8 gTextMsg_jmp
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4054   .progmem.data:000000ed gTextMsg_WHAT_PORT
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4049   .progmem.data:000000da gTextMsg_PortNotSupported
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4044   .progmem.data:000000c9 gTextMsg_MustBeLetter
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:4144   .progmem.data:000001f1 gTextMsg_HUH
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3946   .rodata:00000000 CSWTCH.71
C:\Users\supun\AppData\Local\Temp\ccIdk25U.s:3954   .progmem.data:00000000 gTextMsg_END

UNDEFINED SYMBOLS
eeprom_read_byte
__divmodhi4
__udivmodsi4
eeprom_write_byte
__bswapsi2
__do_copy_data
__do_clear_bss
