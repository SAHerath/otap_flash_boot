   1               		.file	"bootSAH_2.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "bootSAH_2.c"
   1:bootSAH_2.c   **** /*****************************************************************************
   2:bootSAH_2.c   **** Title:     STK500v2 compatible bootloader
   3:bootSAH_2.c   ****            Modified for Wiring board ATMega128-16MHz
   4:bootSAH_2.c   **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:bootSAH_2.c   **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:bootSAH_2.c   **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:bootSAH_2.c   **** License:   GNU General Public License
   8:bootSAH_2.c   **** 
   9:bootSAH_2.c   **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:bootSAH_2.c   **** Date:      17 October 2007
  11:bootSAH_2.c   **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:bootSAH_2.c   **** Compiler:  WINAVR20060421
  13:bootSAH_2.c   **** Description: add timeout feature like previous Wiring bootloader
  14:bootSAH_2.c   **** 
  15:bootSAH_2.c   **** Modified:  Supun Herath <supun@utequip.com> 
  16:bootSAH_2.c   **** Date:      20 Aug 2019
  17:bootSAH_2.c   **** Update:
  18:bootSAH_2.c   **** Compiler:  avr-gcc (AVR_8_bit_GNU_Toolchain_3.6.1_1750) 5.4.0
  19:bootSAH_2.c   **** Description: add capability to write internal flash through external flash chip using spi protocol
  20:bootSAH_2.c   **** 
  21:bootSAH_2.c   **** DESCRIPTION:
  22:bootSAH_2.c   ****     This program allows an AVR with bootloader capabilities to
  23:bootSAH_2.c   ****     read/write its own Flash/EEprom. To enter Programming mode
  24:bootSAH_2.c   ****     an input pin is checked. If this pin is pulled low, programming mode
  25:bootSAH_2.c   ****     is entered. If not, normal execution is done from $0000
  26:bootSAH_2.c   ****     "reset" vector in Application area.
  27:bootSAH_2.c   ****     Size fits into a 1024 word bootloader section
  28:bootSAH_2.c   **** 	when compiled with avr-gcc 4.1
  29:bootSAH_2.c   **** 	(direct replace on Wiring Board without fuse setting changed)
  30:bootSAH_2.c   **** 
  31:bootSAH_2.c   **** USAGE:
  32:bootSAH_2.c   ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  33:bootSAH_2.c   ****     - Set baud rate below (AVRISP only works with 115200 bps)
  34:bootSAH_2.c   ****     - compile/link the bootloader with the supplied Makefile
  35:bootSAH_2.c   ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  36:bootSAH_2.c   ****       for boot-size 1024 words:  program BOOTSZ01
  37:bootSAH_2.c   ****     - enable the BOOT Reset Vector (program BOOTRST)
  38:bootSAH_2.c   ****     - Upload the hex file to the AVR using any ISP programmer
  39:bootSAH_2.c   ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  40:bootSAH_2.c   ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  41:bootSAH_2.c   ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  42:bootSAH_2.c   ****     - AVRISP will detect the bootloader
  43:bootSAH_2.c   ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  44:bootSAH_2.c   **** 
  45:bootSAH_2.c   **** Note:
  46:bootSAH_2.c   ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  47:bootSAH_2.c   ****     is not implemented, due to AVRStudio limitations.
  48:bootSAH_2.c   ****     Flash is always erased before programming.
  49:bootSAH_2.c   **** 
  50:bootSAH_2.c   **** 	AVRdude:
  51:bootSAH_2.c   **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  52:bootSAH_2.c   **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  53:bootSAH_2.c   **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  54:bootSAH_2.c   **** 
  55:bootSAH_2.c   **** NOTES:
  56:bootSAH_2.c   ****     Based on Atmel Application Note AVR109 - Self-programming
  57:bootSAH_2.c   ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  58:bootSAH_2.c   **** 
  59:bootSAH_2.c   **** LICENSE:
  60:bootSAH_2.c   ****     Copyright (C) 2006 Peter Fleury
  61:bootSAH_2.c   **** 
  62:bootSAH_2.c   ****     This program is free software; you can redistribute it and/or modify
  63:bootSAH_2.c   ****     it under the terms of the GNU General Public License as published by
  64:bootSAH_2.c   ****     the Free Software Foundation; either version 2 of the License, or
  65:bootSAH_2.c   ****     any later version.
  66:bootSAH_2.c   **** 
  67:bootSAH_2.c   ****     This program is distributed in the hope that it will be useful,
  68:bootSAH_2.c   ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  69:bootSAH_2.c   ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  70:bootSAH_2.c   ****     GNU General Public License for more details.
  71:bootSAH_2.c   **** 
  72:bootSAH_2.c   **** *****************************************************************************/
  73:bootSAH_2.c   **** 
  74:bootSAH_2.c   **** //************************************************************************
  75:bootSAH_2.c   **** //*	Edit History
  76:bootSAH_2.c   **** //************************************************************************
  77:bootSAH_2.c   **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  78:bootSAH_2.c   **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  79:bootSAH_2.c   **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  80:bootSAH_2.c   **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  81:bootSAH_2.c   **** //*	Jul  8,	2010	<MLS> Adding monitor code
  82:bootSAH_2.c   **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  83:bootSAH_2.c   **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  84:bootSAH_2.c   **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  85:bootSAH_2.c   **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  86:bootSAH_2.c   **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  87:bootSAH_2.c   **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  88:bootSAH_2.c   **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  89:bootSAH_2.c   **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  90:bootSAH_2.c   **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  91:bootSAH_2.c   **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  92:bootSAH_2.c   **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  93:bootSAH_2.c   **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  94:bootSAH_2.c   **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  95:bootSAH_2.c   **** //************************************************************************
  96:bootSAH_2.c   **** 
  97:bootSAH_2.c   **** //************************************************************************
  98:bootSAH_2.c   **** //*	these are used to test issues
  99:bootSAH_2.c   **** //*	http://code.google.com/p/arduino/issues/detail?id=505
 100:bootSAH_2.c   **** //*	Reported by mark.stubbs, Mar 14, 2011
 101:bootSAH_2.c   **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
 102:bootSAH_2.c   **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
 103:bootSAH_2.c   **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
 104:bootSAH_2.c   **** #define	_FIX_ISSUE_505_
 105:bootSAH_2.c   **** //************************************************************************
 106:bootSAH_2.c   **** //*	Issue 181: added watch dog timmer support
 107:bootSAH_2.c   **** #define	_FIX_ISSUE_181_
 108:bootSAH_2.c   **** 
 109:bootSAH_2.c   **** #include	<inttypes.h>
 110:bootSAH_2.c   **** #include	<avr/io.h>
 111:bootSAH_2.c   **** #include	<avr/interrupt.h>
 112:bootSAH_2.c   **** #include	<avr/boot.h>
 113:bootSAH_2.c   **** #include	<avr/pgmspace.h>
 114:bootSAH_2.c   **** #include	<util/delay.h>
 115:bootSAH_2.c   **** #include	<avr/eeprom.h>
 116:bootSAH_2.c   **** #include	<avr/common.h>
 117:bootSAH_2.c   **** #include	<stdlib.h>
 118:bootSAH_2.c   **** #include	"command.h"
 119:bootSAH_2.c   **** 
 120:bootSAH_2.c   **** /*
 121:bootSAH_2.c   **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 122:bootSAH_2.c   **** 	| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 123:bootSAH_2.c   **** 	#undef		ENABLE_MONITOR
 124:bootSAH_2.c   **** 	#define		ENABLE_MONITOR
 125:bootSAH_2.c   **** 	static void	RunMonitor(void);
 126:bootSAH_2.c   **** #endif	
 127:bootSAH_2.c   **** */
 128:bootSAH_2.c   **** 
 129:bootSAH_2.c   **** #ifndef EEWE
 130:bootSAH_2.c   **** 	#define EEWE    1
 131:bootSAH_2.c   **** #endif
 132:bootSAH_2.c   **** #ifndef EEMWE
 133:bootSAH_2.c   **** 	#define EEMWE   2
 134:bootSAH_2.c   **** #endif
 135:bootSAH_2.c   **** 
 136:bootSAH_2.c   **** #define	_DEBUG_SERIAL_
 137:bootSAH_2.c   **** //#define	_DEBUG_WITH_LEDS_
 138:bootSAH_2.c   **** 
 139:bootSAH_2.c   **** 
 140:bootSAH_2.c   **** /*
 141:bootSAH_2.c   ****  * Uncomment the following lines to save code space
 142:bootSAH_2.c   ****  */
 143:bootSAH_2.c   **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 144:bootSAH_2.c   **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 145:bootSAH_2.c   **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 146:bootSAH_2.c   **** //
 147:bootSAH_2.c   **** 
 148:bootSAH_2.c   **** 
 149:bootSAH_2.c   **** 
 150:bootSAH_2.c   **** //************************************************************************
 151:bootSAH_2.c   **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 152:bootSAH_2.c   **** //*	indicates that bootloader is active
 153:bootSAH_2.c   **** //*	PG2 -> LED on Wiring board
 154:bootSAH_2.c   **** //************************************************************************
 155:bootSAH_2.c   **** #define		BLINK_LED_WHILE_WAITING
 156:bootSAH_2.c   **** 
 157:bootSAH_2.c   **** #ifdef __AVR_ATmega2560__
 158:bootSAH_2.c   **** 	#define PROGLED_PORT	PORTB
 159:bootSAH_2.c   **** 	#define PROGLED_DDR		DDRB
 160:bootSAH_2.c   **** 	#define PROGLED_PIN		PINB7
 161:bootSAH_2.c   **** #endif
 162:bootSAH_2.c   **** 
 163:bootSAH_2.c   **** 
 164:bootSAH_2.c   **** 
 165:bootSAH_2.c   **** /*
 166:bootSAH_2.c   ****  * define CPU frequency in Mhz here if not defined in Makefile
 167:bootSAH_2.c   ****  */
 168:bootSAH_2.c   **** #ifndef F_CPU
 169:bootSAH_2.c   **** 	#define F_CPU 16000000UL
 170:bootSAH_2.c   **** #endif
 171:bootSAH_2.c   **** 
 172:bootSAH_2.c   **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 173:bootSAH_2.c   **** /*
 174:bootSAH_2.c   ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 175:bootSAH_2.c   ****  */
 176:bootSAH_2.c   **** 
 177:bootSAH_2.c   **** #ifndef BAUDRATE
 178:bootSAH_2.c   **** 	#define BAUDRATE 115200
 179:bootSAH_2.c   **** #endif
 180:bootSAH_2.c   **** 
 181:bootSAH_2.c   **** /*
 182:bootSAH_2.c   ****  *  Enable (1) or disable (0) USART double speed operation
 183:bootSAH_2.c   ****  */
 184:bootSAH_2.c   **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 185:bootSAH_2.c   **** 	#if defined (__AVR_ATmega32__)
 186:bootSAH_2.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 187:bootSAH_2.c   **** 	#else
 188:bootSAH_2.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 189:bootSAH_2.c   **** 	#endif
 190:bootSAH_2.c   **** #endif
 191:bootSAH_2.c   **** 
 192:bootSAH_2.c   **** /*
 193:bootSAH_2.c   ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 194:bootSAH_2.c   ****  */
 195:bootSAH_2.c   **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 196:bootSAH_2.c   **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 197:bootSAH_2.c   **** #define CONFIG_PARAM_HW_VER				0x0F
 198:bootSAH_2.c   **** #define CONFIG_PARAM_SW_MAJOR			2
 199:bootSAH_2.c   **** #define CONFIG_PARAM_SW_MINOR			0x0A
 200:bootSAH_2.c   **** 
 201:bootSAH_2.c   **** /*
 202:bootSAH_2.c   ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 203:bootSAH_2.c   ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 204:bootSAH_2.c   ****  */
 205:bootSAH_2.c   **** //#define BOOTSIZE 1024
 206:bootSAH_2.c   **** #if FLASHEND > 0x0F000
 207:bootSAH_2.c   **** 	#define BOOTSIZE 8192
 208:bootSAH_2.c   **** #else
 209:bootSAH_2.c   **** 	#define BOOTSIZE 2048
 210:bootSAH_2.c   **** #endif
 211:bootSAH_2.c   **** 
 212:bootSAH_2.c   **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 213:bootSAH_2.c   **** 
 214:bootSAH_2.c   **** /*
 215:bootSAH_2.c   ****  * Signature bytes are not available in avr-gcc io_xxx.h
 216:bootSAH_2.c   ****  * configured for atmega2560
 217:bootSAH_2.c   ****  */
 218:bootSAH_2.c   **** #ifndef SIGNATURE_BYTES
 219:bootSAH_2.c   **** 	#define SIGNATURE_BYTES 0x1E9801
 220:bootSAH_2.c   **** #endif
 221:bootSAH_2.c   **** 
 222:bootSAH_2.c   **** /* 
 223:bootSAH_2.c   ****  * ATMega with two USART, use UART0 
 224:bootSAH_2.c   ****  * configured for atmega2560 
 225:bootSAH_2.c   ****  */
 226:bootSAH_2.c   **** #define	UART_BAUD_RATE_LOW			UBRR0L
 227:bootSAH_2.c   **** #define	UART_STATUS_REG				UCSR0A
 228:bootSAH_2.c   **** #define	UART_CONTROL_REG			UCSR0B
 229:bootSAH_2.c   **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 230:bootSAH_2.c   **** #define	UART_ENABLE_RECEIVER		RXEN0
 231:bootSAH_2.c   **** #define	UART_TRANSMIT_COMPLETE		TXC0
 232:bootSAH_2.c   **** #define	UART_RECEIVE_COMPLETE		RXC0
 233:bootSAH_2.c   **** #define	UART_DATA_REG				UDR0
 234:bootSAH_2.c   **** #define	UART_DOUBLE_SPEED			U2X0
 235:bootSAH_2.c   **** 
 236:bootSAH_2.c   **** 
 237:bootSAH_2.c   **** /*
 238:bootSAH_2.c   ****  * Macro to calculate UBBR from XTAL and baudrate
 239:bootSAH_2.c   ****  */
 240:bootSAH_2.c   **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 241:bootSAH_2.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 242:bootSAH_2.c   **** #elif defined(__AVR_ATmega32__)
 243:bootSAH_2.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 244:bootSAH_2.c   **** #elif UART_BAUDRATE_DOUBLE_SPEED
 245:bootSAH_2.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 246:bootSAH_2.c   **** #else
 247:bootSAH_2.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 248:bootSAH_2.c   **** #endif
 249:bootSAH_2.c   **** 
 250:bootSAH_2.c   **** 
 251:bootSAH_2.c   **** /*
 252:bootSAH_2.c   ****  * States used in the receive state machine
 253:bootSAH_2.c   ****  */
 254:bootSAH_2.c   **** #define	ST_START		0
 255:bootSAH_2.c   **** #define	ST_GET_SEQ_NUM	1
 256:bootSAH_2.c   **** #define ST_MSG_SIZE_1	2
 257:bootSAH_2.c   **** #define ST_MSG_SIZE_2	3
 258:bootSAH_2.c   **** #define ST_GET_TOKEN	4
 259:bootSAH_2.c   **** #define ST_GET_DATA		5
 260:bootSAH_2.c   **** #define	ST_GET_CHECK	6
 261:bootSAH_2.c   **** #define	ST_PROCESS		7
 262:bootSAH_2.c   **** 
 263:bootSAH_2.c   **** /*
 264:bootSAH_2.c   ****  * use 16bit address variable for ATmegas with <= 64K flash
 265:bootSAH_2.c   ****  */
 266:bootSAH_2.c   **** #if defined(RAMPZ)
 267:bootSAH_2.c   **** 	typedef uint32_t address_t;
 268:bootSAH_2.c   **** #else
 269:bootSAH_2.c   **** 	typedef uint16_t address_t;
 270:bootSAH_2.c   **** #endif
 271:bootSAH_2.c   **** 
 272:bootSAH_2.c   **** /*
 273:bootSAH_2.c   ****  * function prototypes
 274:bootSAH_2.c   ****  */
 275:bootSAH_2.c   **** static void sendchar(char c);
 276:bootSAH_2.c   **** static unsigned char recchar(void);
 277:bootSAH_2.c   **** 
 278:bootSAH_2.c   **** /*
 279:bootSAH_2.c   ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 280:bootSAH_2.c   ****  * to reduce the code size, we need to provide our own initialization
 281:bootSAH_2.c   ****  */
 282:bootSAH_2.c   **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 283:bootSAH_2.c   **** #include <avr/sfr_defs.h>
 284:bootSAH_2.c   **** 
 285:bootSAH_2.c   **** //#define	SPH_REG	0x3E
 286:bootSAH_2.c   **** //#define	SPL_REG	0x3D
 287:bootSAH_2.c   **** 
 288:bootSAH_2.c   **** //*****************************************************************************
 289:bootSAH_2.c   **** void __jumpMain(void)
 290:bootSAH_2.c   **** {
 291:bootSAH_2.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 292:bootSAH_2.c   **** //*	the first line did not do the job on the ATmega128
 293:bootSAH_2.c   **** 
 294:bootSAH_2.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 295:bootSAH_2.c   **** 
 296:bootSAH_2.c   **** //*	set stack pointer to top of RAM
 297:bootSAH_2.c   **** 
 298:bootSAH_2.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 299:bootSAH_2.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 300:bootSAH_2.c   **** 
 301:bootSAH_2.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 302:bootSAH_2.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 303:bootSAH_2.c   **** 
 304:bootSAH_2.c   **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 305:bootSAH_2.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 306:bootSAH_2.c   **** 	asm volatile ( "jmp main");												// jump to main()
 307:bootSAH_2.c   **** }
 308:bootSAH_2.c   **** 
 309:bootSAH_2.c   **** 
 310:bootSAH_2.c   **** //*****************************************************************************
 311:bootSAH_2.c   **** void delay_ms(unsigned int timedelay)
 312:bootSAH_2.c   **** {
 313:bootSAH_2.c   **** 	unsigned int i;
 314:bootSAH_2.c   **** 	for (i=0;i<timedelay;i++)
 315:bootSAH_2.c   **** 	{
 316:bootSAH_2.c   **** 		_delay_ms(0.5);
 317:bootSAH_2.c   **** 	}
 318:bootSAH_2.c   **** }
 319:bootSAH_2.c   **** 
 320:bootSAH_2.c   **** 
 321:bootSAH_2.c   **** //*****************************************************************************
 322:bootSAH_2.c   **** /*
 323:bootSAH_2.c   ****  * send single byte to USART, wait until transmission is completed
 324:bootSAH_2.c   ****  */
 325:bootSAH_2.c   **** static void sendchar(char c)
 326:bootSAH_2.c   **** {
  15               		.loc 1 326 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 327:bootSAH_2.c   **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 327 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 328:bootSAH_2.c   **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 328 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 329:bootSAH_2.c   **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 329 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE13:
  39               		.section	.init9,"ax",@progbits
  40               	.global	__jumpMain
  42               	__jumpMain:
  43               	.LFB11:
 290:bootSAH_2.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  44               		.loc 1 290 0
  45               		.cfi_startproc
  46               	/* prologue: naked */
  47               	/* frame size = 0 */
  48               	/* stack size = 0 */
  49               	.L__stack_usage = 0
 294:bootSAH_2.c   **** 
  50               		.loc 1 294 0
  51               	/* #APP */
  52               	 ;  294 "bootSAH_2.c" 1
  53               		.set __stack, 8703
  54               	 ;  0 "" 2
 298:bootSAH_2.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  55               		.loc 1 298 0
  56               	 ;  298 "bootSAH_2.c" 1
  57 0000 01E2      		ldi	16, 33
  58               	 ;  0 "" 2
 299:bootSAH_2.c   **** 
  59               		.loc 1 299 0
  60               	 ;  299 "bootSAH_2.c" 1
  61 0002 0EBF      		out 62,16
  62               	 ;  0 "" 2
 301:bootSAH_2.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  63               		.loc 1 301 0
  64               	 ;  301 "bootSAH_2.c" 1
  65 0004 0FEF      		ldi	16, 255
  66               	 ;  0 "" 2
 302:bootSAH_2.c   **** 
  67               		.loc 1 302 0
  68               	 ;  302 "bootSAH_2.c" 1
  69 0006 0DBF      		out 61,16
  70               	 ;  0 "" 2
 304:bootSAH_2.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  71               		.loc 1 304 0
  72               	 ;  304 "bootSAH_2.c" 1
  73 0008 1124      		clr __zero_reg__
  74               	 ;  0 "" 2
 305:bootSAH_2.c   **** 	asm volatile ( "jmp main");												// jump to main()
  75               		.loc 1 305 0
  76               	 ;  305 "bootSAH_2.c" 1
  77 000a 1FBE      		out 63, __zero_reg__
  78               	 ;  0 "" 2
 306:bootSAH_2.c   **** }
  79               		.loc 1 306 0
  80               	 ;  306 "bootSAH_2.c" 1
  81 000c 0C94 0000 		jmp main
  82               	 ;  0 "" 2
  83               	/* epilogue start */
 307:bootSAH_2.c   **** 
  84               		.loc 1 307 0
  85               	/* #NOAPP */
  86               		.cfi_endproc
  87               	.LFE11:
  89               		.text
  90               	.global	delay_ms
  92               	delay_ms:
  93               	.LFB12:
 312:bootSAH_2.c   **** 	unsigned int i;
  94               		.loc 1 312 0
  95               		.cfi_startproc
  96               	.LVL3:
  97               	/* prologue: function */
  98               	/* frame size = 0 */
  99               	/* stack size = 0 */
 100               	.L__stack_usage = 0
 314:bootSAH_2.c   **** 	{
 101               		.loc 1 314 0
 102 0018 20E0      		ldi r18,0
 103 001a 30E0      		ldi r19,0
 104               	.LVL4:
 105               	.L8:
 314:bootSAH_2.c   **** 	{
 106               		.loc 1 314 0 is_stmt 0 discriminator 1
 107 001c 2817      		cp r18,r24
 108 001e 3907      		cpc r19,r25
 109 0020 01F0      		breq .L10
 110               	.LVL5:
 111               	.LBB46:
 112               	.LBB47:
 113               		.file 2 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ut
   1:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 114               		.loc 2 187 0 is_stmt 1
 115 0022 EFEC      		ldi r30,lo8(1999)
 116 0024 F7E0      		ldi r31,hi8(1999)
 117 0026 3197      	1:	sbiw r30,1
 118 0028 01F4      		brne 1b
 119 002a 00C0      		rjmp .
 120 002c 0000      		nop
 121               	.LVL6:
 122               	.LBE47:
 123               	.LBE46:
 314:bootSAH_2.c   **** 	{
 124               		.loc 1 314 0
 125 002e 2F5F      		subi r18,-1
 126 0030 3F4F      		sbci r19,-1
 127               	.LVL7:
 128 0032 00C0      		rjmp .L8
 129               	.L10:
 130               	/* epilogue start */
 318:bootSAH_2.c   **** 
 131               		.loc 1 318 0
 132 0034 0895      		ret
 133               		.cfi_endproc
 134               	.LFE12:
 136               		.section	.text.startup,"ax",@progbits
 137               	.global	main
 139               	main:
 140               	.LFB17:
 330:bootSAH_2.c   **** }
 331:bootSAH_2.c   **** 
 332:bootSAH_2.c   **** 
 333:bootSAH_2.c   **** //************************************************************************
 334:bootSAH_2.c   **** static int	Serial_Available(void)
 335:bootSAH_2.c   **** {
 336:bootSAH_2.c   **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 337:bootSAH_2.c   **** }
 338:bootSAH_2.c   **** 
 339:bootSAH_2.c   **** 
 340:bootSAH_2.c   **** //*****************************************************************************
 341:bootSAH_2.c   **** /*
 342:bootSAH_2.c   ****  * Read single byte from USART, block if no data available
 343:bootSAH_2.c   ****  */
 344:bootSAH_2.c   **** static unsigned char recchar(void)
 345:bootSAH_2.c   **** {
 346:bootSAH_2.c   **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 347:bootSAH_2.c   **** 	{
 348:bootSAH_2.c   **** 		// wait for data
 349:bootSAH_2.c   **** 	}
 350:bootSAH_2.c   **** 	return UART_DATA_REG;
 351:bootSAH_2.c   **** }
 352:bootSAH_2.c   **** 
 353:bootSAH_2.c   **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 354:bootSAH_2.c   **** //*****************************************************************************
 355:bootSAH_2.c   **** static unsigned char recchar_timeout(void)
 356:bootSAH_2.c   **** {
 357:bootSAH_2.c   **** uint32_t count = 0;
 358:bootSAH_2.c   **** 
 359:bootSAH_2.c   **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 360:bootSAH_2.c   **** 	{
 361:bootSAH_2.c   **** 		// wait for data
 362:bootSAH_2.c   **** 		count++;
 363:bootSAH_2.c   **** 		if (count > MAX_TIME_COUNT)
 364:bootSAH_2.c   **** 		{
 365:bootSAH_2.c   **** 		unsigned int	data;
 366:bootSAH_2.c   **** 		#if (FLASHEND > 0x10000)
 367:bootSAH_2.c   **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 368:bootSAH_2.c   **** 		#else
 369:bootSAH_2.c   **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 370:bootSAH_2.c   **** 		#endif
 371:bootSAH_2.c   **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 372:bootSAH_2.c   **** 			{
 373:bootSAH_2.c   **** 				asm volatile(
 374:bootSAH_2.c   **** 						"clr	r30		\n\t"
 375:bootSAH_2.c   **** 						"clr	r31		\n\t"
 376:bootSAH_2.c   **** 						"ijmp	\n\t"
 377:bootSAH_2.c   **** 						);
 378:bootSAH_2.c   **** 			}
 379:bootSAH_2.c   **** 			count	=	0;
 380:bootSAH_2.c   **** 		}
 381:bootSAH_2.c   **** 	}
 382:bootSAH_2.c   **** 	return UART_DATA_REG;
 383:bootSAH_2.c   **** }
 384:bootSAH_2.c   **** 
 385:bootSAH_2.c   **** /*
 386:bootSAH_2.c   **** unsigned char hexArr[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
 387:bootSAH_2.c   **** 
 388:bootSAH_2.c   **** void printByte(uint8_t numData)
 389:bootSAH_2.c   **** {
 390:bootSAH_2.c   **** 	char chData1, chData2;
 391:bootSAH_2.c   **** 	chData1 = hexArr[numData >> 4];
 392:bootSAH_2.c   **** 	chData2 = hexArr[numData & 0xF];
 393:bootSAH_2.c   **** 	sendchar(chData1);
 394:bootSAH_2.c   **** 	sendchar(chData2);
 395:bootSAH_2.c   **** }
 396:bootSAH_2.c   **** */
 397:bootSAH_2.c   **** 
 398:bootSAH_2.c   **** //*	for watch dog timer startup
 399:bootSAH_2.c   **** void (*app_start)(void) = 0x0000;
 400:bootSAH_2.c   **** 
 401:bootSAH_2.c   **** 
 402:bootSAH_2.c   **** //*****************************************************************************
 403:bootSAH_2.c   **** int main(void)
 404:bootSAH_2.c   **** {
 141               		.loc 1 404 0
 142               		.cfi_startproc
 143 0000 CF93      		push r28
 144               	.LCFI0:
 145               		.cfi_def_cfa_offset 4
 146               		.cfi_offset 28, -3
 147 0002 DF93      		push r29
 148               	.LCFI1:
 149               		.cfi_def_cfa_offset 5
 150               		.cfi_offset 29, -4
 151 0004 CDB7      		in r28,__SP_L__
 152 0006 DEB7      		in r29,__SP_H__
 153               	.LCFI2:
 154               		.cfi_def_cfa_register 28
 155 0008 C052      		subi r28,32
 156 000a D140      		sbci r29,1
 157               	.LCFI3:
 158               		.cfi_def_cfa_offset 293
 159 000c 0FB6      		in __tmp_reg__,__SREG__
 160 000e F894      		cli
 161 0010 DEBF      		out __SP_H__,r29
 162 0012 0FBE      		out __SREG__,__tmp_reg__
 163 0014 CDBF      		out __SP_L__,r28
 164               	/* prologue: function */
 165               	/* frame size = 288 */
 166               	/* stack size = 290 */
 167               	.L__stack_usage = 290
 168               	.LVL8:
 405:bootSAH_2.c   **** 	address_t		address			=	0;
 406:bootSAH_2.c   **** 	address_t		eraseAddress	=	0;
 407:bootSAH_2.c   **** 	unsigned char	msgParseState;
 408:bootSAH_2.c   **** 	unsigned int	ii				=	0;
 409:bootSAH_2.c   **** 	unsigned char	checksum		=	0;
 410:bootSAH_2.c   **** 	unsigned char	seqNum			=	0;
 411:bootSAH_2.c   **** 	unsigned int	msgLength		=	0;
 412:bootSAH_2.c   **** 	unsigned char	msgBuffer[285];
 413:bootSAH_2.c   **** 	unsigned char	c, *p;
 414:bootSAH_2.c   **** 	unsigned char   isLeave = 0;
 415:bootSAH_2.c   **** 
 416:bootSAH_2.c   **** 	unsigned long	boot_timeout;
 417:bootSAH_2.c   **** 	unsigned long	boot_timer;
 418:bootSAH_2.c   **** 	unsigned int	boot_state;
 419:bootSAH_2.c   **** #ifdef ENABLE_MONITOR
 420:bootSAH_2.c   **** 	unsigned int	exPointCntr		=	0;
 421:bootSAH_2.c   **** 	unsigned int	rcvdCharCntr	=	0;
 422:bootSAH_2.c   **** #endif
 423:bootSAH_2.c   **** 
 424:bootSAH_2.c   **** 
 425:bootSAH_2.c   **** 	//*	some chips dont set the stack properly
 426:bootSAH_2.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 169               		.loc 1 426 0
 170               	/* #APP */
 171               	 ;  426 "bootSAH_2.c" 1
 172               		.set __stack, 8703
 173               	 ;  0 "" 2
 427:bootSAH_2.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 174               		.loc 1 427 0
 175               	 ;  427 "bootSAH_2.c" 1
 176 0016 01E2      		ldi	16, 33
 177               	 ;  0 "" 2
 428:bootSAH_2.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 178               		.loc 1 428 0
 179               	 ;  428 "bootSAH_2.c" 1
 180 0018 0EBF      		out 62,16
 181               	 ;  0 "" 2
 429:bootSAH_2.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 182               		.loc 1 429 0
 183               	 ;  429 "bootSAH_2.c" 1
 184 001a 0FEF      		ldi	16, 255
 185               	 ;  0 "" 2
 430:bootSAH_2.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 186               		.loc 1 430 0
 187               	 ;  430 "bootSAH_2.c" 1
 188 001c 0DBF      		out 61,16
 189               	 ;  0 "" 2
 431:bootSAH_2.c   **** 
 432:bootSAH_2.c   **** #ifdef _FIX_ISSUE_181_
 433:bootSAH_2.c   **** 	//************************************************************************
 434:bootSAH_2.c   **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 435:bootSAH_2.c   **** 	//*	handle the watch dog timer
 436:bootSAH_2.c   **** 	uint8_t	mcuStatusReg;
 437:bootSAH_2.c   **** 	mcuStatusReg	=	MCUSR;
 190               		.loc 1 437 0
 191               	/* #NOAPP */
 192 001e 94B7      		in r25,0x34
 193               	.LVL9:
 438:bootSAH_2.c   **** 
 439:bootSAH_2.c   **** 	__asm__ __volatile__ ("cli");
 194               		.loc 1 439 0
 195               	/* #APP */
 196               	 ;  439 "bootSAH_2.c" 1
 197 0020 F894      		cli
 198               	 ;  0 "" 2
 440:bootSAH_2.c   **** 	__asm__ __volatile__ ("wdr");
 199               		.loc 1 440 0
 200               	 ;  440 "bootSAH_2.c" 1
 201 0022 A895      		wdr
 202               	 ;  0 "" 2
 441:bootSAH_2.c   **** 	//MCUSR	=	0;
 442:bootSAH_2.c   **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 203               		.loc 1 442 0
 204               	/* #NOAPP */
 205 0024 8091 6000 		lds r24,96
 206 0028 8861      		ori r24,lo8(24)
 207 002a 8093 6000 		sts 96,r24
 443:bootSAH_2.c   **** 	WDTCSR	=	0;
 208               		.loc 1 443 0
 209 002e 1092 6000 		sts 96,__zero_reg__
 444:bootSAH_2.c   **** 	__asm__ __volatile__ ("sei");
 210               		.loc 1 444 0
 211               	/* #APP */
 212               	 ;  444 "bootSAH_2.c" 1
 213 0032 7894      		sei
 214               	 ;  0 "" 2
 445:bootSAH_2.c   **** 	// check if WDT generated the reset, if so, go straight to app
 446:bootSAH_2.c   **** 	if (mcuStatusReg & _BV(WDRF))
 215               		.loc 1 446 0
 216               	/* #NOAPP */
 217 0034 93FF      		sbrs r25,3
 218 0036 00C0      		rjmp .L12
 447:bootSAH_2.c   **** 	{
 448:bootSAH_2.c   **** 		app_start();
 219               		.loc 1 448 0
 220 0038 E091 0000 		lds r30,app_start
 221 003c F091 0000 		lds r31,app_start+1
 222 0040 1995      		eicall
 223               	.LVL10:
 224               	.L12:
 449:bootSAH_2.c   **** 	}
 450:bootSAH_2.c   **** 	//************************************************************************
 451:bootSAH_2.c   **** #endif
 452:bootSAH_2.c   **** 
 453:bootSAH_2.c   **** 
 454:bootSAH_2.c   **** 	boot_timer	=	0;
 455:bootSAH_2.c   **** 	boot_state	=	0;
 456:bootSAH_2.c   **** 
 457:bootSAH_2.c   **** #ifdef BLINK_LED_WHILE_WAITING
 458:bootSAH_2.c   **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 459:bootSAH_2.c   **** //	boot_timeout	=	170000;
 460:bootSAH_2.c   **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 461:bootSAH_2.c   **** #else
 462:bootSAH_2.c   **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 463:bootSAH_2.c   **** #endif
 464:bootSAH_2.c   **** 	/*
 465:bootSAH_2.c   **** 	 * Branch to bootloader or application code ?
 466:bootSAH_2.c   **** 	 */
 467:bootSAH_2.c   **** 
 468:bootSAH_2.c   **** #ifndef REMOVE_BOOTLOADER_LED
 469:bootSAH_2.c   **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 470:bootSAH_2.c   **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 225               		.loc 1 470 0
 226 0042 279A      		sbi 0x4,7
 471:bootSAH_2.c   **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 472:bootSAH_2.c   **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 227               		.loc 1 472 0
 228 0044 2F9A      		sbi 0x5,7
 473:bootSAH_2.c   **** 
 474:bootSAH_2.c   **** #ifdef _DEBUG_WITH_LEDS_
 475:bootSAH_2.c   **** 	for (ii=0; ii<3; ii++)
 476:bootSAH_2.c   **** 	{
 477:bootSAH_2.c   **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 478:bootSAH_2.c   **** 		delay_ms(100);
 479:bootSAH_2.c   **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 480:bootSAH_2.c   **** 		delay_ms(100);
 481:bootSAH_2.c   **** 	}
 482:bootSAH_2.c   **** #endif
 483:bootSAH_2.c   **** 
 484:bootSAH_2.c   **** #endif
 485:bootSAH_2.c   **** 	/*
 486:bootSAH_2.c   **** 	 * Init UART
 487:bootSAH_2.c   **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 488:bootSAH_2.c   **** 	 */
 489:bootSAH_2.c   **** #if UART_BAUDRATE_DOUBLE_SPEED
 490:bootSAH_2.c   **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 229               		.loc 1 490 0
 230 0046 8091 C000 		lds r24,192
 231 004a 8260      		ori r24,lo8(2)
 232 004c 8093 C000 		sts 192,r24
 491:bootSAH_2.c   **** #endif
 492:bootSAH_2.c   **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 233               		.loc 1 492 0
 234 0050 80E1      		ldi r24,lo8(16)
 235 0052 8093 C400 		sts 196,r24
 493:bootSAH_2.c   **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 236               		.loc 1 493 0
 237 0056 88E1      		ldi r24,lo8(24)
 238 0058 8093 C100 		sts 193,r24
 494:bootSAH_2.c   **** 
 495:bootSAH_2.c   **** 	asm volatile ("nop");			// wait until port has changed
 239               		.loc 1 495 0
 240               	/* #APP */
 241               	 ;  495 "bootSAH_2.c" 1
 242 005c 0000      		nop
 243               	 ;  0 "" 2
 496:bootSAH_2.c   **** 
 497:bootSAH_2.c   **** #ifdef _DEBUG_SERIAL_
 498:bootSAH_2.c   **** //	delay_ms(500);
 499:bootSAH_2.c   **** 
 500:bootSAH_2.c   **** 	sendchar('u');
 244               		.loc 1 500 0
 245               	/* #NOAPP */
 246 005e 85E7      		ldi r24,lo8(117)
 247 0060 0E94 0000 		call sendchar
 248               	.LVL11:
 501:bootSAH_2.c   **** 	sendchar('t');
 249               		.loc 1 501 0
 250 0064 84E7      		ldi r24,lo8(116)
 251 0066 0E94 0000 		call sendchar
 252               	.LVL12:
 502:bootSAH_2.c   **** 	sendchar('e');
 253               		.loc 1 502 0
 254 006a 85E6      		ldi r24,lo8(101)
 255 006c 0E94 0000 		call sendchar
 256               	.LVL13:
 503:bootSAH_2.c   **** 	sendchar('c');
 257               		.loc 1 503 0
 258 0070 83E6      		ldi r24,lo8(99)
 259 0072 0E94 0000 		call sendchar
 260               	.LVL14:
 504:bootSAH_2.c   **** 	sendchar('h');
 261               		.loc 1 504 0
 262 0076 88E6      		ldi r24,lo8(104)
 263 0078 0E94 0000 		call sendchar
 264               	.LVL15:
 505:bootSAH_2.c   **** 	sendchar('_');
 265               		.loc 1 505 0
 266 007c 8FE5      		ldi r24,lo8(95)
 267 007e 0E94 0000 		call sendchar
 268               	.LVL16:
 506:bootSAH_2.c   **** 	sendchar('B');
 269               		.loc 1 506 0
 270 0082 82E4      		ldi r24,lo8(66)
 271 0084 0E94 0000 		call sendchar
 272               	.LVL17:
 507:bootSAH_2.c   **** 	sendchar('B');
 273               		.loc 1 507 0
 274 0088 82E4      		ldi r24,lo8(66)
 275 008a 0E94 0000 		call sendchar
 276               	.LVL18:
 508:bootSAH_2.c   **** 
 509:bootSAH_2.c   **** 	sendchar(0x0d);
 277               		.loc 1 509 0
 278 008e 8DE0      		ldi r24,lo8(13)
 279 0090 0E94 0000 		call sendchar
 280               	.LVL19:
 510:bootSAH_2.c   **** 	sendchar(0x0a);
 281               		.loc 1 510 0
 282 0094 8AE0      		ldi r24,lo8(10)
 283 0096 0E94 0000 		call sendchar
 284               	.LVL20:
 285 009a 00E0      		ldi r16,0
 286 009c 10E0      		ldi r17,0
 287 009e C12C      		mov r12,__zero_reg__
 288 00a0 D12C      		mov r13,__zero_reg__
 289 00a2 7601      		movw r14,r12
 511:bootSAH_2.c   **** /*	
 512:bootSAH_2.c   **** 	//FLASHEND and BOOTSIZE
 513:bootSAH_2.c   **** 	uint32_t flash_end = FLASHEND;
 514:bootSAH_2.c   **** 	uint16_t boot_size = BOOTSIZE;
 515:bootSAH_2.c   **** 	
 516:bootSAH_2.c   **** 	printByte((uint8_t)(flash_end >> 24));
 517:bootSAH_2.c   **** 	printByte((uint8_t)((flash_end >> 16) & 0xff));
 518:bootSAH_2.c   **** 	printByte((uint8_t)((flash_end >> 8) & 0xff));
 519:bootSAH_2.c   **** 	printByte((uint8_t)(flash_end & 0xff));
 520:bootSAH_2.c   **** 	
 521:bootSAH_2.c   **** 	sendchar(' ');
 522:bootSAH_2.c   **** 	
 523:bootSAH_2.c   **** 	printByte((uint8_t)((boot_size >> 8) & 0xff));
 524:bootSAH_2.c   **** 	printByte((uint8_t)(boot_size & 0xff));
 525:bootSAH_2.c   **** 
 526:bootSAH_2.c   **** 	delay_ms(100);
 527:bootSAH_2.c   **** */
 528:bootSAH_2.c   **** #endif
 529:bootSAH_2.c   **** 
 530:bootSAH_2.c   **** 	while (boot_state==0)
 531:bootSAH_2.c   **** 	{
 532:bootSAH_2.c   **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 533:bootSAH_2.c   **** 		{
 534:bootSAH_2.c   **** 			_delay_ms(0.001);
 535:bootSAH_2.c   **** 			boot_timer++;
 536:bootSAH_2.c   **** 			if (boot_timer > boot_timeout)
 537:bootSAH_2.c   **** 			{
 538:bootSAH_2.c   **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 539:bootSAH_2.c   **** 			}
 540:bootSAH_2.c   **** 		#ifdef BLINK_LED_WHILE_WAITING
 541:bootSAH_2.c   **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 290               		.loc 1 541 0
 291 00a4 97EC      		ldi r25,lo8(-57)
 292 00a6 892E      		mov r8,r25
 293 00a8 9BE1      		ldi r25,lo8(27)
 294 00aa 992E      		mov r9,r25
 295 00ac A12C      		mov r10,__zero_reg__
 296 00ae B12C      		mov r11,__zero_reg__
 297               	.LVL21:
 298               	.L13:
 299               	.LBB74:
 300               	.LBB75:
 336:bootSAH_2.c   **** }
 301               		.loc 1 336 0
 302 00b0 8091 C000 		lds r24,192
 303               	.LBE75:
 304               	.LBE74:
 532:bootSAH_2.c   **** 		{
 305               		.loc 1 532 0
 306 00b4 87FD      		sbrc r24,7
 307 00b6 00C0      		rjmp .L123
 532:bootSAH_2.c   **** 		{
 308               		.loc 1 532 0 is_stmt 0 discriminator 1
 309 00b8 0115      		cp r16,__zero_reg__
 310 00ba 1105      		cpc r17,__zero_reg__
 311 00bc 01F4      		brne .L123
 312               	.LVL22:
 313               	.LBB76:
 314               	.LBB77:
 315               		.loc 2 187 0 is_stmt 1
 316 00be 25E0      		ldi r18,lo8(5)
 317 00c0 2A95      	1:	dec r18
 318 00c2 01F4      		brne 1b
 319 00c4 0000      		nop
 320               	.LVL23:
 321               	.LBE77:
 322               	.LBE76:
 535:bootSAH_2.c   **** 			if (boot_timer > boot_timeout)
 323               		.loc 1 535 0
 324 00c6 4FEF      		ldi r20,-1
 325 00c8 C41A      		sub r12,r20
 326 00ca D40A      		sbc r13,r20
 327 00cc E40A      		sbc r14,r20
 328 00ce F40A      		sbc r15,r20
 329               	.LVL24:
 538:bootSAH_2.c   **** 			}
 330               		.loc 1 538 0
 331 00d0 91E0      		ldi r25,lo8(1)
 332 00d2 80E0      		ldi r24,0
 333 00d4 E1E2      		ldi r30,33
 334 00d6 CE16      		cp r12,r30
 335 00d8 EEE4      		ldi r30,78
 336 00da DE06      		cpc r13,r30
 337 00dc E104      		cpc r14,__zero_reg__
 338 00de F104      		cpc r15,__zero_reg__
 339 00e0 00F4      		brsh .L14
 340 00e2 90E0      		ldi r25,0
 341               	.L14:
 342 00e4 092F      		mov r16,r25
 343               	.LVL25:
 344 00e6 182F      		mov r17,r24
 345               		.loc 1 541 0
 346 00e8 C701      		movw r24,r14
 347 00ea B601      		movw r22,r12
 348 00ec A501      		movw r20,r10
 349 00ee 9401      		movw r18,r8
 350 00f0 0E94 0000 		call __udivmodsi4
 351 00f4 672B      		or r22,r23
 352 00f6 682B      		or r22,r24
 353 00f8 692B      		or r22,r25
 354 00fa 01F4      		brne .L13
 542:bootSAH_2.c   **** 			{
 543:bootSAH_2.c   **** 				//*	toggle the LED
 544:bootSAH_2.c   **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 355               		.loc 1 544 0
 356 00fc 85B1      		in r24,0x5
 357 00fe 8058      		subi r24,lo8(-(-128))
 358 0100 85B9      		out 0x5,r24
 359 0102 00C0      		rjmp .L13
 360               	.LVL26:
 361               	.L123:
 545:bootSAH_2.c   **** 			}
 546:bootSAH_2.c   **** 		#endif
 547:bootSAH_2.c   **** 		}
 548:bootSAH_2.c   **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 362               		.loc 1 548 0
 363 0104 0F5F      		subi r16,-1
 364 0106 1F4F      		sbci r17,-1
 365               	.LVL27:
 549:bootSAH_2.c   **** 	}
 550:bootSAH_2.c   **** 
 551:bootSAH_2.c   **** 
 552:bootSAH_2.c   **** 	if (boot_state==1)
 366               		.loc 1 552 0
 367 0108 0130      		cpi r16,1
 368 010a 1105      		cpc r17,__zero_reg__
 369 010c 01F0      		breq .+2
 370 010e 00C0      		rjmp .L20
 371 0110 C25E      		subi r28,lo8(-286)
 372 0112 DE4F      		sbci r29,hi8(-286)
 373 0114 1882      		st Y,__zero_reg__
 374 0116 CE51      		subi r28,lo8(286)
 375 0118 D140      		sbci r29,hi8(286)
 376 011a D12C      		mov r13,__zero_reg__
 377 011c 212C      		mov r2,__zero_reg__
 378 011e 312C      		mov r3,__zero_reg__
 379 0120 812C      		mov r8,__zero_reg__
 380 0122 912C      		mov r9,__zero_reg__
 381 0124 5401      		movw r10,r8
 382 0126 412C      		mov r4,__zero_reg__
 383 0128 512C      		mov r5,__zero_reg__
 384 012a 3201      		movw r6,r4
 385               	.LVL28:
 386               	.L80:
 510:bootSAH_2.c   **** /*	
 387               		.loc 1 510 0
 388 012c 20E0      		ldi r18,0
 389 012e 30E0      		ldi r19,0
 390 0130 80E0      		ldi r24,0
 391               	.LVL29:
 392               	.L81:
 553:bootSAH_2.c   **** 	{
 554:bootSAH_2.c   **** 		//*	main loop
 555:bootSAH_2.c   **** 		while (!isLeave)
 556:bootSAH_2.c   **** 		{
 557:bootSAH_2.c   **** 			/*
 558:bootSAH_2.c   **** 			 * Collect received bytes to a complete message
 559:bootSAH_2.c   **** 			 */
 560:bootSAH_2.c   **** 			msgParseState	=	ST_START;
 561:bootSAH_2.c   **** 			while ( msgParseState != ST_PROCESS )
 562:bootSAH_2.c   **** 			{
 563:bootSAH_2.c   **** 				if (boot_state==1)
 393               		.loc 1 563 0
 394 0132 0130      		cpi r16,1
 395 0134 1105      		cpc r17,__zero_reg__
 396 0136 01F0      		breq .L126
 397               	.L24:
 510:bootSAH_2.c   **** /*	
 398               		.loc 1 510 0
 399 0138 41E0      		ldi r20,lo8(1)
 400 013a 52E1      		ldi r21,lo8(18)
 401 013c 6AE7      		ldi r22,lo8(122)
 402 013e 70E0      		ldi r23,0
 403               	.L23:
 404               	.LVL30:
 405               	.LBB78:
 406               	.LBB79:
 359:bootSAH_2.c   **** 	{
 407               		.loc 1 359 0
 408 0140 9091 C000 		lds r25,192
 409 0144 97FD      		sbrc r25,7
 410 0146 00C0      		rjmp .L126
 411               	.LVL31:
 412 0148 4150      		subi r20,1
 413 014a 5109      		sbc r21,__zero_reg__
 414 014c 6109      		sbc r22,__zero_reg__
 415 014e 7109      		sbc r23,__zero_reg__
 416               	.LVL32:
 363:bootSAH_2.c   **** 		{
 417               		.loc 1 363 0
 418 0150 01F4      		brne .L23
 419               	.LVL33:
 420               	.LBB80:
 421               	.LBB81:
 367:bootSAH_2.c   **** 		#else
 422               		.loc 1 367 0
 423               	/* #APP */
 424               	 ;  367 "bootSAH_2.c" 1
 425 0152 6BBF      		out 59, r22
 426 0154 FA01      		movw r30, r20
 427 0156 4791      		elpm r20, Z+
 428 0158 5691      		elpm r21, Z
 429               		
 430               	 ;  0 "" 2
 431               	.LVL34:
 432               	/* #NOAPP */
 433               	.LBE81:
 371:bootSAH_2.c   **** 			{
 434               		.loc 1 371 0
 435 015a 4F3F      		cpi r20,-1
 436 015c 5F4F      		sbci r21,-1
 437 015e 01F0      		breq .L24
 373:bootSAH_2.c   **** 						"clr	r30		\n\t"
 438               		.loc 1 373 0
 439               	/* #APP */
 440               	 ;  373 "bootSAH_2.c" 1
 441 0160 EE27      		clr	r30		
 442 0162 FF27      		clr	r31		
 443 0164 0994      		ijmp	
 444               		
 445               	 ;  0 "" 2
 446               	/* #NOAPP */
 447 0166 00C0      		rjmp .L24
 448               	.LVL35:
 449               	.L126:
 450               	.LBE80:
 382:bootSAH_2.c   **** }
 451               		.loc 1 382 0
 452 0168 9091 C600 		lds r25,198
 453               	.LVL36:
 454               	.LBE79:
 455               	.LBE78:
 564:bootSAH_2.c   **** 				{
 565:bootSAH_2.c   **** 					boot_state	=	0;
 566:bootSAH_2.c   **** 					c			=	UART_DATA_REG;
 567:bootSAH_2.c   **** 				}
 568:bootSAH_2.c   **** 				else
 569:bootSAH_2.c   **** 				{
 570:bootSAH_2.c   **** 				//	c	=	recchar();
 571:bootSAH_2.c   **** 					c	=	recchar_timeout();
 572:bootSAH_2.c   **** 					
 573:bootSAH_2.c   **** 				}
 574:bootSAH_2.c   **** 
 575:bootSAH_2.c   **** 			#ifdef ENABLE_MONITOR
 576:bootSAH_2.c   **** 				rcvdCharCntr++;
 577:bootSAH_2.c   **** 
 578:bootSAH_2.c   **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 579:bootSAH_2.c   **** 				{
 580:bootSAH_2.c   **** 					exPointCntr++;
 581:bootSAH_2.c   **** 					if (exPointCntr == 3)
 582:bootSAH_2.c   **** 					{
 583:bootSAH_2.c   **** 						RunMonitor();
 584:bootSAH_2.c   **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 585:bootSAH_2.c   **** 						isLeave			=	1;
 586:bootSAH_2.c   **** 						msgParseState	=	99;	//*	we dont want it do anything
 587:bootSAH_2.c   **** 						break;
 588:bootSAH_2.c   **** 					}
 589:bootSAH_2.c   **** 				}
 590:bootSAH_2.c   **** 				else
 591:bootSAH_2.c   **** 				{
 592:bootSAH_2.c   **** 					exPointCntr	=	0;
 593:bootSAH_2.c   **** 				}
 594:bootSAH_2.c   **** 			#endif
 595:bootSAH_2.c   **** 
 596:bootSAH_2.c   **** 				switch (msgParseState)
 456               		.loc 1 596 0
 457 016c 8330      		cpi r24,lo8(3)
 458 016e 01F0      		breq .L27
 459 0170 00F4      		brsh .L28
 460 0172 8130      		cpi r24,lo8(1)
 461 0174 01F0      		breq .L29
 462 0176 00F0      		brlo .L124
 463 0178 00C0      		rjmp .L135
 464               	.L28:
 465 017a 8530      		cpi r24,lo8(5)
 466 017c 01F0      		breq .L32
 467 017e 00F0      		brlo .L33
 468 0180 8630      		cpi r24,lo8(6)
 469 0182 01F0      		breq .L34
 470 0184 00C0      		rjmp .L136
 471               	.L124:
 597:bootSAH_2.c   **** 				{
 598:bootSAH_2.c   **** 					case ST_START:
 599:bootSAH_2.c   **** 				if ( c == MESSAGE_START )
 472               		.loc 1 599 0
 473 0186 9B31      		cpi r25,lo8(27)
 474 0188 01F4      		brne .+2
 475 018a 00C0      		rjmp .L137
 476               	.LVL37:
 477               	.L37:
 478 018c 00E0      		ldi r16,0
 479 018e 10E0      		ldi r17,0
 480 0190 00C0      		rjmp .L81
 481               	.LVL38:
 482               	.L29:
 600:bootSAH_2.c   **** 						{
 601:bootSAH_2.c   **** 							msgParseState	=	ST_GET_SEQ_NUM;
 602:bootSAH_2.c   **** 							checksum		=	MESSAGE_START^0;
 603:bootSAH_2.c   **** 						}
 604:bootSAH_2.c   **** 						break;
 605:bootSAH_2.c   **** 
 606:bootSAH_2.c   **** 					case ST_GET_SEQ_NUM:
 607:bootSAH_2.c   **** 					#ifdef _FIX_ISSUE_505_
 608:bootSAH_2.c   **** 						seqNum			=	c;
 609:bootSAH_2.c   **** 						msgParseState	=	ST_MSG_SIZE_1;
 610:bootSAH_2.c   **** 						checksum		^=	c;
 483               		.loc 1 610 0
 484 0192 D926      		eor r13,r25
 485               	.LVL39:
 611:bootSAH_2.c   **** 					#else
 612:bootSAH_2.c   **** 						if ( (c == 1) || (c == seqNum) )
 613:bootSAH_2.c   **** 						{
 614:bootSAH_2.c   **** 							seqNum			=	c;
 615:bootSAH_2.c   **** 							msgParseState	=	ST_MSG_SIZE_1;
 616:bootSAH_2.c   **** 							checksum		^=	c;
 617:bootSAH_2.c   **** 						}
 618:bootSAH_2.c   **** 						else
 619:bootSAH_2.c   **** 						{
 620:bootSAH_2.c   **** 							msgParseState	=	ST_START;
 621:bootSAH_2.c   **** 						}
 622:bootSAH_2.c   **** 					#endif
 623:bootSAH_2.c   **** 						break;
 486               		.loc 1 623 0
 487 0194 C25E      		subi r28,lo8(-286)
 488 0196 DE4F      		sbci r29,hi8(-286)
 489 0198 9883      		st Y,r25
 490 019a CE51      		subi r28,lo8(286)
 491 019c D140      		sbci r29,hi8(286)
 609:bootSAH_2.c   **** 						checksum		^=	c;
 492               		.loc 1 609 0
 493 019e 82E0      		ldi r24,lo8(2)
 494               		.loc 1 623 0
 495 01a0 00C0      		rjmp .L37
 496               	.LVL40:
 497               	.L135:
 624:bootSAH_2.c   **** 
 625:bootSAH_2.c   **** 					case ST_MSG_SIZE_1:
 626:bootSAH_2.c   **** 						msgLength		=	c<<8;
 498               		.loc 1 626 0
 499 01a2 292F      		mov r18,r25
 500               	.LVL41:
 501 01a4 30E0      		ldi r19,0
 502 01a6 322F      		mov r19,r18
 503 01a8 2227      		clr r18
 504               	.LVL42:
 627:bootSAH_2.c   **** 						msgParseState	=	ST_MSG_SIZE_2;
 628:bootSAH_2.c   **** 						checksum		^=	c;
 505               		.loc 1 628 0
 506 01aa D926      		eor r13,r25
 507               	.LVL43:
 627:bootSAH_2.c   **** 						msgParseState	=	ST_MSG_SIZE_2;
 508               		.loc 1 627 0
 509 01ac 83E0      		ldi r24,lo8(3)
 629:bootSAH_2.c   **** 						break;
 510               		.loc 1 629 0
 511 01ae 00C0      		rjmp .L37
 512               	.LVL44:
 513               	.L27:
 630:bootSAH_2.c   **** 
 631:bootSAH_2.c   **** 					case ST_MSG_SIZE_2:
 632:bootSAH_2.c   **** 						msgLength		|=	c;
 514               		.loc 1 632 0
 515 01b0 292B      		or r18,r25
 516               	.LVL45:
 633:bootSAH_2.c   **** 						msgParseState	=	ST_GET_TOKEN;
 634:bootSAH_2.c   **** 						checksum		^=	c;
 517               		.loc 1 634 0
 518 01b2 D926      		eor r13,r25
 519               	.LVL46:
 633:bootSAH_2.c   **** 						msgParseState	=	ST_GET_TOKEN;
 520               		.loc 1 633 0
 521 01b4 84E0      		ldi r24,lo8(4)
 635:bootSAH_2.c   **** 						break;
 522               		.loc 1 635 0
 523 01b6 00C0      		rjmp .L37
 524               	.LVL47:
 525               	.L33:
 636:bootSAH_2.c   **** 
 637:bootSAH_2.c   **** 					case ST_GET_TOKEN:
 638:bootSAH_2.c   **** 						if ( c == TOKEN )
 526               		.loc 1 638 0
 527 01b8 9E30      		cpi r25,lo8(14)
 528 01ba 01F0      		breq .+2
 529 01bc 00C0      		rjmp .L85
 530               	.LVL48:
 639:bootSAH_2.c   **** 						{
 640:bootSAH_2.c   **** 							msgParseState	=	ST_GET_DATA;
 641:bootSAH_2.c   **** 							checksum		^=	c;
 531               		.loc 1 641 0
 532 01be D926      		eor r13,r25
 533               	.LVL49:
 642:bootSAH_2.c   **** 							ii				=	0;
 534               		.loc 1 642 0
 535 01c0 212C      		mov r2,__zero_reg__
 536 01c2 312C      		mov r3,__zero_reg__
 640:bootSAH_2.c   **** 							checksum		^=	c;
 537               		.loc 1 640 0
 538 01c4 85E0      		ldi r24,lo8(5)
 539 01c6 00C0      		rjmp .L37
 540               	.LVL50:
 541               	.L32:
 643:bootSAH_2.c   **** 						}
 644:bootSAH_2.c   **** 						else
 645:bootSAH_2.c   **** 						{
 646:bootSAH_2.c   **** 							msgParseState	=	ST_START;
 647:bootSAH_2.c   **** 						}
 648:bootSAH_2.c   **** 						break;
 649:bootSAH_2.c   **** 
 650:bootSAH_2.c   **** 					case ST_GET_DATA:
 651:bootSAH_2.c   **** 						msgBuffer[ii++]	=	c;
 542               		.loc 1 651 0
 543 01c8 A101      		movw r20,r2
 544 01ca 4F5F      		subi r20,-1
 545 01cc 5F4F      		sbci r21,-1
 546               	.LVL51:
 547 01ce E1E0      		ldi r30,lo8(1)
 548 01d0 F0E0      		ldi r31,0
 549 01d2 EC0F      		add r30,r28
 550 01d4 FD1F      		adc r31,r29
 551 01d6 E20D      		add r30,r2
 552 01d8 F31D      		adc r31,r3
 553 01da 9083      		st Z,r25
 652:bootSAH_2.c   **** 						checksum		^=	c;
 554               		.loc 1 652 0
 555 01dc D926      		eor r13,r25
 556               	.LVL52:
 653:bootSAH_2.c   **** 						if (ii == msgLength )
 557               		.loc 1 653 0
 558 01de 2417      		cp r18,r20
 559 01e0 3507      		cpc r19,r21
 560 01e2 01F4      		brne .+2
 561 01e4 00C0      		rjmp .L86
 562 01e6 1A01      		movw r2,r20
 563 01e8 00C0      		rjmp .L37
 564               	.LVL53:
 565               	.L34:
 654:bootSAH_2.c   **** 						{
 655:bootSAH_2.c   **** 							msgParseState	=	ST_GET_CHECK;
 656:bootSAH_2.c   **** 						}
 657:bootSAH_2.c   **** 						break;
 658:bootSAH_2.c   **** 
 659:bootSAH_2.c   **** 					case ST_GET_CHECK:
 660:bootSAH_2.c   **** 						if ( c == checksum )
 566               		.loc 1 660 0
 567 01ea 9D11      		cpse r25,r13
 568 01ec 00C0      		rjmp .L85
 569 01ee 00C0      		rjmp .L36
 570               	.L136:
 571               	.LVL54:
 561:bootSAH_2.c   **** 			{
 572               		.loc 1 561 0
 573 01f0 8730      		cpi r24,lo8(7)
 574 01f2 01F4      		brne .L37
 575               	.LVL55:
 576               	.L36:
 661:bootSAH_2.c   **** 						{
 662:bootSAH_2.c   **** 							msgParseState	=	ST_PROCESS;
 663:bootSAH_2.c   **** 						}
 664:bootSAH_2.c   **** 						else
 665:bootSAH_2.c   **** 						{
 666:bootSAH_2.c   **** 							msgParseState	=	ST_START;
 667:bootSAH_2.c   **** 						}
 668:bootSAH_2.c   **** 						break;
 669:bootSAH_2.c   **** 				}	//	switch
 670:bootSAH_2.c   **** 			}	//	while(msgParseState)
 671:bootSAH_2.c   **** 
 672:bootSAH_2.c   **** 			/*
 673:bootSAH_2.c   **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 674:bootSAH_2.c   **** 			 */
 675:bootSAH_2.c   **** 
 676:bootSAH_2.c   **** 			switch (msgBuffer[0])
 577               		.loc 1 676 0
 578 01f4 2981      		ldd r18,Y+1
 579 01f6 2331      		cpi r18,lo8(19)
 580 01f8 01F4      		brne .+2
 581 01fa 00C0      		rjmp .L39
 582 01fc 00F4      		brsh .L40
 583 01fe 2630      		cpi r18,lo8(6)
 584 0200 01F4      		brne .+2
 585 0202 00C0      		rjmp .L41
 586 0204 00F4      		brsh .L42
 587 0206 2230      		cpi r18,lo8(2)
 588 0208 01F0      		breq .L43
 589 020a 2330      		cpi r18,lo8(3)
 590 020c 01F4      		brne .+2
 591 020e 00C0      		rjmp .L44
 592 0210 2130      		cpi r18,lo8(1)
 593 0212 01F0      		breq .+2
 594 0214 00C0      		rjmp .L38
 595               	.LVL56:
 677:bootSAH_2.c   **** 			{
 678:bootSAH_2.c   **** 	#ifndef REMOVE_CMD_SPI_MULTI
 679:bootSAH_2.c   **** 				case CMD_SPI_MULTI:
 680:bootSAH_2.c   **** 					{
 681:bootSAH_2.c   **** 						unsigned char answerByte;
 682:bootSAH_2.c   **** 						unsigned char flag=0;
 683:bootSAH_2.c   **** 
 684:bootSAH_2.c   **** 						if ( msgBuffer[4]== 0x30 )
 685:bootSAH_2.c   **** 						{
 686:bootSAH_2.c   **** 							unsigned char signatureIndex	=	msgBuffer[6];
 687:bootSAH_2.c   **** 
 688:bootSAH_2.c   **** 							if ( signatureIndex == 0 )
 689:bootSAH_2.c   **** 							{
 690:bootSAH_2.c   **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 691:bootSAH_2.c   **** 							}
 692:bootSAH_2.c   **** 							else if ( signatureIndex == 1 )
 693:bootSAH_2.c   **** 							{
 694:bootSAH_2.c   **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 695:bootSAH_2.c   **** 							}
 696:bootSAH_2.c   **** 							else
 697:bootSAH_2.c   **** 							{
 698:bootSAH_2.c   **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 699:bootSAH_2.c   **** 							}
 700:bootSAH_2.c   **** 						}
 701:bootSAH_2.c   **** 						else if ( msgBuffer[4] & 0x50 )
 702:bootSAH_2.c   **** 						{
 703:bootSAH_2.c   **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 704:bootSAH_2.c   **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 705:bootSAH_2.c   **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 706:bootSAH_2.c   **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 707:bootSAH_2.c   **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 708:bootSAH_2.c   **** 							if (msgBuffer[4] == 0x50)
 709:bootSAH_2.c   **** 							{
 710:bootSAH_2.c   **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 711:bootSAH_2.c   **** 							}
 712:bootSAH_2.c   **** 							else if (msgBuffer[4] == 0x58)
 713:bootSAH_2.c   **** 							{
 714:bootSAH_2.c   **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 715:bootSAH_2.c   **** 							}
 716:bootSAH_2.c   **** 							else
 717:bootSAH_2.c   **** 							{
 718:bootSAH_2.c   **** 								answerByte	=	0;
 719:bootSAH_2.c   **** 							}
 720:bootSAH_2.c   **** 						}
 721:bootSAH_2.c   **** 						else
 722:bootSAH_2.c   **** 						{
 723:bootSAH_2.c   **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 724:bootSAH_2.c   **** 						}
 725:bootSAH_2.c   **** 						if ( !flag )
 726:bootSAH_2.c   **** 						{
 727:bootSAH_2.c   **** 							msgLength		=	7;
 728:bootSAH_2.c   **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 729:bootSAH_2.c   **** 							msgBuffer[2]	=	0;
 730:bootSAH_2.c   **** 							msgBuffer[3]	=	msgBuffer[4];
 731:bootSAH_2.c   **** 							msgBuffer[4]	=	0;
 732:bootSAH_2.c   **** 							msgBuffer[5]	=	answerByte;
 733:bootSAH_2.c   **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 734:bootSAH_2.c   **** 						}
 735:bootSAH_2.c   **** 					}
 736:bootSAH_2.c   **** 					break;
 737:bootSAH_2.c   **** 	#endif
 738:bootSAH_2.c   **** 				case CMD_SIGN_ON:
 739:bootSAH_2.c   **** 					msgLength		=	11;
 740:bootSAH_2.c   **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 596               		.loc 1 740 0
 597 0216 1A82      		std Y+2,__zero_reg__
 741:bootSAH_2.c   **** 					msgBuffer[2] 	=	8;
 598               		.loc 1 741 0
 599 0218 88E0      		ldi r24,lo8(8)
 600 021a 8B83      		std Y+3,r24
 742:bootSAH_2.c   **** 					msgBuffer[3] 	=	'A';
 601               		.loc 1 742 0
 602 021c 81E4      		ldi r24,lo8(65)
 603 021e 8C83      		std Y+4,r24
 743:bootSAH_2.c   **** 					msgBuffer[4] 	=	'V';
 604               		.loc 1 743 0
 605 0220 86E5      		ldi r24,lo8(86)
 606 0222 8D83      		std Y+5,r24
 744:bootSAH_2.c   **** 					msgBuffer[5] 	=	'R';
 607               		.loc 1 744 0
 608 0224 82E5      		ldi r24,lo8(82)
 609 0226 8E83      		std Y+6,r24
 745:bootSAH_2.c   **** 					msgBuffer[6] 	=	'I';
 610               		.loc 1 745 0
 611 0228 89E4      		ldi r24,lo8(73)
 612 022a 8F83      		std Y+7,r24
 746:bootSAH_2.c   **** 					msgBuffer[7] 	=	'S';
 613               		.loc 1 746 0
 614 022c 83E5      		ldi r24,lo8(83)
 615 022e 8887      		std Y+8,r24
 747:bootSAH_2.c   **** 					msgBuffer[8] 	=	'P';
 616               		.loc 1 747 0
 617 0230 80E5      		ldi r24,lo8(80)
 618 0232 8987      		std Y+9,r24
 748:bootSAH_2.c   **** 					msgBuffer[9] 	=	'_';
 619               		.loc 1 748 0
 620 0234 8FE5      		ldi r24,lo8(95)
 621 0236 8A87      		std Y+10,r24
 749:bootSAH_2.c   **** 					msgBuffer[10]	=	'2';
 622               		.loc 1 749 0
 623 0238 82E3      		ldi r24,lo8(50)
 624 023a 8B87      		std Y+11,r24
 750:bootSAH_2.c   **** 					break;
 625               		.loc 1 750 0
 626 023c C12C      		mov r12,__zero_reg__
 739:bootSAH_2.c   **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 627               		.loc 1 739 0
 628 023e 0BE0      		ldi r16,lo8(11)
 629 0240 10E0      		ldi r17,0
 630               		.loc 1 750 0
 631 0242 00C0      		rjmp .L58
 632               	.LVL57:
 633               	.L42:
 676:bootSAH_2.c   **** 			{
 634               		.loc 1 676 0
 635 0244 2131      		cpi r18,lo8(17)
 636 0246 01F4      		brne .+2
 637 0248 00C0      		rjmp .L87
 638 024a 00F0      		brlo .+2
 639 024c 00C0      		rjmp .L47
 640 024e 2031      		cpi r18,lo8(16)
 641 0250 01F0      		breq .L43
 642 0252 00C0      		rjmp .L38
 643               	.L40:
 644 0254 2831      		cpi r18,lo8(24)
 645 0256 01F4      		brne .+2
 646 0258 00C0      		rjmp .L48
 647 025a 00F4      		brsh .L49
 648 025c 2531      		cpi r18,lo8(21)
 649 025e 01F4      		brne .+2
 650 0260 00C0      		rjmp .L39
 651 0262 00F4      		brsh .+2
 652 0264 00C0      		rjmp .L50
 653 0266 2631      		cpi r18,lo8(22)
 654 0268 01F4      		brne .+2
 655 026a 00C0      		rjmp .L50
 656 026c 00C0      		rjmp .L38
 657               	.L49:
 658 026e 2A31      		cpi r18,lo8(26)
 659 0270 01F4      		brne .+2
 660 0272 00C0      		rjmp .L51
 661 0274 00F4      		brsh .+2
 662 0276 00C0      		rjmp .L52
 663 0278 2B31      		cpi r18,lo8(27)
 664 027a 01F4      		brne .+2
 665 027c 00C0      		rjmp .L53
 666 027e 2D31      		cpi r18,lo8(29)
 667 0280 01F0      		breq .L54
 668 0282 00C0      		rjmp .L38
 669               	.L43:
 670 0284 C12C      		mov r12,__zero_reg__
 671 0286 00C0      		rjmp .L46
 672               	.L54:
 673               	.LVL58:
 674               	.LBB82:
 684:bootSAH_2.c   **** 						{
 675               		.loc 1 684 0
 676 0288 9D81      		ldd r25,Y+5
 677               	.LVL59:
 678 028a 9033      		cpi r25,lo8(48)
 679 028c 01F4      		brne .L55
 680               	.LBB83:
 686:bootSAH_2.c   **** 
 681               		.loc 1 686 0
 682 028e 8F81      		ldd r24,Y+7
 683               	.LVL60:
 688:bootSAH_2.c   **** 							{
 684               		.loc 1 688 0
 685 0290 8823      		tst r24
 686 0292 01F0      		breq .L88
 692:bootSAH_2.c   **** 							{
 687               		.loc 1 692 0
 688 0294 8130      		cpi r24,lo8(1)
 689 0296 01F4      		brne .L89
 694:bootSAH_2.c   **** 							}
 690               		.loc 1 694 0
 691 0298 88E9      		ldi r24,lo8(-104)
 692               	.LVL61:
 693 029a 00C0      		rjmp .L56
 694               	.LVL62:
 695               	.L55:
 696               	.LBE83:
 701:bootSAH_2.c   **** 						{
 697               		.loc 1 701 0
 698 029c 892F      		mov r24,r25
 699 029e 8075      		andi r24,lo8(80)
 700 02a0 01F0      		breq .L91
 708:bootSAH_2.c   **** 							{
 701               		.loc 1 708 0
 702 02a2 9035      		cpi r25,lo8(80)
 703 02a4 01F4      		brne .L57
 704               	.LBB84:
 710:bootSAH_2.c   **** 							}
 705               		.loc 1 710 0
 706 02a6 89E0      		ldi r24,lo8(9)
 707 02a8 E0E0      		ldi r30,0
 708 02aa F0E0      		ldi r31,0
 709 02ac 00C0      		rjmp .L127
 710               	.L57:
 711               	.LBE84:
 712:bootSAH_2.c   **** 							{
 712               		.loc 1 712 0
 713 02ae 9835      		cpi r25,lo8(88)
 714 02b0 01F4      		brne .L91
 715               	.LBB85:
 714:bootSAH_2.c   **** 							}
 716               		.loc 1 714 0
 717 02b2 E3E0      		ldi r30,lo8(3)
 718 02b4 F0E0      		ldi r31,0
 719 02b6 89E0      		ldi r24,lo8(9)
 720               	.L127:
 721               	/* #APP */
 722               	 ;  714 "bootSAH_2.c" 1
 723 02b8 8093 5700 		sts 87, r24
 724 02bc 8491      		lpm r24, Z
 725               		
 726               	 ;  0 "" 2
 727               	.LVL63:
 728               	/* #NOAPP */
 729               	.LBE85:
 730 02be 00C0      		rjmp .L56
 731               	.LVL64:
 732               	.L88:
 733               	.LBB86:
 690:bootSAH_2.c   **** 							}
 734               		.loc 1 690 0
 735 02c0 8EE1      		ldi r24,lo8(30)
 736               	.LVL65:
 737 02c2 00C0      		rjmp .L56
 738               	.LVL66:
 739               	.L89:
 698:bootSAH_2.c   **** 							}
 740               		.loc 1 698 0
 741 02c4 81E0      		ldi r24,lo8(1)
 742               	.LVL67:
 743 02c6 00C0      		rjmp .L56
 744               	.LVL68:
 745               	.L91:
 746               	.LBE86:
 723:bootSAH_2.c   **** 						}
 747               		.loc 1 723 0
 748 02c8 80E0      		ldi r24,0
 749               	.L56:
 750               	.LVL69:
 728:bootSAH_2.c   **** 							msgBuffer[2]	=	0;
 751               		.loc 1 728 0
 752 02ca 1A82      		std Y+2,__zero_reg__
 729:bootSAH_2.c   **** 							msgBuffer[3]	=	msgBuffer[4];
 753               		.loc 1 729 0
 754 02cc 1B82      		std Y+3,__zero_reg__
 730:bootSAH_2.c   **** 							msgBuffer[4]	=	0;
 755               		.loc 1 730 0
 756 02ce 9C83      		std Y+4,r25
 731:bootSAH_2.c   **** 							msgBuffer[5]	=	answerByte;
 757               		.loc 1 731 0
 758 02d0 1D82      		std Y+5,__zero_reg__
 732:bootSAH_2.c   **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 759               		.loc 1 732 0
 760 02d2 8E83      		std Y+6,r24
 733:bootSAH_2.c   **** 						}
 761               		.loc 1 733 0
 762 02d4 1F82      		std Y+7,__zero_reg__
 763 02d6 C12C      		mov r12,__zero_reg__
 727:bootSAH_2.c   **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 764               		.loc 1 727 0
 765 02d8 07E0      		ldi r16,lo8(7)
 766 02da 10E0      		ldi r17,0
 767 02dc 00C0      		rjmp .L58
 768               	.LVL70:
 769               	.L44:
 770 02de EA81      		ldd r30,Y+2
 771 02e0 E059      		subi r30,lo8(-(112))
 772 02e2 E330      		cpi r30,lo8(3)
 773 02e4 00F4      		brsh .L92
 774 02e6 F0E0      		ldi r31,0
 775 02e8 E050      		subi r30,lo8(-(CSWTCH.27))
 776 02ea F040      		sbci r31,hi8(-(CSWTCH.27))
 777 02ec 8081      		ld r24,Z
 778 02ee 00C0      		rjmp .L59
 779               	.L92:
 780               	.LBE82:
 781               	.LBB87:
 751:bootSAH_2.c   **** 
 752:bootSAH_2.c   **** 				case CMD_GET_PARAMETER:
 753:bootSAH_2.c   **** 					{
 754:bootSAH_2.c   **** 						unsigned char value;
 755:bootSAH_2.c   **** 
 756:bootSAH_2.c   **** 						switch(msgBuffer[1])
 782               		.loc 1 756 0
 783 02f0 80E0      		ldi r24,0
 784               	.L59:
 785               	.LVL71:
 757:bootSAH_2.c   **** 						{
 758:bootSAH_2.c   **** 						case PARAM_BUILD_NUMBER_LOW:
 759:bootSAH_2.c   **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 760:bootSAH_2.c   **** 							break;
 761:bootSAH_2.c   **** 						case PARAM_BUILD_NUMBER_HIGH:
 762:bootSAH_2.c   **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 763:bootSAH_2.c   **** 							break;
 764:bootSAH_2.c   **** 						case PARAM_HW_VER:
 765:bootSAH_2.c   **** 							value	=	CONFIG_PARAM_HW_VER;
 766:bootSAH_2.c   **** 							break;
 767:bootSAH_2.c   **** 						case PARAM_SW_MAJOR:
 768:bootSAH_2.c   **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 769:bootSAH_2.c   **** 							break;
 770:bootSAH_2.c   **** 						case PARAM_SW_MINOR:
 771:bootSAH_2.c   **** 							value	=	CONFIG_PARAM_SW_MINOR;
 772:bootSAH_2.c   **** 							break;
 773:bootSAH_2.c   **** 						default:
 774:bootSAH_2.c   **** 							value	=	0;
 775:bootSAH_2.c   **** 							break;
 776:bootSAH_2.c   **** 						}
 777:bootSAH_2.c   **** 						msgLength		=	3;
 778:bootSAH_2.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 786               		.loc 1 778 0
 787 02f2 1A82      		std Y+2,__zero_reg__
 779:bootSAH_2.c   **** 						msgBuffer[2]	=	value;
 788               		.loc 1 779 0
 789 02f4 8B83      		std Y+3,r24
 790 02f6 00C0      		rjmp .L130
 791               	.LVL72:
 792               	.L87:
 793               	.LBE87:
 780:bootSAH_2.c   **** 					}
 781:bootSAH_2.c   **** 					break;
 782:bootSAH_2.c   **** 
 783:bootSAH_2.c   **** 				case CMD_LEAVE_PROGMODE_ISP:
 784:bootSAH_2.c   **** 					isLeave	=	1;
 794               		.loc 1 784 0
 795 02f8 CC24      		clr r12
 796 02fa C394      		inc r12
 797               	.L46:
 798               	.LVL73:
 785:bootSAH_2.c   **** 					//*	fall thru
 786:bootSAH_2.c   **** 
 787:bootSAH_2.c   **** 				case CMD_SET_PARAMETER:
 788:bootSAH_2.c   **** 				case CMD_ENTER_PROGMODE_ISP:
 789:bootSAH_2.c   **** 					msgLength		=	2;
 790:bootSAH_2.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 799               		.loc 1 790 0
 800 02fc 1A82      		std Y+2,__zero_reg__
 801 02fe 00C0      		rjmp .L131
 802               	.LVL74:
 803               	.L53:
 804               	.LBB88:
 791:bootSAH_2.c   **** 					break;
 792:bootSAH_2.c   **** 
 793:bootSAH_2.c   **** 				case CMD_READ_SIGNATURE_ISP:
 794:bootSAH_2.c   **** 					{
 795:bootSAH_2.c   **** 						unsigned char signatureIndex	=	msgBuffer[4];
 805               		.loc 1 795 0
 806 0300 8D81      		ldd r24,Y+5
 807               	.LVL75:
 796:bootSAH_2.c   **** 						unsigned char signature;
 797:bootSAH_2.c   **** 
 798:bootSAH_2.c   **** 						if ( signatureIndex == 0 )
 808               		.loc 1 798 0
 809 0302 8823      		tst r24
 810 0304 01F0      		breq .L93
 799:bootSAH_2.c   **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 800:bootSAH_2.c   **** 						else if ( signatureIndex == 1 )
 811               		.loc 1 800 0
 812 0306 8130      		cpi r24,lo8(1)
 813 0308 01F4      		brne .L94
 801:bootSAH_2.c   **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 814               		.loc 1 801 0
 815 030a 88E9      		ldi r24,lo8(-104)
 816               	.LVL76:
 817 030c 00C0      		rjmp .L134
 818               	.LVL77:
 819               	.L93:
 799:bootSAH_2.c   **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 820               		.loc 1 799 0
 821 030e 8EE1      		ldi r24,lo8(30)
 822               	.LVL78:
 823 0310 00C0      		rjmp .L134
 824               	.LVL79:
 825               	.L94:
 802:bootSAH_2.c   **** 						else
 803:bootSAH_2.c   **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 826               		.loc 1 803 0
 827 0312 81E0      		ldi r24,lo8(1)
 828               	.LVL80:
 829 0314 00C0      		rjmp .L134
 830               	.LVL81:
 831               	.L51:
 832               	.LBE88:
 804:bootSAH_2.c   **** 
 805:bootSAH_2.c   **** 						msgLength		=	4;
 806:bootSAH_2.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 807:bootSAH_2.c   **** 						msgBuffer[2]	=	signature;
 808:bootSAH_2.c   **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 809:bootSAH_2.c   **** 					}
 810:bootSAH_2.c   **** 					break;
 811:bootSAH_2.c   **** 
 812:bootSAH_2.c   **** 				case CMD_READ_LOCK_ISP:
 813:bootSAH_2.c   **** 					msgLength		=	4;
 814:bootSAH_2.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 833               		.loc 1 814 0
 834 0316 1A82      		std Y+2,__zero_reg__
 835               	.LBB89:
 815:bootSAH_2.c   **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 836               		.loc 1 815 0
 837 0318 E1E0      		ldi r30,lo8(1)
 838 031a F0E0      		ldi r31,0
 839 031c 89E0      		ldi r24,lo8(9)
 840               	/* #APP */
 841               	 ;  815 "bootSAH_2.c" 1
 842 031e 8093 5700 		sts 87, r24
 843 0322 8491      		lpm r24, Z
 844               		
 845               	 ;  0 "" 2
 846               	/* #NOAPP */
 847               	.L133:
 848               	.LVL82:
 849               	.LBE89:
 850 0324 8B83      		std Y+3,r24
 816:bootSAH_2.c   **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 851               		.loc 1 816 0
 852 0326 1C82      		std Y+4,__zero_reg__
 817:bootSAH_2.c   **** 					break;
 853               		.loc 1 817 0
 854 0328 C12C      		mov r12,__zero_reg__
 813:bootSAH_2.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 855               		.loc 1 813 0
 856 032a 04E0      		ldi r16,lo8(4)
 857 032c 10E0      		ldi r17,0
 858               		.loc 1 817 0
 859 032e 00C0      		rjmp .L58
 860               	.LVL83:
 861               	.L48:
 862               	.LBB90:
 818:bootSAH_2.c   **** 
 819:bootSAH_2.c   **** 				case CMD_READ_FUSE_ISP:
 820:bootSAH_2.c   **** 					{
 821:bootSAH_2.c   **** 						unsigned char fuseBits;
 822:bootSAH_2.c   **** 
 823:bootSAH_2.c   **** 						if ( msgBuffer[2] == 0x50 )
 863               		.loc 1 823 0
 864 0330 8B81      		ldd r24,Y+3
 865 0332 8035      		cpi r24,lo8(80)
 866 0334 01F4      		brne .L61
 824:bootSAH_2.c   **** 						{
 825:bootSAH_2.c   **** 							if ( msgBuffer[3] == 0x08 )
 867               		.loc 1 825 0
 868 0336 8C81      		ldd r24,Y+4
 869 0338 8830      		cpi r24,lo8(8)
 870 033a 01F4      		brne .L62
 871               	.LBB91:
 826:bootSAH_2.c   **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 872               		.loc 1 826 0
 873 033c E2E0      		ldi r30,lo8(2)
 874 033e F0E0      		ldi r31,0
 875 0340 00C0      		rjmp .L128
 876               	.L62:
 877               	.LBE91:
 878               	.LBB92:
 827:bootSAH_2.c   **** 							else
 828:bootSAH_2.c   **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 879               		.loc 1 828 0
 880 0342 89E0      		ldi r24,lo8(9)
 881 0344 E0E0      		ldi r30,0
 882 0346 F0E0      		ldi r31,0
 883 0348 00C0      		rjmp .L129
 884               	.L61:
 885               	.LBE92:
 886               	.LBB93:
 829:bootSAH_2.c   **** 						}
 830:bootSAH_2.c   **** 						else
 831:bootSAH_2.c   **** 						{
 832:bootSAH_2.c   **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 887               		.loc 1 832 0
 888 034a E3E0      		ldi r30,lo8(3)
 889 034c F0E0      		ldi r31,0
 890               	.L128:
 891 034e 89E0      		ldi r24,lo8(9)
 892               	.L129:
 893               	/* #APP */
 894               	 ;  832 "bootSAH_2.c" 1
 895 0350 8093 5700 		sts 87, r24
 896 0354 8491      		lpm r24, Z
 897               		
 898               	 ;  0 "" 2
 899               	.LVL84:
 900               	/* #NOAPP */
 901               	.L134:
 902               	.LBE93:
 833:bootSAH_2.c   **** 						}
 834:bootSAH_2.c   **** 						msgLength		=	4;
 835:bootSAH_2.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 903               		.loc 1 835 0
 904 0356 1A82      		std Y+2,__zero_reg__
 905 0358 00C0      		rjmp .L133
 906               	.LVL85:
 907               	.L52:
 908               	.LBE90:
 909               	.LBB94:
 836:bootSAH_2.c   **** 						msgBuffer[2]	=	fuseBits;
 837:bootSAH_2.c   **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 838:bootSAH_2.c   **** 					}
 839:bootSAH_2.c   **** 					break;
 840:bootSAH_2.c   **** 
 841:bootSAH_2.c   **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 842:bootSAH_2.c   **** 				case CMD_PROGRAM_LOCK_ISP:
 843:bootSAH_2.c   **** 					{
 844:bootSAH_2.c   **** 						unsigned char lockBits	=	msgBuffer[4];
 845:bootSAH_2.c   **** 
 846:bootSAH_2.c   **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 910               		.loc 1 846 0
 911 035a 8D81      		ldd r24,Y+5
 912               	.LVL86:
 913               	.LBB95:
 847:bootSAH_2.c   **** 						boot_lock_bits_set(lockBits);		// and program it
 914               		.loc 1 847 0
 915 035c 836C      		ori r24,lo8(-61)
 916               	.LVL87:
 917 035e 99E0      		ldi r25,lo8(9)
 918               	.LVL88:
 919               	/* #APP */
 920               	 ;  847 "bootSAH_2.c" 1
 921 0360 E1E0      		ldi r30, 1
 922 0362 F0E0      		ldi r31, 0
 923 0364 082E      		mov r0, r24
 924 0366 9093 5700 		sts 87, r25
 925 036a E895      		spm
 926               		
 927               	 ;  0 "" 2
 928               	/* #NOAPP */
 929               	.L64:
 930               	.LBE95:
 848:bootSAH_2.c   **** 						boot_spm_busy_wait();
 931               		.loc 1 848 0 discriminator 1
 932 036c 07B6      		in __tmp_reg__,0x37
 933 036e 00FC      		sbrc __tmp_reg__,0
 934 0370 00C0      		rjmp .L64
 935               	.LVL89:
 849:bootSAH_2.c   **** 
 850:bootSAH_2.c   **** 						msgLength		=	3;
 851:bootSAH_2.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 936               		.loc 1 851 0
 937 0372 1A82      		std Y+2,__zero_reg__
 852:bootSAH_2.c   **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 938               		.loc 1 852 0
 939 0374 1B82      		std Y+3,__zero_reg__
 940               	.LVL90:
 941               	.L130:
 942               	.LBE94:
 853:bootSAH_2.c   **** 					}
 854:bootSAH_2.c   **** 					break;
 943               		.loc 1 854 0
 944 0376 C12C      		mov r12,__zero_reg__
 945               	.LBB96:
 850:bootSAH_2.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 946               		.loc 1 850 0
 947 0378 03E0      		ldi r16,lo8(3)
 948 037a 10E0      		ldi r17,0
 949               	.LBE96:
 950               		.loc 1 854 0
 951 037c 00C0      		rjmp .L58
 952               	.LVL91:
 953               	.L47:
 855:bootSAH_2.c   **** 	#endif
 856:bootSAH_2.c   **** 				case CMD_CHIP_ERASE_ISP:
 857:bootSAH_2.c   **** 					eraseAddress	=	0;
 858:bootSAH_2.c   **** 					msgLength		=	2;
 859:bootSAH_2.c   **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 860:bootSAH_2.c   **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 954               		.loc 1 860 0
 955 037e 80EC      		ldi r24,lo8(-64)
 956 0380 8A83      		std Y+2,r24
 861:bootSAH_2.c   **** 					break;
 957               		.loc 1 861 0
 958 0382 C12C      		mov r12,__zero_reg__
 858:bootSAH_2.c   **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 959               		.loc 1 858 0
 960 0384 02E0      		ldi r16,lo8(2)
 961 0386 10E0      		ldi r17,0
 857:bootSAH_2.c   **** 					msgLength		=	2;
 962               		.loc 1 857 0
 963 0388 812C      		mov r8,__zero_reg__
 964 038a 912C      		mov r9,__zero_reg__
 965 038c 5401      		movw r10,r8
 966               		.loc 1 861 0
 967 038e 00C0      		rjmp .L58
 968               	.LVL92:
 969               	.L41:
 970 0390 6A81      		ldd r22,Y+2
 971 0392 7B81      		ldd r23,Y+3
 972 0394 8C81      		ldd r24,Y+4
 973 0396 9D81      		ldd r25,Y+5
 974 0398 0E94 0000 		call __bswapsi2
 862:bootSAH_2.c   **** 
 863:bootSAH_2.c   **** 				case CMD_LOAD_ADDRESS:
 864:bootSAH_2.c   **** 	#if defined(RAMPZ)
 865:bootSAH_2.c   **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 975               		.loc 1 865 0
 976 039c 2B01      		movw r4,r22
 977 039e 3C01      		movw r6,r24
 978               	.LVL93:
 979 03a0 440C      		lsl r4
 980 03a2 551C      		rol r5
 981 03a4 661C      		rol r6
 982 03a6 771C      		rol r7
 983               	.LVL94:
 866:bootSAH_2.c   **** 	#else
 867:bootSAH_2.c   **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 868:bootSAH_2.c   **** 	#endif
 869:bootSAH_2.c   **** 			
 870:bootSAH_2.c   **** 					msgLength		=	2;
 871:bootSAH_2.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 984               		.loc 1 871 0
 985 03a8 1A82      		std Y+2,__zero_reg__
 986 03aa 00C0      		rjmp .L132
 987               	.LVL95:
 988               	.L39:
 989 03ac EA80      		ldd r14,Y+2
 990 03ae FB80      		ldd r15,Y+3
 991 03b0 FE24      		eor r15,r14
 992 03b2 EF24      		eor r14,r15
 993 03b4 FE24      		eor r15,r14
 994               	.LVL96:
 995               	.LBB97:
 872:bootSAH_2.c   **** 					break;
 873:bootSAH_2.c   **** 
 874:bootSAH_2.c   **** 				case CMD_PROGRAM_FLASH_ISP:
 875:bootSAH_2.c   **** 				case CMD_PROGRAM_EEPROM_ISP:
 876:bootSAH_2.c   **** 					{
 877:bootSAH_2.c   **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 878:bootSAH_2.c   **** 						unsigned char	*p	=	msgBuffer+10;
 879:bootSAH_2.c   **** 						unsigned int	data;
 880:bootSAH_2.c   **** 						unsigned char	highByte, lowByte;
 881:bootSAH_2.c   **** 						address_t		tempaddress	=	address;
 882:bootSAH_2.c   **** 
 883:bootSAH_2.c   **** 
 884:bootSAH_2.c   **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 996               		.loc 1 884 0
 997 03b6 2331      		cpi r18,lo8(19)
 998 03b8 01F0      		breq .+2
 999 03ba 00C0      		rjmp .L65
 885:bootSAH_2.c   **** 						{
 886:bootSAH_2.c   **** 							// erase only main section (bootloader protection)
 887:bootSAH_2.c   **** 							if (eraseAddress < APP_END )
 1000               		.loc 1 887 0
 1001 03bc 8114      		cp r8,__zero_reg__
 1002 03be F0EC      		ldi r31,-64
 1003 03c0 9F06      		cpc r9,r31
 1004 03c2 F3E0      		ldi r31,3
 1005 03c4 AF06      		cpc r10,r31
 1006 03c6 B104      		cpc r11,__zero_reg__
 1007 03c8 00F4      		brsh .L66
 888:bootSAH_2.c   **** 							{
 889:bootSAH_2.c   **** 								boot_page_erase(eraseAddress);	// Perform page erase
 1008               		.loc 1 889 0
 1009 03ca 23E0      		ldi r18,lo8(3)
 1010               	/* #APP */
 1011               	 ;  889 "bootSAH_2.c" 1
 1012 03cc F401      		movw r30, r8
 1013 03ce A092 5B00 		sts  91, r10
 1014 03d2 2093 5700 		sts 87, r18
 1015 03d6 E895      		spm
 1016               		
 1017               	 ;  0 "" 2
 1018               	/* #NOAPP */
 1019               	.L67:
 890:bootSAH_2.c   **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 1020               		.loc 1 890 0 discriminator 1
 1021 03d8 07B6      		in __tmp_reg__,0x37
 1022 03da 00FC      		sbrc __tmp_reg__,0
 1023 03dc 00C0      		rjmp .L67
 891:bootSAH_2.c   **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 1024               		.loc 1 891 0
 1025 03de 4FEF      		ldi r20,-1
 1026 03e0 941A      		sub r9,r20
 1027 03e2 A40A      		sbc r10,r20
 1028 03e4 B40A      		sbc r11,r20
 1029               	.LVL97:
 1030               	.L66:
 1031 03e6 8B85      		ldd r24,Y+11
 1032 03e8 DE01      		movw r26,r28
 1033 03ea 1196      		adiw r26,1
 1034               	.LBE97:
 1035               	.LBB99:
 803:bootSAH_2.c   **** 
 1036               		.loc 1 803 0 discriminator 1
 1037 03ec 9301      		movw r18,r6
 1038 03ee 8201      		movw r16,r4
 1039               	.LVL98:
 1040               	.L69:
 1041               	.LBE99:
 1042               	.LBB100:
 892:bootSAH_2.c   **** 							}
 893:bootSAH_2.c   **** 
 894:bootSAH_2.c   **** 							/* Write FLASH */
 895:bootSAH_2.c   **** 							do {
 896:bootSAH_2.c   **** 								lowByte		=	*p++;
 897:bootSAH_2.c   **** 								highByte 	=	*p++;
 898:bootSAH_2.c   **** 
 899:bootSAH_2.c   **** 								data		=	(highByte << 8) | lowByte;
 900:bootSAH_2.c   **** 								boot_page_fill(address,data);
 1043               		.loc 1 900 0 discriminator 1
 1044 03f0 1B96      		adiw r26,11
 1045 03f2 4C91      		ld r20,X
 1046 03f4 1B97      		sbiw r26,11
 1047 03f6 90E0      		ldi r25,0
 1048 03f8 942B      		or r25,r20
 1049 03fa 41E0      		ldi r20,lo8(1)
 1050               	/* #APP */
 1051               	 ;  900 "bootSAH_2.c" 1
 1052 03fc 0C01      		movw  r0, r24
 1053 03fe F801      		movw r30, r16
 1054 0400 2093 5B00 		sts 91, r18
 1055 0404 4093 5700 		sts 87, r20
 1056 0408 E895      		spm
 1057 040a 1124      		clr  r1
 1058               		
 1059               	 ;  0 "" 2
 901:bootSAH_2.c   **** 
 902:bootSAH_2.c   **** 								address	=	address + 2;	// Select next word in memory
 1060               		.loc 1 902 0 discriminator 1
 1061               	/* #NOAPP */
 1062 040c 0E5F      		subi r16,-2
 1063 040e 1F4F      		sbci r17,-1
 1064 0410 2F4F      		sbci r18,-1
 1065 0412 3F4F      		sbci r19,-1
 1066               	.LVL99:
 903:bootSAH_2.c   **** 								size	-=	2;				// Reduce number of bytes to write by two
 1067               		.loc 1 903 0 discriminator 1
 1068 0414 82E0      		ldi r24,2
 1069 0416 E81A      		sub r14,r24
 1070 0418 F108      		sbc r15,__zero_reg__
 1071               	.LVL100:
 1072 041a 1296      		adiw r26,2
 1073               	.LVL101:
 904:bootSAH_2.c   **** 							} while (size);					// Loop until all bytes written
 1074               		.loc 1 904 0 discriminator 1
 1075 041c E114      		cp r14,__zero_reg__
 1076 041e F104      		cpc r15,__zero_reg__
 1077 0420 01F0      		breq .L68
 897:bootSAH_2.c   **** 
 1078               		.loc 1 897 0
 1079 0422 1A96      		adiw r26,10
 1080 0424 8C91      		ld r24,X
 1081 0426 1A97      		sbiw r26,10
 1082 0428 00C0      		rjmp .L69
 1083               	.L68:
 905:bootSAH_2.c   **** 
 906:bootSAH_2.c   **** 							boot_page_write(tempaddress);
 1084               		.loc 1 906 0
 1085 042a 95E0      		ldi r25,lo8(5)
 1086               	/* #APP */
 1087               	 ;  906 "bootSAH_2.c" 1
 1088 042c F201      		movw r30, r4
 1089 042e 6092 5B00 		sts 91, r6
 1090 0432 9093 5700 		sts 87, r25
 1091 0436 E895      		spm
 1092               		
 1093               	 ;  0 "" 2
 1094               	/* #NOAPP */
 1095               	.L70:
 907:bootSAH_2.c   **** 							boot_spm_busy_wait();
 1096               		.loc 1 907 0 discriminator 1
 1097 0438 07B6      		in __tmp_reg__,0x37
 1098 043a 00FC      		sbrc __tmp_reg__,0
 1099 043c 00C0      		rjmp .L70
 908:bootSAH_2.c   **** 							boot_rww_enable();				// Re-enable the RWW section
 1100               		.loc 1 908 0
 1101 043e 81E1      		ldi r24,lo8(17)
 1102               	/* #APP */
 1103               	 ;  908 "bootSAH_2.c" 1
 1104 0440 8093 5700 		sts 87, r24
 1105 0444 E895      		spm
 1106               		
 1107               	 ;  0 "" 2
 1108               	/* #NOAPP */
 1109 0446 00C0      		rjmp .L71
 1110               	.LVL102:
 1111               	.L65:
 1112               	.LBB98:
 909:bootSAH_2.c   **** 						}
 910:bootSAH_2.c   **** 						else
 911:bootSAH_2.c   **** 						{
 912:bootSAH_2.c   **** 							//*	issue 543, this should work, It has not been tested.
 913:bootSAH_2.c   **** 							uint16_t ii = address >> 1;
 1113               		.loc 1 913 0
 1114 0448 D301      		movw r26,r6
 1115 044a C201      		movw r24,r4
 1116 044c B695      		lsr r27
 1117 044e A795      		ror r26
 1118 0450 9795      		ror r25
 1119 0452 8795      		ror r24
 1120 0454 6C01      		movw r12,r24
 1121               	.LVL103:
 1122 0456 FE01      		movw r30,r28
 1123 0458 3B96      		adiw r30,11
 1124 045a C15E      		subi r28,lo8(-287)
 1125 045c DE4F      		sbci r29,hi8(-287)
 1126 045e F983      		std Y+1,r31
 1127 0460 E883      		st Y,r30
 1128 0462 CF51      		subi r28,lo8(287)
 1129 0464 D140      		sbci r29,hi8(287)
 914:bootSAH_2.c   **** 							/* write EEPROM */
 915:bootSAH_2.c   **** 							while (size) {
 1130               		.loc 1 915 0
 1131 0466 00E0      		ldi r16,0
 1132 0468 10E0      		ldi r17,0
 1133               	.LVL104:
 1134               	.L72:
 1135 046a 0E15      		cp r16,r14
 1136 046c 1F05      		cpc r17,r15
 1137 046e 01F0      		breq .L138
 916:bootSAH_2.c   **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 1138               		.loc 1 916 0
 1139 0470 C15E      		subi r28,lo8(-287)
 1140 0472 DE4F      		sbci r29,hi8(-287)
 1141 0474 E881      		ld r30,Y
 1142 0476 F981      		ldd r31,Y+1
 1143 0478 CF51      		subi r28,lo8(287)
 1144 047a D140      		sbci r29,hi8(287)
 1145 047c 6191      		ld r22,Z+
 1146 047e C15E      		subi r28,lo8(-287)
 1147 0480 DE4F      		sbci r29,hi8(-287)
 1148 0482 F983      		std Y+1,r31
 1149 0484 E883      		st Y,r30
 1150 0486 CF51      		subi r28,lo8(287)
 1151 0488 D140      		sbci r29,hi8(287)
 1152 048a C801      		movw r24,r16
 1153 048c 8C0D      		add r24,r12
 1154 048e 9D1D      		adc r25,r13
 1155 0490 0E94 0000 		call eeprom_write_byte
 1156               	.LVL105:
 1157 0494 0F5F      		subi r16,-1
 1158 0496 1F4F      		sbci r17,-1
 1159               	.LVL106:
 1160 0498 00C0      		rjmp .L72
 1161               	.L138:
 1162 049a 20E0      		ldi r18,0
 1163 049c 30E0      		ldi r19,0
 1164 049e 000F      		lsl r16
 1165 04a0 111F      		rol r17
 1166 04a2 221F      		rol r18
 1167 04a4 331F      		rol r19
 1168               	.LVL107:
 1169 04a6 040D      		add r16,r4
 1170 04a8 151D      		adc r17,r5
 1171 04aa 261D      		adc r18,r6
 1172 04ac 371D      		adc r19,r7
 1173               	.L71:
 1174               	.LVL108:
 1175               	.LBE98:
 917:bootSAH_2.c   **** 								address+=2;						// Select next EEPROM byte
 918:bootSAH_2.c   **** 								ii++;
 919:bootSAH_2.c   **** 								size--;
 920:bootSAH_2.c   **** 							}
 921:bootSAH_2.c   **** 						}
 922:bootSAH_2.c   **** 						msgLength		=	2;
 923:bootSAH_2.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1176               		.loc 1 923 0
 1177 04ae 1A82      		std Y+2,__zero_reg__
 1178               	.LBE100:
 924:bootSAH_2.c   **** 					}
 925:bootSAH_2.c   **** 					break;
 1179               		.loc 1 925 0
 1180 04b0 2801      		movw r4,r16
 1181 04b2 3901      		movw r6,r18
 1182               	.LVL109:
 1183 04b4 00C0      		rjmp .L132
 1184               	.LVL110:
 1185               	.L50:
 1186 04b6 8A81      		ldd r24,Y+2
 1187 04b8 9B81      		ldd r25,Y+3
 1188 04ba 9827      		eor r25,r24
 1189               	.LVL111:
 1190 04bc 8927      		eor r24,r25
 1191 04be 9827      		eor r25,r24
 1192               	.LVL112:
 1193               	.LBB101:
 926:bootSAH_2.c   **** 
 927:bootSAH_2.c   **** 				case CMD_READ_FLASH_ISP:
 928:bootSAH_2.c   **** 				case CMD_READ_EEPROM_ISP:
 929:bootSAH_2.c   **** 					{
 930:bootSAH_2.c   **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 931:bootSAH_2.c   **** 						unsigned char	*p		=	msgBuffer+1;
 932:bootSAH_2.c   **** 						msgLength				=	size+3;
 1194               		.loc 1 932 0
 1195 04c0 8C01      		movw r16,r24
 1196 04c2 0D5F      		subi r16,-3
 1197 04c4 1F4F      		sbci r17,-1
 1198               	.LVL113:
 933:bootSAH_2.c   **** 
 934:bootSAH_2.c   **** 						*p++	=	STATUS_CMD_OK;
 1199               		.loc 1 934 0
 1200 04c6 1A82      		std Y+2,__zero_reg__
 935:bootSAH_2.c   **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 1201               		.loc 1 935 0
 1202 04c8 2431      		cpi r18,lo8(20)
 1203 04ca 01F4      		brne .L74
 1204 04cc DE01      		movw r26,r28
 1205 04ce 1196      		adiw r26,1
 1206               	.LVL114:
 1207               	.L75:
 1208               	.LBB102:
 1209               	.LBB103:
 936:bootSAH_2.c   **** 						{
 937:bootSAH_2.c   **** 							unsigned int data;
 938:bootSAH_2.c   **** 
 939:bootSAH_2.c   **** 							// Read FLASH
 940:bootSAH_2.c   **** 							do {
 941:bootSAH_2.c   **** 						//#if defined(RAMPZ)
 942:bootSAH_2.c   **** 						#if (FLASHEND > 0x10000)
 943:bootSAH_2.c   **** 								data	=	pgm_read_word_far(address);
 1210               		.loc 1 943 0 discriminator 1
 1211               	/* #APP */
 1212               	 ;  943 "bootSAH_2.c" 1
 1213 04d0 6BBE      		out 59, r6
 1214 04d2 F201      		movw r30, r4
 1215 04d4 2791      		elpm r18, Z+
 1216 04d6 3691      		elpm r19, Z
 1217               		
 1218               	 ;  0 "" 2
 1219               	.LVL115:
 1220               	/* #NOAPP */
 1221               	.LBE103:
 944:bootSAH_2.c   **** 						#else
 945:bootSAH_2.c   **** 								data	=	pgm_read_word_near(address);
 946:bootSAH_2.c   **** 						#endif
 947:bootSAH_2.c   **** 								*p++	=	(unsigned char)data;		//LSB
 1222               		.loc 1 947 0 discriminator 1
 1223 04d8 1296      		adiw r26,2
 1224 04da 2C93      		st X,r18
 1225 04dc 1297      		sbiw r26,2
 1226 04de FD01      		movw r30,r26
 1227 04e0 3496      		adiw r30,4
 1228               	.LVL116:
 948:bootSAH_2.c   **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 1229               		.loc 1 948 0 discriminator 1
 1230 04e2 1396      		adiw r26,3
 1231 04e4 3C93      		st X,r19
 1232 04e6 1397      		sbiw r26,3
 949:bootSAH_2.c   **** 								address	+=	2;							// Select next word in memory
 1233               		.loc 1 949 0 discriminator 1
 1234 04e8 22E0      		ldi r18,2
 1235 04ea 420E      		add r4,r18
 1236 04ec 511C      		adc r5,__zero_reg__
 1237 04ee 611C      		adc r6,__zero_reg__
 1238 04f0 711C      		adc r7,__zero_reg__
 1239               	.LVL117:
 950:bootSAH_2.c   **** 								size	-=	2;
 1240               		.loc 1 950 0 discriminator 1
 1241 04f2 0297      		sbiw r24,2
 1242               	.LVL118:
 1243 04f4 1296      		adiw r26,2
 951:bootSAH_2.c   **** 							}while (size);
 1244               		.loc 1 951 0 discriminator 1
 1245 04f6 0097      		sbiw r24,0
 1246 04f8 01F4      		brne .L75
 1247 04fa 00C0      		rjmp .L76
 1248               	.LVL119:
 1249               	.L74:
 1250 04fc FE01      		movw r30,r28
 1251 04fe 3196      		adiw r30,1
 1252 0500 9F01      		movw r18,r30
 1253 0502 280F      		add r18,r24
 1254 0504 391F      		adc r19,r25
 1255               	.LBE102:
 935:bootSAH_2.c   **** 						{
 1256               		.loc 1 935 0 discriminator 1
 1257 0506 B301      		movw r22,r6
 1258 0508 A201      		movw r20,r4
 1259               	.LVL120:
 1260               	.L77:
 952:bootSAH_2.c   **** 						}
 953:bootSAH_2.c   **** 						else
 954:bootSAH_2.c   **** 						{
 955:bootSAH_2.c   **** 							/* Read EEPROM */
 956:bootSAH_2.c   **** 							do {
 957:bootSAH_2.c   **** 								EEARL	=	address;			// Setup EEPROM address
 1261               		.loc 1 957 0 discriminator 1
 1262 050a 41BD      		out 0x21,r20
 958:bootSAH_2.c   **** 								EEARH	=	((address >> 8));
 1263               		.loc 1 958 0 discriminator 1
 1264 050c C52E      		mov r12,r21
 1265 050e D62E      		mov r13,r22
 1266 0510 E72E      		mov r14,r23
 1267 0512 FF24      		clr r15
 1268 0514 C2BC      		out 0x22,r12
 959:bootSAH_2.c   **** 								address++;					// Select next EEPROM byte
 1269               		.loc 1 959 0 discriminator 1
 1270 0516 4F5F      		subi r20,-1
 1271 0518 5F4F      		sbci r21,-1
 1272 051a 6F4F      		sbci r22,-1
 1273 051c 7F4F      		sbci r23,-1
 1274               	.LVL121:
 960:bootSAH_2.c   **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 1275               		.loc 1 960 0 discriminator 1
 1276 051e F89A      		sbi 0x1f,0
 1277               	.LVL122:
 961:bootSAH_2.c   **** 								*p++	=	EEDR;				// Send EEPROM data
 1278               		.loc 1 961 0 discriminator 1
 1279 0520 A0B5      		in r26,0x20
 1280 0522 A283      		std Z+2,r26
 1281 0524 3196      		adiw r30,1
 1282               	.LVL123:
 962:bootSAH_2.c   **** 								size--;
 963:bootSAH_2.c   **** 							} while (size);
 1283               		.loc 1 963 0 discriminator 1
 1284 0526 2E17      		cp r18,r30
 1285 0528 3F07      		cpc r19,r31
 1286 052a 01F4      		brne .L77
 1287 052c AC01      		movw r20,r24
 1288               	.LVL124:
 1289 052e 4150      		subi r20,1
 1290 0530 5109      		sbc r21,__zero_reg__
 1291 0532 60E0      		ldi r22,0
 1292 0534 70E0      		ldi r23,0
 1293 0536 4F5F      		subi r20,-1
 1294 0538 5F4F      		sbci r21,-1
 1295 053a 6F4F      		sbci r22,-1
 1296 053c 7F4F      		sbci r23,-1
 1297 053e 440E      		add r4,r20
 1298 0540 551E      		adc r5,r21
 1299 0542 661E      		adc r6,r22
 1300 0544 771E      		adc r7,r23
 1301 0546 E3E0      		ldi r30,lo8(3)
 1302 0548 F0E0      		ldi r31,0
 1303               	.LVL125:
 1304 054a EC0F      		add r30,r28
 1305 054c FD1F      		adc r31,r29
 1306 054e E80F      		add r30,r24
 1307 0550 F91F      		adc r31,r25
 1308               	.L76:
 1309               	.LVL126:
 964:bootSAH_2.c   **** 						}
 965:bootSAH_2.c   **** 						*p++	=	STATUS_CMD_OK;
 1310               		.loc 1 965 0
 1311 0552 1082      		st Z,__zero_reg__
 1312               	.LBE101:
 966:bootSAH_2.c   **** 					}
 967:bootSAH_2.c   **** 					break;
 1313               		.loc 1 967 0
 1314 0554 C12C      		mov r12,__zero_reg__
 1315 0556 00C0      		rjmp .L58
 1316               	.LVL127:
 1317               	.L38:
 968:bootSAH_2.c   **** 
 969:bootSAH_2.c   **** 				default:
 970:bootSAH_2.c   **** 					msgLength		=	2;
 971:bootSAH_2.c   **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 1318               		.loc 1 971 0
 1319 0558 80EC      		ldi r24,lo8(-64)
 1320 055a 8A83      		std Y+2,r24
 1321               	.LVL128:
 1322               	.L132:
 972:bootSAH_2.c   **** 					break;
 1323               		.loc 1 972 0
 1324 055c C12C      		mov r12,__zero_reg__
 1325               	.LVL129:
 1326               	.L131:
 970:bootSAH_2.c   **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 1327               		.loc 1 970 0
 1328 055e 02E0      		ldi r16,lo8(2)
 1329 0560 10E0      		ldi r17,0
 1330               	.LVL130:
 1331               	.L58:
 973:bootSAH_2.c   **** 			}
 974:bootSAH_2.c   **** 
 975:bootSAH_2.c   **** 			/*
 976:bootSAH_2.c   **** 			 * Now send answer message back
 977:bootSAH_2.c   **** 			 */
 978:bootSAH_2.c   **** 			sendchar(MESSAGE_START);
 1332               		.loc 1 978 0
 1333 0562 8BE1      		ldi r24,lo8(27)
 1334 0564 0E94 0000 		call sendchar
 1335               	.LVL131:
 979:bootSAH_2.c   **** 			checksum	=	MESSAGE_START^0;
 980:bootSAH_2.c   **** 
 981:bootSAH_2.c   **** 			sendchar(seqNum);
 1336               		.loc 1 981 0
 1337 0568 C25E      		subi r28,lo8(-286)
 1338 056a DE4F      		sbci r29,hi8(-286)
 1339 056c 8881      		ld r24,Y
 1340 056e CE51      		subi r28,lo8(286)
 1341 0570 D140      		sbci r29,hi8(286)
 1342 0572 0E94 0000 		call sendchar
 1343               	.LVL132:
 982:bootSAH_2.c   **** 			checksum	^=	seqNum;
 983:bootSAH_2.c   **** 
 984:bootSAH_2.c   **** 			c			=	((msgLength>>8)&0xFF);
 985:bootSAH_2.c   **** 			sendchar(c);
 1344               		.loc 1 985 0
 1345 0576 812F      		mov r24,r17
 1346 0578 0E94 0000 		call sendchar
 1347               	.LVL133:
 986:bootSAH_2.c   **** 			checksum	^=	c;
 987:bootSAH_2.c   **** 
 988:bootSAH_2.c   **** 			c			=	msgLength&0x00FF;
 989:bootSAH_2.c   **** 			sendchar(c);
 1348               		.loc 1 989 0
 1349 057c 802F      		mov r24,r16
 1350 057e 0E94 0000 		call sendchar
 1351               	.LVL134:
 1352 0582 85E1      		ldi r24,lo8(21)
 1353 0584 C25E      		subi r28,lo8(-286)
 1354 0586 DE4F      		sbci r29,hi8(-286)
 1355 0588 D880      		ld r13,Y
 1356 058a CE51      		subi r28,lo8(286)
 1357 058c D140      		sbci r29,hi8(286)
 1358 058e D826      		eor r13,r24
 1359 0590 D026      		eor r13,r16
 1360               	.LVL135:
 990:bootSAH_2.c   **** 			checksum ^= c;
 991:bootSAH_2.c   **** 
 992:bootSAH_2.c   **** 			sendchar(TOKEN);
 1361               		.loc 1 992 0
 1362 0592 8EE0      		ldi r24,lo8(14)
 1363 0594 0E94 0000 		call sendchar
 1364               	.LVL136:
 993:bootSAH_2.c   **** 			checksum ^= TOKEN;
 1365               		.loc 1 993 0
 1366 0598 D126      		eor r13,r17
 1367               	.LVL137:
 1368 059a CE01      		movw r24,r28
 1369 059c 0196      		adiw r24,1
 1370 059e 7C01      		movw r14,r24
 1371 05a0 080F      		add r16,r24
 1372 05a2 191F      		adc r17,r25
 1373               	.LVL138:
 1374               	.L78:
 994:bootSAH_2.c   **** 
 995:bootSAH_2.c   **** 			p	=	msgBuffer;
 996:bootSAH_2.c   **** 			while ( msgLength )
 1375               		.loc 1 996 0
 1376 05a4 0E15      		cp r16,r14
 1377 05a6 1F05      		cpc r17,r15
 1378 05a8 01F0      		breq .L139
 1379               	.LVL139:
 997:bootSAH_2.c   **** 			{
 998:bootSAH_2.c   **** 				c	=	*p++;
 1380               		.loc 1 998 0
 1381 05aa F701      		movw r30,r14
 1382 05ac 2191      		ld r18,Z+
 1383               	.LVL140:
 1384 05ae 7F01      		movw r14,r30
 1385 05b0 C15E      		subi r28,lo8(-287)
 1386 05b2 DE4F      		sbci r29,hi8(-287)
 1387 05b4 2883      		st Y,r18
 1388 05b6 CF51      		subi r28,lo8(287)
 1389 05b8 D140      		sbci r29,hi8(287)
 1390               	.LVL141:
 999:bootSAH_2.c   **** 				sendchar(c);
 1391               		.loc 1 999 0
 1392 05ba 822F      		mov r24,r18
 1393 05bc 0E94 0000 		call sendchar
 1394               	.LVL142:
1000:bootSAH_2.c   **** 				checksum ^=c;
 1395               		.loc 1 1000 0
 1396 05c0 C15E      		subi r28,lo8(-287)
 1397 05c2 DE4F      		sbci r29,hi8(-287)
 1398 05c4 4881      		ld r20,Y
 1399 05c6 CF51      		subi r28,lo8(287)
 1400 05c8 D140      		sbci r29,hi8(287)
 1401 05ca D426      		eor r13,r20
 1402               	.LVL143:
 1403 05cc 00C0      		rjmp .L78
 1404               	.LVL144:
 1405               	.L139:
1001:bootSAH_2.c   **** 				msgLength--;
1002:bootSAH_2.c   **** 			}
1003:bootSAH_2.c   **** 			sendchar(checksum);
 1406               		.loc 1 1003 0
 1407 05ce 8D2D      		mov r24,r13
 1408 05d0 0E94 0000 		call sendchar
 1409               	.LVL145:
1004:bootSAH_2.c   **** 			seqNum++;
 1410               		.loc 1 1004 0
 1411 05d4 C25E      		subi r28,lo8(-286)
 1412 05d6 DE4F      		sbci r29,hi8(-286)
 1413 05d8 8881      		ld r24,Y
 1414 05da CE51      		subi r28,lo8(286)
 1415 05dc D140      		sbci r29,hi8(286)
 1416 05de 8F5F      		subi r24,lo8(-(1))
 1417 05e0 C25E      		subi r28,lo8(-286)
 1418 05e2 DE4F      		sbci r29,hi8(-286)
 1419 05e4 8883      		st Y,r24
 1420 05e6 CE51      		subi r28,lo8(286)
 1421 05e8 D140      		sbci r29,hi8(286)
 1422               	.LVL146:
1005:bootSAH_2.c   **** 	
1006:bootSAH_2.c   **** 		#ifndef REMOVE_BOOTLOADER_LED
1007:bootSAH_2.c   **** 			//*	<MLS>	toggle the LED
1008:bootSAH_2.c   **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
 1423               		.loc 1 1008 0
 1424 05ea 85B1      		in r24,0x5
 1425               	.LVL147:
 1426 05ec 8058      		subi r24,lo8(-(-128))
 1427 05ee 85B9      		out 0x5,r24
 1428               	.LVL148:
 1429 05f0 00E0      		ldi r16,0
 1430 05f2 10E0      		ldi r17,0
 555:bootSAH_2.c   **** 		{
 1431               		.loc 1 555 0
 1432 05f4 CC20      		tst r12
 1433 05f6 01F4      		brne .+2
 1434 05f8 00C0      		rjmp .L80
 1435               	.LVL149:
 1436               	.L20:
1009:bootSAH_2.c   **** 		#endif
1010:bootSAH_2.c   **** 
1011:bootSAH_2.c   **** 		}
1012:bootSAH_2.c   **** 	}
1013:bootSAH_2.c   **** 
1014:bootSAH_2.c   **** #ifdef _DEBUG_WITH_LEDS_
1015:bootSAH_2.c   **** 	//*	this is for debugging it can be removed
1016:bootSAH_2.c   **** 	for (ii=0; ii<10; ii++)
1017:bootSAH_2.c   **** 	{
1018:bootSAH_2.c   **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1019:bootSAH_2.c   **** 		delay_ms(200);
1020:bootSAH_2.c   **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1021:bootSAH_2.c   **** 		delay_ms(200);
1022:bootSAH_2.c   **** 	}
1023:bootSAH_2.c   **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1024:bootSAH_2.c   **** #endif
1025:bootSAH_2.c   **** 
1026:bootSAH_2.c   **** #ifdef _DEBUG_SERIAL_
1027:bootSAH_2.c   **** 	sendchar('b');
 1437               		.loc 1 1027 0
 1438 05fa 82E6      		ldi r24,lo8(98)
 1439 05fc 0E94 0000 		call sendchar
 1440               	.LVL150:
1028:bootSAH_2.c   **** 	sendchar('y');
 1441               		.loc 1 1028 0
 1442 0600 89E7      		ldi r24,lo8(121)
 1443 0602 0E94 0000 		call sendchar
 1444               	.LVL151:
1029:bootSAH_2.c   **** 	sendchar(' ');
 1445               		.loc 1 1029 0
 1446 0606 80E2      		ldi r24,lo8(32)
 1447 0608 0E94 0000 		call sendchar
 1448               	.LVL152:
1030:bootSAH_2.c   **** 	sendchar('s');
 1449               		.loc 1 1030 0
 1450 060c 83E7      		ldi r24,lo8(115)
 1451 060e 0E94 0000 		call sendchar
 1452               	.LVL153:
1031:bootSAH_2.c   **** 	sendchar('a');
 1453               		.loc 1 1031 0
 1454 0612 81E6      		ldi r24,lo8(97)
 1455 0614 0E94 0000 		call sendchar
 1456               	.LVL154:
1032:bootSAH_2.c   **** 	sendchar('h');
 1457               		.loc 1 1032 0
 1458 0618 88E6      		ldi r24,lo8(104)
 1459 061a 0E94 0000 		call sendchar
 1460               	.LVL155:
1033:bootSAH_2.c   **** 	sendchar(0x0d);
 1461               		.loc 1 1033 0
 1462 061e 8DE0      		ldi r24,lo8(13)
 1463 0620 0E94 0000 		call sendchar
 1464               	.LVL156:
1034:bootSAH_2.c   **** 	sendchar(0x0a);
 1465               		.loc 1 1034 0
 1466 0624 8AE0      		ldi r24,lo8(10)
 1467 0626 0E94 0000 		call sendchar
 1468               	.LVL157:
1035:bootSAH_2.c   **** 
1036:bootSAH_2.c   **** 	delay_ms(100);
 1469               		.loc 1 1036 0
 1470 062a 84E6      		ldi r24,lo8(100)
 1471 062c 90E0      		ldi r25,0
 1472 062e 0E94 0000 		call delay_ms
 1473               	.LVL158:
1037:bootSAH_2.c   **** #endif
1038:bootSAH_2.c   **** 
1039:bootSAH_2.c   **** 
1040:bootSAH_2.c   **** #ifndef REMOVE_BOOTLOADER_LED
1041:bootSAH_2.c   **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
 1474               		.loc 1 1041 0
 1475 0632 2798      		cbi 0x4,7
1042:bootSAH_2.c   **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 1476               		.loc 1 1042 0
 1477 0634 2F98      		cbi 0x5,7
1043:bootSAH_2.c   **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1044:bootSAH_2.c   **** 	delay_ms(100);							// delay after exit
 1478               		.loc 1 1044 0
 1479 0636 84E6      		ldi r24,lo8(100)
 1480 0638 90E0      		ldi r25,0
 1481 063a 0E94 0000 		call delay_ms
 1482               	.LVL159:
1045:bootSAH_2.c   **** #endif
1046:bootSAH_2.c   **** 
1047:bootSAH_2.c   **** 
1048:bootSAH_2.c   **** 	asm volatile ("nop");			// wait until port has changed
 1483               		.loc 1 1048 0
 1484               	/* #APP */
 1485               	 ;  1048 "bootSAH_2.c" 1
 1486 063e 0000      		nop
 1487               	 ;  0 "" 2
1049:bootSAH_2.c   **** 
1050:bootSAH_2.c   **** 	/*
1051:bootSAH_2.c   **** 	 * Now leave bootloader
1052:bootSAH_2.c   **** 	 */
1053:bootSAH_2.c   **** 
1054:bootSAH_2.c   **** 	UART_STATUS_REG	&=	0xfd;
 1488               		.loc 1 1054 0
 1489               	/* #NOAPP */
 1490 0640 8091 C000 		lds r24,192
 1491 0644 8D7F      		andi r24,lo8(-3)
 1492 0646 8093 C000 		sts 192,r24
1055:bootSAH_2.c   **** 	boot_rww_enable();				// enable application section
 1493               		.loc 1 1055 0
 1494 064a 81E1      		ldi r24,lo8(17)
 1495               	/* #APP */
 1496               	 ;  1055 "bootSAH_2.c" 1
 1497 064c 8093 5700 		sts 87, r24
 1498 0650 E895      		spm
 1499               		
 1500               	 ;  0 "" 2
1056:bootSAH_2.c   **** 
1057:bootSAH_2.c   **** 
1058:bootSAH_2.c   **** 	asm volatile(
 1501               		.loc 1 1058 0
 1502               	 ;  1058 "bootSAH_2.c" 1
 1503 0652 EE27      		clr	r30		
 1504 0654 FF27      		clr	r31		
 1505 0656 0994      		ijmp	
 1506               		
 1507               	 ;  0 "" 2
 1508               	/* #NOAPP */
 1509               	.L82:
 1510 0658 00C0      		rjmp .L82
 1511               	.LVL160:
 1512               	.L137:
 602:bootSAH_2.c   **** 						}
 1513               		.loc 1 602 0
 1514 065a 8BE1      		ldi r24,lo8(27)
 1515 065c D82E      		mov r13,r24
 1516               	.LVL161:
 601:bootSAH_2.c   **** 							checksum		=	MESSAGE_START^0;
 1517               		.loc 1 601 0
 1518 065e 81E0      		ldi r24,lo8(1)
 1519 0660 00C0      		rjmp .L37
 1520               	.LVL162:
 1521               	.L85:
 646:bootSAH_2.c   **** 						}
 1522               		.loc 1 646 0
 1523 0662 80E0      		ldi r24,0
 1524               	.LVL163:
 1525 0664 00C0      		rjmp .L37
 1526               	.LVL164:
 1527               	.L86:
 1528 0666 1901      		movw r2,r18
 655:bootSAH_2.c   **** 						}
 1529               		.loc 1 655 0
 1530 0668 86E0      		ldi r24,lo8(6)
 1531               	.LVL165:
 1532 066a 00C0      		rjmp .L37
 1533               		.cfi_endproc
 1534               	.LFE17:
 1536               		.section	.rodata
 1539               	CSWTCH.27:
 1540 0000 0F        		.byte	15
 1541 0001 02        		.byte	2
 1542 0002 0A        		.byte	10
 1543               	.global	app_start
 1544               		.section .bss
 1547               	app_start:
 1548 0000 0000      		.zero	2
 1549               		.text
 1550               	.Letext0:
 1551               		.file 3 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\st
 1552               		.file 4 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\av
DEFINED SYMBOLS
                            *ABS*:00000000 bootSAH_2.c
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:2      *ABS*:0000003e __SP_H__
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:3      *ABS*:0000003d __SP_L__
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:4      *ABS*:0000003f __SREG__
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:7      *ABS*:00000001 __zero_reg__
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:12     .text:00000000 sendchar
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:42     .init9:00000000 __jumpMain
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:53     *ABS*:000021ff __stack
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:139    .text.startup:00000000 main
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:92     .text:00000018 delay_ms
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:1547   .bss:00000000 app_start
C:\Users\supun\AppData\Local\Temp\ccE7MjuJ.s:1539   .rodata:00000000 CSWTCH.27

UNDEFINED SYMBOLS
__udivmodsi4
__bswapsi2
eeprom_write_byte
__do_copy_data
__do_clear_bss
