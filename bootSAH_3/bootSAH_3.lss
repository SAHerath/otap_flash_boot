
bootSAH_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  0003e5da  0000066e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000005da  0003e000  0003e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800200  00800200  0000066e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000066e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000006a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000030  00000000  00000000  000006e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001730  00000000  00000000  00000710  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000dcc  00000000  00000000  00001e40  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000059f  00000000  00000000  00002c0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000018c  00000000  00000000  000031ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000073e  00000000  00000000  00003338  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000008e6  00000000  00000000  00003a76  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000020  00000000  00000000  0000435c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0003e000 <__vectors>:
   3e000:	0d 94 72 f0 	jmp	0x3e0e4	; 0x3e0e4 <__ctors_end>
   3e004:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e008:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e00c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e010:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e014:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e018:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e01c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e020:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e024:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e028:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e02c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e030:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e034:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e038:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e03c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e040:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e044:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e048:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e04c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e050:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e054:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e058:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e05c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e060:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e064:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e068:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e06c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e070:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e074:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e078:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e07c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e080:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e084:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e088:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e08c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e090:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e094:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e098:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e09c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0a0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0a4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0a8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0ac:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0b0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0b4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0b8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0bc:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0c0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0c4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0c8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0cc:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0d0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0d4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0d8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0dc:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0e0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>

0003e0e4 <__ctors_end>:
   3e0e4:	11 24       	eor	r1, r1
   3e0e6:	1f be       	out	0x3f, r1	; 63
   3e0e8:	cf ef       	ldi	r28, 0xFF	; 255
   3e0ea:	d1 e2       	ldi	r29, 0x21	; 33
   3e0ec:	de bf       	out	0x3e, r29	; 62
   3e0ee:	cd bf       	out	0x3d, r28	; 61
   3e0f0:	01 e0       	ldi	r16, 0x01	; 1
   3e0f2:	0c bf       	out	0x3c, r16	; 60

0003e0f4 <__do_clear_bss>:
   3e0f4:	22 e0       	ldi	r18, 0x02	; 2
   3e0f6:	a0 e0       	ldi	r26, 0x00	; 0
   3e0f8:	b2 e0       	ldi	r27, 0x02	; 2
   3e0fa:	01 c0       	rjmp	.+2      	; 0x3e0fe <.do_clear_bss_start>

0003e0fc <.do_clear_bss_loop>:
   3e0fc:	1d 92       	st	X+, r1

0003e0fe <.do_clear_bss_start>:
   3e0fe:	a2 30       	cpi	r26, 0x02	; 2
   3e100:	b2 07       	cpc	r27, r18
   3e102:	e1 f7       	brne	.-8      	; 0x3e0fc <.do_clear_bss_loop>
   3e104:	0f 94 ab f1 	call	0x3e356	; 0x3e356 <main>
   3e108:	0d 94 eb f2 	jmp	0x3e5d6	; 0x3e5d6 <_exit>

0003e10c <__jumpMain>:

	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );

//*	set stack pointer to top of RAM

	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
   3e10c:	01 e2       	ldi	r16, 0x21	; 33
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
   3e10e:	0e bf       	out	0x3e, r16	; 62

	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
   3e110:	0f ef       	ldi	r16, 0xFF	; 255
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
   3e112:	0d bf       	out	0x3d, r16	; 61

	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
   3e114:	11 24       	eor	r1, r1
	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
   3e116:	1f be       	out	0x3f, r1	; 63
	asm volatile ( "jmp main");												// jump to main()
   3e118:	0d 94 ab f1 	jmp	0x3e356	; 0x3e356 <main>

0003e11c <__bad_interrupt>:
   3e11c:	0d 94 00 f0 	jmp	0x3e000	; 0x3e000 <__vectors>

0003e120 <delay_ms>:

//*****************************************************************************
void delay_ms(unsigned int timedelay)
{
	unsigned int i;
	for (i=0;i<timedelay;i++)
   3e120:	20 e0       	ldi	r18, 0x00	; 0
   3e122:	30 e0       	ldi	r19, 0x00	; 0
   3e124:	28 17       	cp	r18, r24
   3e126:	39 07       	cpc	r19, r25
   3e128:	49 f0       	breq	.+18     	; 0x3e13c <delay_ms+0x1c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   3e12a:	ef ec       	ldi	r30, 0xCF	; 207
   3e12c:	f7 e0       	ldi	r31, 0x07	; 7
   3e12e:	31 97       	sbiw	r30, 0x01	; 1
   3e130:	f1 f7       	brne	.-4      	; 0x3e12e <delay_ms+0xe>
   3e132:	00 c0       	rjmp	.+0      	; 0x3e134 <delay_ms+0x14>
   3e134:	00 00       	nop
   3e136:	2f 5f       	subi	r18, 0xFF	; 255
   3e138:	3f 4f       	sbci	r19, 0xFF	; 255
   3e13a:	f4 cf       	rjmp	.-24     	; 0x3e124 <delay_ms+0x4>
	{
		_delay_ms(0.5);
	}
}
   3e13c:	08 95       	ret

0003e13e <SPI_Init>:
	FLASH_UntilReady();
}

void SPI_Init(void)
{
	DDRB = (1<<PB2)|(1<<PB1)|(1<<PB0);
   3e13e:	87 e0       	ldi	r24, 0x07	; 7
   3e140:	84 b9       	out	0x04, r24	; 4

	SPCR = ((1<<SPE)|               // SPI Enable
   3e142:	81 e5       	ldi	r24, 0x51	; 81
   3e144:	8c bd       	out	0x2c, r24	; 44
   3e146:	08 95       	ret

0003e148 <SPI_Transfer>:
	(0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)
}

uint8_t SPI_Transfer(uint8_t spidata)
{
	SPDR = spidata;
   3e148:	8e bd       	out	0x2e, r24	; 46
	asm volatile("nop");    // small delay
   3e14a:	00 00       	nop
	while(!(SPSR & (1<<SPIF)));   // Wait for transmission complete
   3e14c:	0d b4       	in	r0, 0x2d	; 45
   3e14e:	07 fe       	sbrs	r0, 7
   3e150:	fd cf       	rjmp	.-6      	; 0x3e14c <SPI_Transfer+0x4>

	return SPDR;
   3e152:	8e b5       	in	r24, 0x2e	; 46
}
   3e154:	08 95       	ret

0003e156 <FLASH_WriteEnable>:
	return 0;
}

void FLASH_WriteEnable()
{
	PROG_PORT  &=  ~(1<<PROGCS_PIN);
   3e156:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x06);
   3e158:	86 e0       	ldi	r24, 0x06	; 6
   3e15a:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	PROG_PORT  |=  (1<<PROGCS_PIN);
   3e15e:	28 9a       	sbi	0x05, 0	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   3e160:	85 e3       	ldi	r24, 0x35	; 53
   3e162:	8a 95       	dec	r24
   3e164:	f1 f7       	brne	.-4      	; 0x3e162 <FLASH_WriteEnable+0xc>
   3e166:	00 00       	nop
   3e168:	08 95       	ret

0003e16a <FLASH_ResetEnable>:
	_delay_us(10);
}

void FLASH_ResetEnable()
{
	PROG_PORT  &=  ~(1<<PROGCS_PIN);
   3e16a:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x66);
   3e16c:	86 e6       	ldi	r24, 0x66	; 102
   3e16e:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	PROG_PORT  |=  (1<<PROGCS_PIN);
   3e172:	28 9a       	sbi	0x05, 0	; 5
   3e174:	85 e3       	ldi	r24, 0x35	; 53
   3e176:	8a 95       	dec	r24
   3e178:	f1 f7       	brne	.-4      	; 0x3e176 <FLASH_ResetEnable+0xc>
   3e17a:	00 00       	nop
   3e17c:	08 95       	ret

0003e17e <FLASH_Reset>:
	_delay_us(10);
}

void FLASH_Reset()
{
	PROG_PORT  &=  ~(1<<PROGCS_PIN);
   3e17e:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x99);
   3e180:	89 e9       	ldi	r24, 0x99	; 153
   3e182:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	PROG_PORT  |=  (1<<PROGCS_PIN);
   3e186:	28 9a       	sbi	0x05, 0	; 5
   3e188:	85 e3       	ldi	r24, 0x35	; 53
   3e18a:	8a 95       	dec	r24
   3e18c:	f1 f7       	brne	.-4      	; 0x3e18a <FLASH_Reset+0xc>
   3e18e:	00 00       	nop
   3e190:	08 95       	ret

0003e192 <FLASH_UntilReady>:
}

void FLASH_UntilReady()
{
	uint8_t stat=0xff;
	PROG_PORT  &=  ~(1<<PROGCS_PIN);
   3e192:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x05);
   3e194:	85 e0       	ldi	r24, 0x05	; 5
   3e196:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	_delay_us(10);
}

void FLASH_UntilReady()
{
	uint8_t stat=0xff;
   3e19a:	8f ef       	ldi	r24, 0xFF	; 255
	PROG_PORT  &=  ~(1<<PROGCS_PIN);
	SPI_Transfer(0x05);
	while((stat & 0x01) == 0x01)
   3e19c:	80 ff       	sbrs	r24, 0
   3e19e:	04 c0       	rjmp	.+8      	; 0x3e1a8 <FLASH_UntilReady+0x16>
	{
		stat = SPI_Transfer(0);
   3e1a0:	80 e0       	ldi	r24, 0x00	; 0
   3e1a2:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
   3e1a6:	fa cf       	rjmp	.-12     	; 0x3e19c <FLASH_UntilReady+0xa>
	}
	PROG_PORT  |=  (1<<PROGCS_PIN);
   3e1a8:	28 9a       	sbi	0x05, 0	; 5
   3e1aa:	85 e3       	ldi	r24, 0x35	; 53
   3e1ac:	8a 95       	dec	r24
   3e1ae:	f1 f7       	brne	.-4      	; 0x3e1ac <FLASH_UntilReady+0x1a>
   3e1b0:	00 00       	nop
   3e1b2:	08 95       	ret

0003e1b4 <FLASH_Init>:
	for(;;);
}


uint8_t FLASH_Init()
{
   3e1b4:	cf 92       	push	r12
   3e1b6:	df 92       	push	r13
   3e1b8:	ef 92       	push	r14
   3e1ba:	ff 92       	push	r15
	PROG_DDR  |=  (1<<PROGCS_PIN); // chip select as output
   3e1bc:	20 9a       	sbi	0x04, 0	; 4
	PROG_PORT |=  (1<<PROGCS_PIN); // pull high
   3e1be:	28 9a       	sbi	0x05, 0	; 5
   3e1c0:	85 e3       	ldi	r24, 0x35	; 53
   3e1c2:	8a 95       	dec	r24
   3e1c4:	f1 f7       	brne	.-4      	; 0x3e1c2 <FLASH_Init+0xe>
   3e1c6:	00 00       	nop
	
	_delay_us(10);
	FLASH_UntilReady();
   3e1c8:	0f 94 c9 f0 	call	0x3e192	; 0x3e192 <FLASH_UntilReady>
	FLASH_ResetEnable();
   3e1cc:	0f 94 b5 f0 	call	0x3e16a	; 0x3e16a <FLASH_ResetEnable>
	FLASH_Reset();
   3e1d0:	0f 94 bf f0 	call	0x3e17e	; 0x3e17e <FLASH_Reset>
	uint32_t temp=0;
	PROG_PORT  &=  ~(1<<PROGCS_PIN);    // low
   3e1d4:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x9F);
   3e1d6:	8f e9       	ldi	r24, 0x9F	; 159
   3e1d8:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	temp = (uint32_t)SPI_Transfer(0) << 16;
   3e1dc:	80 e0       	ldi	r24, 0x00	; 0
   3e1de:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
   3e1e2:	c8 2e       	mov	r12, r24
   3e1e4:	d1 2c       	mov	r13, r1
   3e1e6:	e1 2c       	mov	r14, r1
   3e1e8:	f1 2c       	mov	r15, r1
   3e1ea:	76 01       	movw	r14, r12
   3e1ec:	dd 24       	eor	r13, r13
   3e1ee:	cc 24       	eor	r12, r12
	temp |= (uint32_t)SPI_Transfer(0) << 8;
   3e1f0:	80 e0       	ldi	r24, 0x00	; 0
   3e1f2:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
   3e1f6:	d8 2a       	or	r13, r24
	temp |= (uint32_t)SPI_Transfer(0);
   3e1f8:	80 e0       	ldi	r24, 0x00	; 0
   3e1fa:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	PROG_PORT  |=  (1<<PROGCS_PIN);   // high
   3e1fe:	28 9a       	sbi	0x05, 0	; 5
   3e200:	c8 2a       	or	r12, r24
   3e202:	81 e0       	ldi	r24, 0x01	; 1
   3e204:	97 e1       	ldi	r25, 0x17	; 23
   3e206:	c9 16       	cp	r12, r25
   3e208:	90 e4       	ldi	r25, 0x40	; 64
   3e20a:	d9 06       	cpc	r13, r25
   3e20c:	9f ee       	ldi	r25, 0xEF	; 239
   3e20e:	e9 06       	cpc	r14, r25
   3e210:	f1 04       	cpc	r15, r1
   3e212:	09 f0       	breq	.+2      	; 0x3e216 <FLASH_Init+0x62>
   3e214:	80 e0       	ldi	r24, 0x00	; 0

	if(temp == EXMEM_JEDEC)
	return 1;
	
	return 0;
}
   3e216:	ff 90       	pop	r15
   3e218:	ef 90       	pop	r14
   3e21a:	df 90       	pop	r13
   3e21c:	cf 90       	pop	r12
   3e21e:	08 95       	ret

0003e220 <FLASH_ReadByte>:
	PROG_PORT  |=  (1<<PROGCS_PIN);
	_delay_us(10);
}

void FLASH_ReadByte(uint32_t faddr, uint8_t *rdata)
{
   3e220:	ff 92       	push	r15
   3e222:	0f 93       	push	r16
   3e224:	1f 93       	push	r17
   3e226:	cf 93       	push	r28
   3e228:	df 93       	push	r29
   3e22a:	16 2f       	mov	r17, r22
   3e22c:	07 2f       	mov	r16, r23
   3e22e:	f8 2e       	mov	r15, r24
   3e230:	ea 01       	movw	r28, r20
	PROG_PORT  &=  ~(1<<PROGCS_PIN);
   3e232:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x03);
   3e234:	83 e0       	ldi	r24, 0x03	; 3
   3e236:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e23a:	8f 2d       	mov	r24, r15
   3e23c:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e240:	80 2f       	mov	r24, r16
   3e242:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e246:	81 2f       	mov	r24, r17
   3e248:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	//  SPI_Transfer(0);
	*rdata = SPI_Transfer(0);
   3e24c:	80 e0       	ldi	r24, 0x00	; 0
   3e24e:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
   3e252:	88 83       	st	Y, r24
	PROG_PORT  |=  (1<<PROGCS_PIN);
   3e254:	28 9a       	sbi	0x05, 0	; 5
   3e256:	85 e3       	ldi	r24, 0x35	; 53
   3e258:	8a 95       	dec	r24
   3e25a:	f1 f7       	brne	.-4      	; 0x3e258 <FLASH_ReadByte+0x38>
   3e25c:	00 00       	nop
	_delay_us(10);
}
   3e25e:	df 91       	pop	r29
   3e260:	cf 91       	pop	r28
   3e262:	1f 91       	pop	r17
   3e264:	0f 91       	pop	r16
   3e266:	ff 90       	pop	r15
   3e268:	08 95       	ret

0003e26a <FLASH_ReadWord>:

void FLASH_ReadWord(uint32_t faddr, uint16_t *rdata)
{
   3e26a:	ff 92       	push	r15
   3e26c:	0f 93       	push	r16
   3e26e:	1f 93       	push	r17
   3e270:	cf 93       	push	r28
   3e272:	df 93       	push	r29
   3e274:	eb 01       	movw	r28, r22
   3e276:	f8 2e       	mov	r15, r24
   3e278:	8a 01       	movw	r16, r20
	uint8_t temp1=0, temp2=0;
	PROG_PORT &= ~(1<<PROGCS_PIN);
   3e27a:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x03);
   3e27c:	83 e0       	ldi	r24, 0x03	; 3
   3e27e:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e282:	8f 2d       	mov	r24, r15
   3e284:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e288:	8d 2f       	mov	r24, r29
   3e28a:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e28e:	8c 2f       	mov	r24, r28
   3e290:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	temp1 = SPI_Transfer(0);
   3e294:	80 e0       	ldi	r24, 0x00	; 0
   3e296:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
   3e29a:	c8 2f       	mov	r28, r24
	temp2 = SPI_Transfer(0);
   3e29c:	80 e0       	ldi	r24, 0x00	; 0
   3e29e:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	PROG_PORT |= (1<<PROGCS_PIN);
   3e2a2:	28 9a       	sbi	0x05, 0	; 5
	*rdata = ((uint16_t)temp1 << 8) | temp2;
   3e2a4:	2c 2f       	mov	r18, r28
   3e2a6:	30 e0       	ldi	r19, 0x00	; 0
   3e2a8:	32 2f       	mov	r19, r18
   3e2aa:	22 27       	eor	r18, r18
   3e2ac:	28 2b       	or	r18, r24
   3e2ae:	f8 01       	movw	r30, r16
   3e2b0:	31 83       	std	Z+1, r19	; 0x01
   3e2b2:	20 83       	st	Z, r18
   3e2b4:	f5 e3       	ldi	r31, 0x35	; 53
   3e2b6:	fa 95       	dec	r31
   3e2b8:	f1 f7       	brne	.-4      	; 0x3e2b6 <FLASH_ReadWord+0x4c>
   3e2ba:	00 00       	nop
	_delay_us(10);
}
   3e2bc:	df 91       	pop	r29
   3e2be:	cf 91       	pop	r28
   3e2c0:	1f 91       	pop	r17
   3e2c2:	0f 91       	pop	r16
   3e2c4:	ff 90       	pop	r15
   3e2c6:	08 95       	ret

0003e2c8 <FLASH_WriteByte>:

void FLASH_WriteByte(uint32_t faddr, uint8_t wdata)
{
   3e2c8:	0f 93       	push	r16
   3e2ca:	1f 93       	push	r17
   3e2cc:	cf 93       	push	r28
   3e2ce:	df 93       	push	r29
   3e2d0:	d6 2f       	mov	r29, r22
   3e2d2:	17 2f       	mov	r17, r23
   3e2d4:	08 2f       	mov	r16, r24
   3e2d6:	c4 2f       	mov	r28, r20
	FLASH_UntilReady();
   3e2d8:	0f 94 c9 f0 	call	0x3e192	; 0x3e192 <FLASH_UntilReady>
	FLASH_WriteEnable();
   3e2dc:	0f 94 ab f0 	call	0x3e156	; 0x3e156 <FLASH_WriteEnable>
	PROG_PORT &= ~(1<<PROGCS_PIN);
   3e2e0:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x02);
   3e2e2:	82 e0       	ldi	r24, 0x02	; 2
   3e2e4:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e2e8:	80 2f       	mov	r24, r16
   3e2ea:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e2ee:	81 2f       	mov	r24, r17
   3e2f0:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e2f4:	8d 2f       	mov	r24, r29
   3e2f6:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer(wdata & 0xff);
   3e2fa:	8c 2f       	mov	r24, r28
   3e2fc:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	PROG_PORT |= (1<<PROGCS_PIN);
   3e300:	28 9a       	sbi	0x05, 0	; 5
   3e302:	85 e3       	ldi	r24, 0x35	; 53
   3e304:	8a 95       	dec	r24
   3e306:	f1 f7       	brne	.-4      	; 0x3e304 <FLASH_WriteByte+0x3c>
   3e308:	00 00       	nop
	_delay_us(10);
	FLASH_UntilReady();
}
   3e30a:	df 91       	pop	r29
   3e30c:	cf 91       	pop	r28
   3e30e:	1f 91       	pop	r17
   3e310:	0f 91       	pop	r16
	SPI_Transfer((faddr >> 8) & 0xff);
	SPI_Transfer(faddr & 0xff);
	SPI_Transfer(wdata & 0xff);
	PROG_PORT |= (1<<PROGCS_PIN);
	_delay_us(10);
	FLASH_UntilReady();
   3e312:	0d 94 c9 f0 	jmp	0x3e192	; 0x3e192 <FLASH_UntilReady>

0003e316 <FLASH_EraseSector>:
}

void FLASH_EraseSector(uint32_t faddr)
{
   3e316:	1f 93       	push	r17
   3e318:	cf 93       	push	r28
   3e31a:	df 93       	push	r29
   3e31c:	eb 01       	movw	r28, r22
   3e31e:	18 2f       	mov	r17, r24
	FLASH_UntilReady();
   3e320:	0f 94 c9 f0 	call	0x3e192	; 0x3e192 <FLASH_UntilReady>
	FLASH_WriteEnable();
   3e324:	0f 94 ab f0 	call	0x3e156	; 0x3e156 <FLASH_WriteEnable>
	PROG_PORT  &=  ~(1<<PROGCS_PIN);
   3e328:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x20);
   3e32a:	80 e2       	ldi	r24, 0x20	; 32
   3e32c:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e330:	81 2f       	mov	r24, r17
   3e332:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e336:	8d 2f       	mov	r24, r29
   3e338:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e33c:	8c 2f       	mov	r24, r28
   3e33e:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
	PROG_PORT  |=  (1<<PROGCS_PIN);
   3e342:	28 9a       	sbi	0x05, 0	; 5
   3e344:	85 e3       	ldi	r24, 0x35	; 53
   3e346:	8a 95       	dec	r24
   3e348:	f1 f7       	brne	.-4      	; 0x3e346 <FLASH_EraseSector+0x30>
   3e34a:	00 00       	nop
	_delay_us(10);
	FLASH_UntilReady();
}
   3e34c:	df 91       	pop	r29
   3e34e:	cf 91       	pop	r28
   3e350:	1f 91       	pop	r17
	SPI_Transfer((faddr >> 16) & 0xff);
	SPI_Transfer((faddr >> 8) & 0xff);
	SPI_Transfer(faddr & 0xff);
	PROG_PORT  |=  (1<<PROGCS_PIN);
	_delay_us(10);
	FLASH_UntilReady();
   3e352:	0d 94 c9 f0 	jmp	0x3e192	; 0x3e192 <FLASH_UntilReady>

0003e356 <main>:



//*****************************************************************************
int main(void)
{
   3e356:	cf 93       	push	r28
   3e358:	df 93       	push	r29
   3e35a:	cd b7       	in	r28, 0x3d	; 61
   3e35c:	de b7       	in	r29, 0x3e	; 62
   3e35e:	c9 52       	subi	r28, 0x29	; 41
   3e360:	d1 40       	sbci	r29, 0x01	; 1
   3e362:	0f b6       	in	r0, 0x3f	; 63
   3e364:	f8 94       	cli
   3e366:	de bf       	out	0x3e, r29	; 62
   3e368:	0f be       	out	0x3f, r0	; 63
   3e36a:	cd bf       	out	0x3d, r28	; 61
	unsigned long	boot_timer;
	unsigned int	boot_state;

	//*	some chips dont set the stack properly
	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
   3e36c:	01 e2       	ldi	r16, 0x21	; 33
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
   3e36e:	0e bf       	out	0x3e, r16	; 62
	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
   3e370:	0f ef       	ldi	r16, 0xFF	; 255
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
   3e372:	0d bf       	out	0x3d, r16	; 61


	//*	handle the watch dog timer
	uint8_t	mcuStatusReg;
	mcuStatusReg	=	MCUSR;
   3e374:	94 b7       	in	r25, 0x34	; 52

	__asm__ __volatile__ ("cli");
   3e376:	f8 94       	cli
	__asm__ __volatile__ ("wdr");
   3e378:	a8 95       	wdr
	MCUSR	=	0;
   3e37a:	14 be       	out	0x34, r1	; 52
	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
   3e37c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
   3e380:	88 61       	ori	r24, 0x18	; 24
   3e382:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	WDTCSR	=	0;
   3e386:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	__asm__ __volatile__ ("sei");
   3e38a:	78 94       	sei
	// check if WDT generated the reset, if so, go straight to app
	if (mcuStatusReg & _BV(WDRF))
   3e38c:	93 ff       	sbrs	r25, 3
   3e38e:	05 c0       	rjmp	.+10     	; 0x3e39a <main+0x44>
	{
		app_start();
   3e390:	e0 91 00 02 	lds	r30, 0x0200	; 0x800200 <_edata>
   3e394:	f0 91 01 02 	lds	r31, 0x0201	; 0x800201 <_edata+0x1>
   3e398:	19 95       	eicall
	 * Branch to bootloader or application code ?
	 */

#ifndef REMOVE_BOOTLOADER_LED
	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
	PROG_DDR	|=	(1<<PROGLED_PIN);
   3e39a:	26 9a       	sbi	0x04, 6	; 4
//	PROG_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
	PROG_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
   3e39c:	2e 9a       	sbi	0x05, 6	; 5
	}
#endif

#endif

	asm volatile ("nop");			// wait until port has changed
   3e39e:	00 00       	nop

	SPI_Init();
   3e3a0:	0f 94 9f f0 	call	0x3e13e	; 0x3e13e <SPI_Init>
	if(FLASH_Init())
   3e3a4:	0f 94 da f0 	call	0x3e1b4	; 0x3e1b4 <FLASH_Init>
   3e3a8:	88 23       	and	r24, r24
   3e3aa:	09 f4       	brne	.+2      	; 0x3e3ae <main+0x58>
   3e3ac:	05 c1       	rjmp	.+522    	; 0x3e5b8 <main+0x262>
		  
		uint32_t fDataAddr = BOOT_DATA_ADDR;
		uint32_t fCsumAddr = BOOT_CSUM_ADDR;
		uint8_t  fRdTries  = 0;
		uint16_t fii, fjj;
		uint16_t fBootStat = 0;
   3e3ae:	ce 5d       	subi	r28, 0xDE	; 222
   3e3b0:	de 4f       	sbci	r29, 0xFE	; 254
   3e3b2:	19 82       	std	Y+1, r1	; 0x01
   3e3b4:	18 82       	st	Y, r1
   3e3b6:	c2 52       	subi	r28, 0x22	; 34
   3e3b8:	d1 40       	sbci	r29, 0x01	; 1
		uint16_t fDataLen  = 0;
   3e3ba:	c0 5e       	subi	r28, 0xE0	; 224
   3e3bc:	de 4f       	sbci	r29, 0xFE	; 254
   3e3be:	19 82       	std	Y+1, r1	; 0x01
   3e3c0:	18 82       	st	Y, r1
   3e3c2:	c0 52       	subi	r28, 0x20	; 32
   3e3c4:	d1 40       	sbci	r29, 0x01	; 1
		uint16_t fChSumCal = 0;
		uint16_t fChSumRev = 0;
   3e3c6:	8e 01       	movw	r16, r28
   3e3c8:	02 5e       	subi	r16, 0xE2	; 226
   3e3ca:	1e 4f       	sbci	r17, 0xFE	; 254
   3e3cc:	f8 01       	movw	r30, r16
   3e3ce:	11 82       	std	Z+1, r1	; 0x01
   3e3d0:	10 82       	st	Z, r1
		uint32_t bootPageAddr = 0;

		FLASH_ReadWord(BOOT_STAT_ADDR, &fBootStat);
   3e3d2:	ae 01       	movw	r20, r28
   3e3d4:	4e 5d       	subi	r20, 0xDE	; 222
   3e3d6:	5e 4f       	sbci	r21, 0xFE	; 254
   3e3d8:	60 e0       	ldi	r22, 0x00	; 0
   3e3da:	70 e1       	ldi	r23, 0x10	; 16
   3e3dc:	80 e0       	ldi	r24, 0x00	; 0
   3e3de:	90 e0       	ldi	r25, 0x00	; 0
   3e3e0:	0f 94 35 f1 	call	0x3e26a	; 0x3e26a <FLASH_ReadWord>
		  
		if(fBootStat == 0x2323)
   3e3e4:	ce 5d       	subi	r28, 0xDE	; 222
   3e3e6:	de 4f       	sbci	r29, 0xFE	; 254
   3e3e8:	88 81       	ld	r24, Y
   3e3ea:	99 81       	ldd	r25, Y+1	; 0x01
   3e3ec:	c2 52       	subi	r28, 0x22	; 34
   3e3ee:	d1 40       	sbci	r29, 0x01	; 1
   3e3f0:	83 32       	cpi	r24, 0x23	; 35
   3e3f2:	93 42       	sbci	r25, 0x23	; 35
   3e3f4:	09 f0       	breq	.+2      	; 0x3e3f8 <main+0xa2>
   3e3f6:	e0 c0       	rjmp	.+448    	; 0x3e5b8 <main+0x262>
		{
			FLASH_ReadWord((BOOT_STAT_ADDR+2), &fDataLen);
   3e3f8:	ae 01       	movw	r20, r28
   3e3fa:	40 5e       	subi	r20, 0xE0	; 224
   3e3fc:	5e 4f       	sbci	r21, 0xFE	; 254
   3e3fe:	62 e0       	ldi	r22, 0x02	; 2
   3e400:	70 e1       	ldi	r23, 0x10	; 16
   3e402:	80 e0       	ldi	r24, 0x00	; 0
   3e404:	90 e0       	ldi	r25, 0x00	; 0
   3e406:	0f 94 35 f1 	call	0x3e26a	; 0x3e26a <FLASH_ReadWord>
		uint16_t fii, fjj;
		uint16_t fBootStat = 0;
		uint16_t fDataLen  = 0;
		uint16_t fChSumCal = 0;
		uint16_t fChSumRev = 0;
		uint32_t bootPageAddr = 0;
   3e40a:	c1 2c       	mov	r12, r1
   3e40c:	d1 2c       	mov	r13, r1
   3e40e:	76 01       	movw	r14, r12
		  
		if(fBootStat == 0x2323)
		{
			FLASH_ReadWord((BOOT_STAT_ADDR+2), &fDataLen);

			for(fjj=0; fjj<fDataLen; fjj++)
   3e410:	ca 5d       	subi	r28, 0xDA	; 218
   3e412:	de 4f       	sbci	r29, 0xFE	; 254
   3e414:	19 82       	std	Y+1, r1	; 0x01
   3e416:	18 82       	st	Y, r1
   3e418:	c6 52       	subi	r28, 0x26	; 38
   3e41a:	d1 40       	sbci	r29, 0x01	; 1
	SPI_Init();
	if(FLASH_Init())
	{
		  
		uint32_t fDataAddr = BOOT_DATA_ADDR;
		uint32_t fCsumAddr = BOOT_CSUM_ADDR;
   3e41c:	81 2c       	mov	r8, r1
   3e41e:	31 e1       	ldi	r19, 0x11	; 17
   3e420:	93 2e       	mov	r9, r19
   3e422:	a1 2c       	mov	r10, r1
   3e424:	b1 2c       	mov	r11, r1

	SPI_Init();
	if(FLASH_Init())
	{
		  
		uint32_t fDataAddr = BOOT_DATA_ADDR;
   3e426:	41 2c       	mov	r4, r1
   3e428:	40 e2       	ldi	r20, 0x20	; 32
   3e42a:	54 2e       	mov	r5, r20
   3e42c:	61 2c       	mov	r6, r1
   3e42e:	71 2c       	mov	r7, r1
   3e430:	9e 01       	movw	r18, r28
   3e432:	2f 5f       	subi	r18, 0xFF	; 255
   3e434:	3e 4f       	sbci	r19, 0xFE	; 254
   3e436:	cc 5d       	subi	r28, 0xDC	; 220
   3e438:	de 4f       	sbci	r29, 0xFE	; 254
   3e43a:	39 83       	std	Y+1, r19	; 0x01
   3e43c:	28 83       	st	Y, r18
   3e43e:	c4 52       	subi	r28, 0x24	; 36
   3e440:	d1 40       	sbci	r29, 0x01	; 1
		  
		if(fBootStat == 0x2323)
		{
			FLASH_ReadWord((BOOT_STAT_ADDR+2), &fDataLen);

			for(fjj=0; fjj<fDataLen; fjj++)
   3e442:	c0 5e       	subi	r28, 0xE0	; 224
   3e444:	de 4f       	sbci	r29, 0xFE	; 254
   3e446:	88 81       	ld	r24, Y
   3e448:	99 81       	ldd	r25, Y+1	; 0x01
   3e44a:	c0 52       	subi	r28, 0x20	; 32
   3e44c:	d1 40       	sbci	r29, 0x01	; 1
   3e44e:	ca 5d       	subi	r28, 0xDA	; 218
   3e450:	de 4f       	sbci	r29, 0xFE	; 254
   3e452:	e8 81       	ld	r30, Y
   3e454:	f9 81       	ldd	r31, Y+1	; 0x01
   3e456:	c6 52       	subi	r28, 0x26	; 38
   3e458:	d1 40       	sbci	r29, 0x01	; 1
   3e45a:	e8 17       	cp	r30, r24
   3e45c:	f9 07       	cpc	r31, r25
   3e45e:	08 f0       	brcs	.+2      	; 0x3e462 <main+0x10c>
   3e460:	a5 c0       	rjmp	.+330    	; 0x3e5ac <main+0x256>
			{
				fRdTries  = 0;
				fChSumCal = 0;
				PROG_PORT &= ~(1<<PROGCS_PIN);
   3e462:	28 98       	cbi	0x05, 0	; 5
				SPI_Transfer(0x03);
   3e464:	83 e0       	ldi	r24, 0x03	; 3
   3e466:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
				SPI_Transfer((fDataAddr >> 16) & 0xff);
   3e46a:	86 2d       	mov	r24, r6
   3e46c:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
				SPI_Transfer((fDataAddr >> 8) & 0xff);
   3e470:	85 2d       	mov	r24, r5
   3e472:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
				SPI_Transfer(fDataAddr & 0xff);
   3e476:	80 e0       	ldi	r24, 0x00	; 0
   3e478:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
   3e47c:	ce 01       	movw	r24, r28
   3e47e:	01 96       	adiw	r24, 0x01	; 1
   3e480:	1c 01       	movw	r2, r24
   3e482:	c8 5d       	subi	r28, 0xD8	; 216
   3e484:	de 4f       	sbci	r29, 0xFE	; 254
   3e486:	99 83       	std	Y+1, r25	; 0x01
   3e488:	88 83       	st	Y, r24
   3e48a:	c8 52       	subi	r28, 0x28	; 40
   3e48c:	d1 40       	sbci	r29, 0x01	; 1
			FLASH_ReadWord((BOOT_STAT_ADDR+2), &fDataLen);

			for(fjj=0; fjj<fDataLen; fjj++)
			{
				fRdTries  = 0;
				fChSumCal = 0;
   3e48e:	00 e0       	ldi	r16, 0x00	; 0
   3e490:	10 e0       	ldi	r17, 0x00	; 0
				SPI_Transfer((fDataAddr >> 16) & 0xff);
				SPI_Transfer((fDataAddr >> 8) & 0xff);
				SPI_Transfer(fDataAddr & 0xff);
				for(fii=0; fii<256; fii++)
				{
					msgBuffer[fii] = SPI_Transfer(0);
   3e492:	80 e0       	ldi	r24, 0x00	; 0
   3e494:	0f 94 a4 f0 	call	0x3e148	; 0x3e148 <SPI_Transfer>
   3e498:	c8 5d       	subi	r28, 0xD8	; 216
   3e49a:	de 4f       	sbci	r29, 0xFE	; 254
   3e49c:	e8 81       	ld	r30, Y
   3e49e:	f9 81       	ldd	r31, Y+1	; 0x01
   3e4a0:	c8 52       	subi	r28, 0x28	; 40
   3e4a2:	d1 40       	sbci	r29, 0x01	; 1
   3e4a4:	81 93       	st	Z+, r24
   3e4a6:	c8 5d       	subi	r28, 0xD8	; 216
   3e4a8:	de 4f       	sbci	r29, 0xFE	; 254
   3e4aa:	f9 83       	std	Y+1, r31	; 0x01
   3e4ac:	e8 83       	st	Y, r30
   3e4ae:	c8 52       	subi	r28, 0x28	; 40
   3e4b0:	d1 40       	sbci	r29, 0x01	; 1
					fChSumCal += msgBuffer[fii];
   3e4b2:	08 0f       	add	r16, r24
   3e4b4:	11 1d       	adc	r17, r1
				PROG_PORT &= ~(1<<PROGCS_PIN);
				SPI_Transfer(0x03);
				SPI_Transfer((fDataAddr >> 16) & 0xff);
				SPI_Transfer((fDataAddr >> 8) & 0xff);
				SPI_Transfer(fDataAddr & 0xff);
				for(fii=0; fii<256; fii++)
   3e4b6:	cc 5d       	subi	r28, 0xDC	; 220
   3e4b8:	de 4f       	sbci	r29, 0xFE	; 254
   3e4ba:	28 81       	ld	r18, Y
   3e4bc:	39 81       	ldd	r19, Y+1	; 0x01
   3e4be:	c4 52       	subi	r28, 0x24	; 36
   3e4c0:	d1 40       	sbci	r29, 0x01	; 1
   3e4c2:	2e 17       	cp	r18, r30
   3e4c4:	3f 07       	cpc	r19, r31
   3e4c6:	29 f7       	brne	.-54     	; 0x3e492 <main+0x13c>
				{
					msgBuffer[fii] = SPI_Transfer(0);
					fChSumCal += msgBuffer[fii];
				}
				PROG_PORT |= (1<<PROGCS_PIN);
   3e4c8:	28 9a       	sbi	0x05, 0	; 5
				fDataAddr += EXMEM_PAGE_SIZE;
   3e4ca:	3f ef       	ldi	r19, 0xFF	; 255
   3e4cc:	53 1a       	sub	r5, r19
   3e4ce:	63 0a       	sbc	r6, r19
   3e4d0:	73 0a       	sbc	r7, r19
   3e4d2:	85 e3       	ldi	r24, 0x35	; 53
   3e4d4:	8a 95       	dec	r24
   3e4d6:	f1 f7       	brne	.-4      	; 0x3e4d4 <main+0x17e>
   3e4d8:	00 00       	nop
				_delay_us(10);

				FLASH_ReadWord(fCsumAddr, &fChSumRev);
   3e4da:	ae 01       	movw	r20, r28
   3e4dc:	42 5e       	subi	r20, 0xE2	; 226
   3e4de:	5e 4f       	sbci	r21, 0xFE	; 254
   3e4e0:	c5 01       	movw	r24, r10
   3e4e2:	b4 01       	movw	r22, r8
   3e4e4:	0f 94 35 f1 	call	0x3e26a	; 0x3e26a <FLASH_ReadWord>
				  
				if(fChSumRev == fChSumCal)
   3e4e8:	c2 5e       	subi	r28, 0xE2	; 226
   3e4ea:	de 4f       	sbci	r29, 0xFE	; 254
   3e4ec:	88 81       	ld	r24, Y
   3e4ee:	99 81       	ldd	r25, Y+1	; 0x01
   3e4f0:	ce 51       	subi	r28, 0x1E	; 30
   3e4f2:	d1 40       	sbci	r29, 0x01	; 1
   3e4f4:	80 17       	cp	r24, r16
   3e4f6:	91 07       	cpc	r25, r17
   3e4f8:	09 f0       	breq	.+2      	; 0x3e4fc <main+0x1a6>
   3e4fa:	4a c0       	rjmp	.+148    	; 0x3e590 <main+0x23a>
					uint8_t  fLSByte, fMSByte;
					uint16_t fData;
					
					address = bootPageAddr;
								
					if(bootPageAddr < APP_END)				// erase only main section (bootloader protection)
   3e4fc:	c1 14       	cp	r12, r1
   3e4fe:	90 ec       	ldi	r25, 0xC0	; 192
   3e500:	d9 06       	cpc	r13, r25
   3e502:	93 e0       	ldi	r25, 0x03	; 3
   3e504:	e9 06       	cpc	r14, r25
   3e506:	f1 04       	cpc	r15, r1
   3e508:	50 f4       	brcc	.+20     	; 0x3e51e <main+0x1c8>
					{
					    boot_page_erase(bootPageAddr);		// Perform page erase
   3e50a:	83 e0       	ldi	r24, 0x03	; 3
   3e50c:	f6 01       	movw	r30, r12
   3e50e:	e0 92 5b 00 	sts	0x005B, r14	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
   3e512:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e516:	e8 95       	spm
					    boot_spm_busy_wait();				// Wait until the memory is erased.
   3e518:	07 b6       	in	r0, 0x37	; 55
   3e51a:	00 fc       	sbrc	r0, 0
   3e51c:	fd cf       	rjmp	.-6      	; 0x3e518 <main+0x1c2>
   3e51e:	b7 01       	movw	r22, r14
   3e520:	a6 01       	movw	r20, r12
					{
						fLSByte = msgBuffer[fii];
						fMSByte = msgBuffer[fii+1];
						fData   = (fMSByte << 8) | fLSByte;
						          
						boot_page_fill(address, fData);		// fill boot page
   3e522:	f1 01       	movw	r30, r2
   3e524:	81 81       	ldd	r24, Z+1	; 0x01
   3e526:	90 e0       	ldi	r25, 0x00	; 0
   3e528:	98 2f       	mov	r25, r24
   3e52a:	88 27       	eor	r24, r24
   3e52c:	20 81       	ld	r18, Z
   3e52e:	82 2b       	or	r24, r18
   3e530:	21 e0       	ldi	r18, 0x01	; 1
   3e532:	0c 01       	movw	r0, r24
   3e534:	fa 01       	movw	r30, r20
   3e536:	60 93 5b 00 	sts	0x005B, r22	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
   3e53a:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e53e:	e8 95       	spm
   3e540:	11 24       	eor	r1, r1
						address += 2;						// inc boot page address
   3e542:	4e 5f       	subi	r20, 0xFE	; 254
   3e544:	5f 4f       	sbci	r21, 0xFF	; 255
   3e546:	6f 4f       	sbci	r22, 0xFF	; 255
   3e548:	7f 4f       	sbci	r23, 0xFF	; 255
   3e54a:	32 e0       	ldi	r19, 0x02	; 2
   3e54c:	23 0e       	add	r2, r19
   3e54e:	31 1c       	adc	r3, r1
					{
					    boot_page_erase(bootPageAddr);		// Perform page erase
					    boot_spm_busy_wait();				// Wait until the memory is erased.
					}
					
					for(fii=0; fii<256; fii+=2)
   3e550:	cc 5d       	subi	r28, 0xDC	; 220
   3e552:	de 4f       	sbci	r29, 0xFE	; 254
   3e554:	88 81       	ld	r24, Y
   3e556:	99 81       	ldd	r25, Y+1	; 0x01
   3e558:	c4 52       	subi	r28, 0x24	; 36
   3e55a:	d1 40       	sbci	r29, 0x01	; 1
   3e55c:	82 15       	cp	r24, r2
   3e55e:	93 05       	cpc	r25, r3
   3e560:	01 f7       	brne	.-64     	; 0x3e522 <main+0x1cc>
						          
						boot_page_fill(address, fData);		// fill boot page
						address += 2;						// inc boot page address
					}

					boot_page_write(bootPageAddr);			// write boot page
   3e562:	95 e0       	ldi	r25, 0x05	; 5
   3e564:	f6 01       	movw	r30, r12
   3e566:	e0 92 5b 00 	sts	0x005B, r14	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
   3e56a:	90 93 57 00 	sts	0x0057, r25	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e56e:	e8 95       	spm
					boot_spm_busy_wait();
   3e570:	07 b6       	in	r0, 0x37	; 55
   3e572:	00 fc       	sbrc	r0, 0
   3e574:	fd cf       	rjmp	.-6      	; 0x3e570 <main+0x21a>
					boot_rww_enable();						// Re-enable the RWW section
   3e576:	e1 e1       	ldi	r30, 0x11	; 17
   3e578:	e0 93 57 00 	sts	0x0057, r30	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e57c:	e8 95       	spm
					
					bootPageAddr += SPM_PAGESIZE;			// SPM_PAGESIZE=256  point to next page to be erase
   3e57e:	ff ef       	ldi	r31, 0xFF	; 255
   3e580:	df 1a       	sub	r13, r31
   3e582:	ef 0a       	sbc	r14, r31
   3e584:	ff 0a       	sbc	r15, r31
					fCsumAddr += 2;
   3e586:	22 e0       	ldi	r18, 0x02	; 2
   3e588:	82 0e       	add	r8, r18
   3e58a:	91 1c       	adc	r9, r1
   3e58c:	a1 1c       	adc	r10, r1
   3e58e:	b1 1c       	adc	r11, r1
		  
		if(fBootStat == 0x2323)
		{
			FLASH_ReadWord((BOOT_STAT_ADDR+2), &fDataLen);

			for(fjj=0; fjj<fDataLen; fjj++)
   3e590:	ca 5d       	subi	r28, 0xDA	; 218
   3e592:	de 4f       	sbci	r29, 0xFE	; 254
   3e594:	88 81       	ld	r24, Y
   3e596:	99 81       	ldd	r25, Y+1	; 0x01
   3e598:	c6 52       	subi	r28, 0x26	; 38
   3e59a:	d1 40       	sbci	r29, 0x01	; 1
   3e59c:	01 96       	adiw	r24, 0x01	; 1
   3e59e:	ca 5d       	subi	r28, 0xDA	; 218
   3e5a0:	de 4f       	sbci	r29, 0xFE	; 254
   3e5a2:	99 83       	std	Y+1, r25	; 0x01
   3e5a4:	88 83       	st	Y, r24
   3e5a6:	c6 52       	subi	r28, 0x26	; 38
   3e5a8:	d1 40       	sbci	r29, 0x01	; 1
   3e5aa:	4b cf       	rjmp	.-362    	; 0x3e442 <main+0xec>
						break;
					}
				}
			}
			
			FLASH_EraseSector(BOOT_STAT_ADDR);		// erase exmem page
   3e5ac:	60 e0       	ldi	r22, 0x00	; 0
   3e5ae:	70 e1       	ldi	r23, 0x10	; 16
   3e5b0:	80 e0       	ldi	r24, 0x00	; 0
   3e5b2:	90 e0       	ldi	r25, 0x00	; 0
   3e5b4:	0f 94 8b f1 	call	0x3e316	; 0x3e316 <FLASH_EraseSector>
	PROG_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
#endif


#ifndef REMOVE_BOOTLOADER_LED
	PROG_DDR	&=	~(1<<PROGLED_PIN);	// set to default
   3e5b8:	26 98       	cbi	0x04, 6	; 4
	PROG_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
   3e5ba:	2e 98       	cbi	0x05, 6	; 5
//	PROG_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
	delay_ms(100);							// delay after exit
   3e5bc:	84 e6       	ldi	r24, 0x64	; 100
   3e5be:	90 e0       	ldi	r25, 0x00	; 0
   3e5c0:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <delay_ms>
#endif


	asm volatile ("nop");			// wait until port has changed
   3e5c4:	00 00       	nop
	/*
	 * Now leave bootloader
	 */

//	UART_STATUS_REG	&=	0xfd;
	boot_rww_enable();				// enable application section
   3e5c6:	81 e1       	ldi	r24, 0x11	; 17
   3e5c8:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e5cc:	e8 95       	spm


	asm volatile(
   3e5ce:	ee 27       	eor	r30, r30
   3e5d0:	ff 27       	eor	r31, r31
   3e5d2:	09 94       	ijmp
   3e5d4:	ff cf       	rjmp	.-2      	; 0x3e5d4 <main+0x27e>

0003e5d6 <_exit>:
   3e5d6:	f8 94       	cli

0003e5d8 <__stop_program>:
   3e5d8:	ff cf       	rjmp	.-2      	; 0x3e5d8 <__stop_program>
