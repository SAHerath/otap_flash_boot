   1               		.file	"bootSAH_3.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.init9,"ax",@progbits
  12               	.global	__jumpMain
  14               	__jumpMain:
  15               	.LFB11:
  16               		.file 1 "bootSAH_3.c"
   1:bootSAH_3.c   **** /*****************************************************************************
   2:bootSAH_3.c   **** Title:     STK500v2 compatible bootloader
   3:bootSAH_3.c   ****            Modified for Wiring board ATMega128-16MHz
   4:bootSAH_3.c   **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:bootSAH_3.c   **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:bootSAH_3.c   **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:bootSAH_3.c   **** License:   GNU General Public License
   8:bootSAH_3.c   **** 
   9:bootSAH_3.c   **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:bootSAH_3.c   **** Date:      17 October 2007
  11:bootSAH_3.c   **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:bootSAH_3.c   **** Compiler:  WINAVR20060421
  13:bootSAH_3.c   **** Description: add timeout feature like previous Wiring bootloader
  14:bootSAH_3.c   **** 
  15:bootSAH_3.c   **** Modified:  Supun Herath <supun@utequip.com> 
  16:bootSAH_3.c   **** Date:      20 Aug 2019
  17:bootSAH_3.c   **** Update:
  18:bootSAH_3.c   **** Compiler:  avr-gcc (AVR_8_bit_GNU_Toolchain_3.6.1_1750) 5.4.0
  19:bootSAH_3.c   **** Description: add capability to write internal flash through external flash chip using spi protocol
  20:bootSAH_3.c   **** 
  21:bootSAH_3.c   **** DESCRIPTION:
  22:bootSAH_3.c   ****     This program allows an AVR with bootloader capabilities to
  23:bootSAH_3.c   ****     read/write its own Flash/EEprom. To enter Programming mode
  24:bootSAH_3.c   ****     an input pin is checked. If this pin is pulled low, programming mode
  25:bootSAH_3.c   ****     is entered. If not, normal execution is done from $0000
  26:bootSAH_3.c   ****     "reset" vector in Application area.
  27:bootSAH_3.c   ****     Size fits into a 1024 word bootloader section
  28:bootSAH_3.c   **** 	when compiled with avr-gcc 4.1
  29:bootSAH_3.c   **** 	(direct replace on Wiring Board without fuse setting changed)
  30:bootSAH_3.c   **** 
  31:bootSAH_3.c   **** USAGE:
  32:bootSAH_3.c   ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  33:bootSAH_3.c   ****     - Set baud rate below (AVRISP only works with 115200 bps)
  34:bootSAH_3.c   ****     - compile/link the bootloader with the supplied Makefile
  35:bootSAH_3.c   ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  36:bootSAH_3.c   ****       for boot-size 1024 words:  program BOOTSZ01
  37:bootSAH_3.c   ****     - enable the BOOT Reset Vector (program BOOTRST)
  38:bootSAH_3.c   ****     - Upload the hex file to the AVR using any ISP programmer
  39:bootSAH_3.c   ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  40:bootSAH_3.c   ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  41:bootSAH_3.c   ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  42:bootSAH_3.c   ****     - AVRISP will detect the bootloader
  43:bootSAH_3.c   ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  44:bootSAH_3.c   **** 
  45:bootSAH_3.c   **** Note:
  46:bootSAH_3.c   ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  47:bootSAH_3.c   ****     is not implemented, due to AVRStudio limitations.
  48:bootSAH_3.c   ****     Flash is always erased before programming.
  49:bootSAH_3.c   **** 
  50:bootSAH_3.c   **** 	AVRdude:
  51:bootSAH_3.c   **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  52:bootSAH_3.c   **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  53:bootSAH_3.c   **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  54:bootSAH_3.c   **** 
  55:bootSAH_3.c   **** NOTES:
  56:bootSAH_3.c   ****     Based on Atmel Application Note AVR109 - Self-programming
  57:bootSAH_3.c   ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  58:bootSAH_3.c   **** 
  59:bootSAH_3.c   **** LICENSE:
  60:bootSAH_3.c   ****     Copyright (C) 2006 Peter Fleury
  61:bootSAH_3.c   **** 
  62:bootSAH_3.c   ****     This program is free software; you can redistribute it and/or modify
  63:bootSAH_3.c   ****     it under the terms of the GNU General Public License as published by
  64:bootSAH_3.c   ****     the Free Software Foundation; either version 2 of the License, or
  65:bootSAH_3.c   ****     any later version.
  66:bootSAH_3.c   **** 
  67:bootSAH_3.c   ****     This program is distributed in the hope that it will be useful,
  68:bootSAH_3.c   ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  69:bootSAH_3.c   ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  70:bootSAH_3.c   ****     GNU General Public License for more details.
  71:bootSAH_3.c   **** 
  72:bootSAH_3.c   **** *****************************************************************************/
  73:bootSAH_3.c   **** 
  74:bootSAH_3.c   **** //************************************************************************
  75:bootSAH_3.c   **** //*	Edit History
  76:bootSAH_3.c   **** //************************************************************************
  77:bootSAH_3.c   **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  78:bootSAH_3.c   **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  79:bootSAH_3.c   **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  80:bootSAH_3.c   **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  81:bootSAH_3.c   **** //*	Jul  8,	2010	<MLS> Adding monitor code
  82:bootSAH_3.c   **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  83:bootSAH_3.c   **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  84:bootSAH_3.c   **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  85:bootSAH_3.c   **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  86:bootSAH_3.c   **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  87:bootSAH_3.c   **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  88:bootSAH_3.c   **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  89:bootSAH_3.c   **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  90:bootSAH_3.c   **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  91:bootSAH_3.c   **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  92:bootSAH_3.c   **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  93:bootSAH_3.c   **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  94:bootSAH_3.c   **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  95:bootSAH_3.c   **** //************************************************************************
  96:bootSAH_3.c   **** 
  97:bootSAH_3.c   **** //************************************************************************
  98:bootSAH_3.c   **** //*	these are used to test issues
  99:bootSAH_3.c   **** //*	http://code.google.com/p/arduino/issues/detail?id=505
 100:bootSAH_3.c   **** //*	Reported by mark.stubbs, Mar 14, 2011
 101:bootSAH_3.c   **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
 102:bootSAH_3.c   **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
 103:bootSAH_3.c   **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
 104:bootSAH_3.c   **** #define	_FIX_ISSUE_505_
 105:bootSAH_3.c   **** //************************************************************************
 106:bootSAH_3.c   **** 
 107:bootSAH_3.c   **** #include	<inttypes.h>
 108:bootSAH_3.c   **** #include	<avr/io.h>
 109:bootSAH_3.c   **** #include	<avr/interrupt.h>
 110:bootSAH_3.c   **** #include	<avr/boot.h>
 111:bootSAH_3.c   **** #include	<avr/pgmspace.h>
 112:bootSAH_3.c   **** #include	<util/delay.h>
 113:bootSAH_3.c   **** #include	<avr/eeprom.h>
 114:bootSAH_3.c   **** #include	<avr/common.h>
 115:bootSAH_3.c   **** #include	<stdlib.h>
 116:bootSAH_3.c   **** #include	"command.h"
 117:bootSAH_3.c   **** 
 118:bootSAH_3.c   **** 
 119:bootSAH_3.c   **** //#define	_DEBUG_WITH_LEDS_
 120:bootSAH_3.c   **** 
 121:bootSAH_3.c   **** 
 122:bootSAH_3.c   **** /*
 123:bootSAH_3.c   ****  * Uncomment the following lines to save code space
 124:bootSAH_3.c   ****  */
 125:bootSAH_3.c   **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 126:bootSAH_3.c   **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 127:bootSAH_3.c   **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 128:bootSAH_3.c   **** //
 129:bootSAH_3.c   **** 
 130:bootSAH_3.c   **** 
 131:bootSAH_3.c   **** 
 132:bootSAH_3.c   **** 
 133:bootSAH_3.c   **** //************************************************************************
 134:bootSAH_3.c   **** //*	LED on pin "PROGLED_PIN" on port "PROG_PORT"
 135:bootSAH_3.c   **** //*	indicates that bootloader is active
 136:bootSAH_3.c   **** //*	PG2 -> LED on Wiring board
 137:bootSAH_3.c   **** //************************************************************************
 138:bootSAH_3.c   **** #define	BLINK_LED_WHILE_WAITING
 139:bootSAH_3.c   **** 
 140:bootSAH_3.c   **** #define PROG_PORT		PORTB
 141:bootSAH_3.c   **** #define PROG_DDR		DDRB
 142:bootSAH_3.c   **** #define PROGLED_PIN		PINB6
 143:bootSAH_3.c   **** #define PROGCS_PIN		PINB0
 144:bootSAH_3.c   **** 
 145:bootSAH_3.c   **** #define EXMEM_JEDEC		0xEF4017
 146:bootSAH_3.c   **** #define EXMEM_SECT_SIZE	4096		// bytes
 147:bootSAH_3.c   **** #define EXMEM_PAGE_SIZE 256			// bytes
 148:bootSAH_3.c   **** 
 149:bootSAH_3.c   **** #define BOOT_EROR_ADDR  256
 150:bootSAH_3.c   **** #define BOOT_STAT_ADDR  4096    // byte addr
 151:bootSAH_3.c   **** #define BOOT_CSUM_ADDR  4352    // byte addr
 152:bootSAH_3.c   **** #define BOOT_DATA_ADDR  8192    // byte addr
 153:bootSAH_3.c   **** 
 154:bootSAH_3.c   **** /*
 155:bootSAH_3.c   ****  * define CPU frequency in Mhz here if not defined in Makefile
 156:bootSAH_3.c   ****  */
 157:bootSAH_3.c   **** #ifndef F_CPU
 158:bootSAH_3.c   **** 	#define F_CPU 16000000UL
 159:bootSAH_3.c   **** #endif
 160:bootSAH_3.c   **** 
 161:bootSAH_3.c   **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 162:bootSAH_3.c   **** 
 163:bootSAH_3.c   **** 
 164:bootSAH_3.c   **** /*
 165:bootSAH_3.c   ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 166:bootSAH_3.c   ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 167:bootSAH_3.c   ****  */
 168:bootSAH_3.c   **** //#define BOOTSIZE 1024
 169:bootSAH_3.c   **** #if FLASHEND > 0x0F000
 170:bootSAH_3.c   **** 	#define BOOTSIZE 8192
 171:bootSAH_3.c   **** #else
 172:bootSAH_3.c   **** 	#define BOOTSIZE 2048
 173:bootSAH_3.c   **** #endif
 174:bootSAH_3.c   **** 
 175:bootSAH_3.c   **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 176:bootSAH_3.c   **** 
 177:bootSAH_3.c   **** 
 178:bootSAH_3.c   **** /*
 179:bootSAH_3.c   ****  * use 16bit address variable for ATmegas with <= 64K flash
 180:bootSAH_3.c   ****  */
 181:bootSAH_3.c   **** #if defined(RAMPZ)
 182:bootSAH_3.c   **** 	typedef uint32_t address_t;
 183:bootSAH_3.c   **** #else
 184:bootSAH_3.c   **** 	typedef uint16_t address_t;
 185:bootSAH_3.c   **** #endif
 186:bootSAH_3.c   **** 
 187:bootSAH_3.c   **** 
 188:bootSAH_3.c   **** /*
 189:bootSAH_3.c   ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 190:bootSAH_3.c   ****  * to reduce the code size, we need to provide our own initialization
 191:bootSAH_3.c   ****  */
 192:bootSAH_3.c   **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 193:bootSAH_3.c   **** #include <avr/sfr_defs.h>
 194:bootSAH_3.c   **** 
 195:bootSAH_3.c   **** //#define	SPH_REG	0x3E
 196:bootSAH_3.c   **** //#define	SPL_REG	0x3D
 197:bootSAH_3.c   **** 
 198:bootSAH_3.c   **** //*****************************************************************************
 199:bootSAH_3.c   **** void __jumpMain(void)
 200:bootSAH_3.c   **** {
  17               		.loc 1 200 0
  18               		.cfi_startproc
  19               	/* prologue: naked */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 201:bootSAH_3.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 202:bootSAH_3.c   **** //*	the first line did not do the job on the ATmega128
 203:bootSAH_3.c   **** 
 204:bootSAH_3.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
  23               		.loc 1 204 0
  24               	/* #APP */
  25               	 ;  204 "bootSAH_3.c" 1
  26               		.set __stack, 8703
  27               	 ;  0 "" 2
 205:bootSAH_3.c   **** 
 206:bootSAH_3.c   **** //*	set stack pointer to top of RAM
 207:bootSAH_3.c   **** 
 208:bootSAH_3.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
  28               		.loc 1 208 0
  29               	 ;  208 "bootSAH_3.c" 1
  30 0000 01E2      		ldi	16, 33
  31               	 ;  0 "" 2
 209:bootSAH_3.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  32               		.loc 1 209 0
  33               	 ;  209 "bootSAH_3.c" 1
  34 0002 0EBF      		out 62,16
  35               	 ;  0 "" 2
 210:bootSAH_3.c   **** 
 211:bootSAH_3.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
  36               		.loc 1 211 0
  37               	 ;  211 "bootSAH_3.c" 1
  38 0004 0FEF      		ldi	16, 255
  39               	 ;  0 "" 2
 212:bootSAH_3.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  40               		.loc 1 212 0
  41               	 ;  212 "bootSAH_3.c" 1
  42 0006 0DBF      		out 61,16
  43               	 ;  0 "" 2
 213:bootSAH_3.c   **** 
 214:bootSAH_3.c   **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
  44               		.loc 1 214 0
  45               	 ;  214 "bootSAH_3.c" 1
  46 0008 1124      		clr __zero_reg__
  47               	 ;  0 "" 2
 215:bootSAH_3.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  48               		.loc 1 215 0
  49               	 ;  215 "bootSAH_3.c" 1
  50 000a 1FBE      		out 63, __zero_reg__
  51               	 ;  0 "" 2
 216:bootSAH_3.c   **** 	asm volatile ( "jmp main");												// jump to main()
  52               		.loc 1 216 0
  53               	 ;  216 "bootSAH_3.c" 1
  54 000c 0C94 0000 		jmp main
  55               	 ;  0 "" 2
  56               	/* epilogue start */
 217:bootSAH_3.c   **** }
  57               		.loc 1 217 0
  58               	/* #NOAPP */
  59               		.cfi_endproc
  60               	.LFE11:
  62               		.text
  63               	.global	delay_ms
  65               	delay_ms:
  66               	.LFB12:
 218:bootSAH_3.c   **** 
 219:bootSAH_3.c   **** 
 220:bootSAH_3.c   **** //*****************************************************************************
 221:bootSAH_3.c   **** void delay_ms(unsigned int timedelay)
 222:bootSAH_3.c   **** {
  67               		.loc 1 222 0
  68               		.cfi_startproc
  69               	.LVL0:
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 0 */
  73               	.L__stack_usage = 0
 223:bootSAH_3.c   **** 	unsigned int i;
 224:bootSAH_3.c   **** 	for (i=0;i<timedelay;i++)
  74               		.loc 1 224 0
  75 0000 20E0      		ldi r18,0
  76 0002 30E0      		ldi r19,0
  77               	.LVL1:
  78               	.L3:
  79               		.loc 1 224 0 is_stmt 0 discriminator 1
  80 0004 2817      		cp r18,r24
  81 0006 3907      		cpc r19,r25
  82 0008 01F0      		breq .L6
  83               	.LVL2:
  84               	.LBB26:
  85               	.LBB27:
  86               		.file 2 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ut
   1:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  87               		.loc 2 187 0 is_stmt 1
  88 000a EFEC      		ldi r30,lo8(1999)
  89 000c F7E0      		ldi r31,hi8(1999)
  90 000e 3197      	1:	sbiw r30,1
  91 0010 01F4      		brne 1b
  92 0012 00C0      		rjmp .
  93 0014 0000      		nop
  94               	.LVL3:
  95               	.LBE27:
  96               	.LBE26:
  97               		.loc 1 224 0
  98 0016 2F5F      		subi r18,-1
  99 0018 3F4F      		sbci r19,-1
 100               	.LVL4:
 101 001a 00C0      		rjmp .L3
 102               	.L6:
 103               	/* epilogue start */
 225:bootSAH_3.c   **** 	{
 226:bootSAH_3.c   **** 		_delay_ms(0.5);
 227:bootSAH_3.c   **** 	}
 228:bootSAH_3.c   **** }
 104               		.loc 1 228 0
 105 001c 0895      		ret
 106               		.cfi_endproc
 107               	.LFE12:
 109               	.global	SPI_Init
 111               	SPI_Init:
 112               	.LFB23:
 229:bootSAH_3.c   **** 
 230:bootSAH_3.c   **** 
 231:bootSAH_3.c   **** 
 232:bootSAH_3.c   **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 233:bootSAH_3.c   **** //*****************************************************************************
 234:bootSAH_3.c   **** 
 235:bootSAH_3.c   **** 			
 236:bootSAH_3.c   **** //*	for watch dog timer startup
 237:bootSAH_3.c   **** void (*app_start)(void) = 0x0000;
 238:bootSAH_3.c   **** 
 239:bootSAH_3.c   **** //function prototypes//
 240:bootSAH_3.c   **** uint8_t FLASH_Init(void);
 241:bootSAH_3.c   **** void FLASH_WriteEnable(void);
 242:bootSAH_3.c   **** void FLASH_ResetEnable(void);
 243:bootSAH_3.c   **** void FLASH_Reset(void);
 244:bootSAH_3.c   **** void FLASH_UntilReady(void);
 245:bootSAH_3.c   **** void FLASH_ReadByte(uint32_t faddr, uint8_t *rdata);
 246:bootSAH_3.c   **** void FLASH_ReadWord(uint32_t faddr, uint16_t *rdata);
 247:bootSAH_3.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata);
 248:bootSAH_3.c   **** void FLASH_EraseSector(uint32_t faddr);
 249:bootSAH_3.c   **** 
 250:bootSAH_3.c   **** void SPI_Init(void);
 251:bootSAH_3.c   **** uint8_t SPI_Transfer(uint8_t spidata);
 252:bootSAH_3.c   **** 
 253:bootSAH_3.c   **** 
 254:bootSAH_3.c   **** 
 255:bootSAH_3.c   **** //*****************************************************************************
 256:bootSAH_3.c   **** int main(void)
 257:bootSAH_3.c   **** {
 258:bootSAH_3.c   **** 	address_t		address			=	0;
 259:bootSAH_3.c   **** 	address_t		eraseAddress	=	0;
 260:bootSAH_3.c   **** 	unsigned char	msgParseState;
 261:bootSAH_3.c   **** 	unsigned int	ii				=	0;
 262:bootSAH_3.c   **** 	unsigned char	checksum		=	0;
 263:bootSAH_3.c   **** 	unsigned char	seqNum			=	0;
 264:bootSAH_3.c   **** 	unsigned int	msgLength		=	0;
 265:bootSAH_3.c   **** 	unsigned char	msgBuffer[285];
 266:bootSAH_3.c   **** 	unsigned char	c, *p;
 267:bootSAH_3.c   **** 	unsigned char   isLeave = 0;
 268:bootSAH_3.c   **** 
 269:bootSAH_3.c   **** 	unsigned long	boot_timeout;
 270:bootSAH_3.c   **** 	unsigned long	boot_timer;
 271:bootSAH_3.c   **** 	unsigned int	boot_state;
 272:bootSAH_3.c   **** 
 273:bootSAH_3.c   **** 	//*	some chips dont set the stack properly
 274:bootSAH_3.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 275:bootSAH_3.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 276:bootSAH_3.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 277:bootSAH_3.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 278:bootSAH_3.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 279:bootSAH_3.c   **** 
 280:bootSAH_3.c   **** 
 281:bootSAH_3.c   **** 	//*	handle the watch dog timer
 282:bootSAH_3.c   **** 	uint8_t	mcuStatusReg;
 283:bootSAH_3.c   **** 	mcuStatusReg	=	MCUSR;
 284:bootSAH_3.c   **** 
 285:bootSAH_3.c   **** 	__asm__ __volatile__ ("cli");
 286:bootSAH_3.c   **** 	__asm__ __volatile__ ("wdr");
 287:bootSAH_3.c   **** 	MCUSR	=	0;
 288:bootSAH_3.c   **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 289:bootSAH_3.c   **** 	WDTCSR	=	0;
 290:bootSAH_3.c   **** 	__asm__ __volatile__ ("sei");
 291:bootSAH_3.c   **** 	// check if WDT generated the reset, if so, go straight to app
 292:bootSAH_3.c   **** 	if (mcuStatusReg & _BV(WDRF))
 293:bootSAH_3.c   **** 	{
 294:bootSAH_3.c   **** 		app_start();
 295:bootSAH_3.c   **** 	}
 296:bootSAH_3.c   **** 
 297:bootSAH_3.c   **** 
 298:bootSAH_3.c   **** 
 299:bootSAH_3.c   **** 	boot_timer	=	0;
 300:bootSAH_3.c   **** 	boot_state	=	0;
 301:bootSAH_3.c   **** 
 302:bootSAH_3.c   **** #ifdef BLINK_LED_WHILE_WAITING
 303:bootSAH_3.c   **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 304:bootSAH_3.c   **** //	boot_timeout	=	170000;
 305:bootSAH_3.c   **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 306:bootSAH_3.c   **** #else
 307:bootSAH_3.c   **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 308:bootSAH_3.c   **** #endif
 309:bootSAH_3.c   **** 	/*
 310:bootSAH_3.c   **** 	 * Branch to bootloader or application code ?
 311:bootSAH_3.c   **** 	 */
 312:bootSAH_3.c   **** 
 313:bootSAH_3.c   **** #ifndef REMOVE_BOOTLOADER_LED
 314:bootSAH_3.c   **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 315:bootSAH_3.c   **** 	PROG_DDR	|=	(1<<PROGLED_PIN);
 316:bootSAH_3.c   **** //	PROG_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 317:bootSAH_3.c   **** 	PROG_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 318:bootSAH_3.c   **** 
 319:bootSAH_3.c   **** #ifdef _DEBUG_WITH_LEDS_
 320:bootSAH_3.c   **** 	for (ii=0; ii<3; ii++)
 321:bootSAH_3.c   **** 	{
 322:bootSAH_3.c   **** 		PROG_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 323:bootSAH_3.c   **** 		delay_ms(100);
 324:bootSAH_3.c   **** 		PROG_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 325:bootSAH_3.c   **** 		delay_ms(100);
 326:bootSAH_3.c   **** 	}
 327:bootSAH_3.c   **** #endif
 328:bootSAH_3.c   **** 
 329:bootSAH_3.c   **** #endif
 330:bootSAH_3.c   **** 
 331:bootSAH_3.c   **** 	asm volatile ("nop");			// wait until port has changed
 332:bootSAH_3.c   **** 
 333:bootSAH_3.c   **** 	SPI_Init();
 334:bootSAH_3.c   **** 	if(FLASH_Init())
 335:bootSAH_3.c   **** 	{
 336:bootSAH_3.c   **** 		  
 337:bootSAH_3.c   **** 		uint32_t fDataAddr = BOOT_DATA_ADDR;
 338:bootSAH_3.c   **** 		uint32_t fCsumAddr = BOOT_CSUM_ADDR;
 339:bootSAH_3.c   **** 		uint8_t  fRdTries  = 0;
 340:bootSAH_3.c   **** 		uint16_t fii, fjj;
 341:bootSAH_3.c   **** 		uint16_t fBootStat = 0;
 342:bootSAH_3.c   **** 		uint16_t fDataLen  = 0;
 343:bootSAH_3.c   **** 		uint16_t fChSumCal = 0;
 344:bootSAH_3.c   **** 		uint16_t fChSumRev = 0;
 345:bootSAH_3.c   **** 		uint32_t bootPageAddr = 0;
 346:bootSAH_3.c   **** 
 347:bootSAH_3.c   **** 		FLASH_ReadWord(BOOT_STAT_ADDR, &fBootStat);
 348:bootSAH_3.c   **** 		  
 349:bootSAH_3.c   **** 		if(fBootStat == 0x2323)
 350:bootSAH_3.c   **** 		{
 351:bootSAH_3.c   **** 			FLASH_ReadWord((BOOT_STAT_ADDR+2), &fDataLen);
 352:bootSAH_3.c   **** 
 353:bootSAH_3.c   **** 			for(fjj=0; fjj<fDataLen; fjj++)
 354:bootSAH_3.c   **** 			{
 355:bootSAH_3.c   **** 				fRdTries  = 0;
 356:bootSAH_3.c   **** 				fChSumCal = 0;
 357:bootSAH_3.c   **** 				PROG_PORT &= ~(1<<PROGCS_PIN);
 358:bootSAH_3.c   **** 				SPI_Transfer(0x03);
 359:bootSAH_3.c   **** 				SPI_Transfer((fDataAddr >> 16) & 0xff);
 360:bootSAH_3.c   **** 				SPI_Transfer((fDataAddr >> 8) & 0xff);
 361:bootSAH_3.c   **** 				SPI_Transfer(fDataAddr & 0xff);
 362:bootSAH_3.c   **** 				for(fii=0; fii<256; fii++)
 363:bootSAH_3.c   **** 				{
 364:bootSAH_3.c   **** 					msgBuffer[fii] = SPI_Transfer(0);
 365:bootSAH_3.c   **** 					fChSumCal += msgBuffer[fii];
 366:bootSAH_3.c   **** 				}
 367:bootSAH_3.c   **** 				PROG_PORT |= (1<<PROGCS_PIN);
 368:bootSAH_3.c   **** 				fDataAddr += EXMEM_PAGE_SIZE;
 369:bootSAH_3.c   **** 				_delay_us(10);
 370:bootSAH_3.c   **** 
 371:bootSAH_3.c   **** 				FLASH_ReadWord(fCsumAddr, &fChSumRev);
 372:bootSAH_3.c   **** 				  
 373:bootSAH_3.c   **** 				if(fChSumRev == fChSumCal)
 374:bootSAH_3.c   **** 				{
 375:bootSAH_3.c   **** 					/////////////////checksum Matched
 376:bootSAH_3.c   **** 					uint8_t  fLSByte, fMSByte;
 377:bootSAH_3.c   **** 					uint16_t fData;
 378:bootSAH_3.c   **** 					
 379:bootSAH_3.c   **** 					address = bootPageAddr;
 380:bootSAH_3.c   **** 								
 381:bootSAH_3.c   **** 					if(bootPageAddr < APP_END)				// erase only main section (bootloader protection)
 382:bootSAH_3.c   **** 					{
 383:bootSAH_3.c   **** 					    boot_page_erase(bootPageAddr);		// Perform page erase
 384:bootSAH_3.c   **** 					    boot_spm_busy_wait();				// Wait until the memory is erased.
 385:bootSAH_3.c   **** 					}
 386:bootSAH_3.c   **** 					
 387:bootSAH_3.c   **** 					for(fii=0; fii<256; fii+=2)
 388:bootSAH_3.c   **** 					{
 389:bootSAH_3.c   **** 						fLSByte = msgBuffer[fii];
 390:bootSAH_3.c   **** 						fMSByte = msgBuffer[fii+1];
 391:bootSAH_3.c   **** 						fData   = (fMSByte << 8) | fLSByte;
 392:bootSAH_3.c   **** 						          
 393:bootSAH_3.c   **** 						boot_page_fill(address, fData);		// fill boot page
 394:bootSAH_3.c   **** 						address += 2;						// inc boot page address
 395:bootSAH_3.c   **** 					}
 396:bootSAH_3.c   **** 
 397:bootSAH_3.c   **** 					boot_page_write(bootPageAddr);			// write boot page
 398:bootSAH_3.c   **** 					boot_spm_busy_wait();
 399:bootSAH_3.c   **** 					boot_rww_enable();						// Re-enable the RWW section
 400:bootSAH_3.c   **** 					
 401:bootSAH_3.c   **** 					bootPageAddr += SPM_PAGESIZE;			// SPM_PAGESIZE=256  point to next page to be erase
 402:bootSAH_3.c   **** 					fCsumAddr += 2;
 403:bootSAH_3.c   **** 
 404:bootSAH_3.c   **** 				}
 405:bootSAH_3.c   **** 				else
 406:bootSAH_3.c   **** 				{
 407:bootSAH_3.c   **** 					///////////////////checksum Wrong
 408:bootSAH_3.c   **** 					fRdTries++;
 409:bootSAH_3.c   **** 					if(fRdTries>3)
 410:bootSAH_3.c   **** 					{
 411:bootSAH_3.c   **** 						////////////fail to read page
 412:bootSAH_3.c   **** 						FLASH_WriteByte(BOOT_EROR_ADDR, (fjj >> 8));
 413:bootSAH_3.c   **** 						FLASH_WriteByte(BOOT_EROR_ADDR, (fjj & 0x00ff));
 414:bootSAH_3.c   **** 						break;
 415:bootSAH_3.c   **** 					}
 416:bootSAH_3.c   **** 				}
 417:bootSAH_3.c   **** 			}
 418:bootSAH_3.c   **** 			
 419:bootSAH_3.c   **** 			FLASH_EraseSector(BOOT_STAT_ADDR);		// erase exmem page
 420:bootSAH_3.c   **** 			//app_start();
 421:bootSAH_3.c   **** 		}
 422:bootSAH_3.c   **** 		  
 423:bootSAH_3.c   **** 	}
 424:bootSAH_3.c   **** 	
 425:bootSAH_3.c   **** 
 426:bootSAH_3.c   **** 
 427:bootSAH_3.c   **** 
 428:bootSAH_3.c   **** #ifdef _DEBUG_WITH_LEDS_
 429:bootSAH_3.c   **** 	//*	this is for debugging it can be removed
 430:bootSAH_3.c   **** 	for (ii=0; ii<10; ii++)
 431:bootSAH_3.c   **** 	{
 432:bootSAH_3.c   **** 		PROG_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 433:bootSAH_3.c   **** 		delay_ms(200);
 434:bootSAH_3.c   **** 		PROG_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 435:bootSAH_3.c   **** 		delay_ms(200);
 436:bootSAH_3.c   **** 	}
 437:bootSAH_3.c   **** 	PROG_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 438:bootSAH_3.c   **** #endif
 439:bootSAH_3.c   **** 
 440:bootSAH_3.c   **** 
 441:bootSAH_3.c   **** #ifndef REMOVE_BOOTLOADER_LED
 442:bootSAH_3.c   **** 	PROG_DDR	&=	~(1<<PROGLED_PIN);	// set to default
 443:bootSAH_3.c   **** 	PROG_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 444:bootSAH_3.c   **** //	PROG_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 445:bootSAH_3.c   **** 	delay_ms(100);							// delay after exit
 446:bootSAH_3.c   **** #endif
 447:bootSAH_3.c   **** 
 448:bootSAH_3.c   **** 
 449:bootSAH_3.c   **** 	asm volatile ("nop");			// wait until port has changed
 450:bootSAH_3.c   **** 
 451:bootSAH_3.c   **** 	/*
 452:bootSAH_3.c   **** 	 * Now leave bootloader
 453:bootSAH_3.c   **** 	 */
 454:bootSAH_3.c   **** 
 455:bootSAH_3.c   **** //	UART_STATUS_REG	&=	0xfd;
 456:bootSAH_3.c   **** 	boot_rww_enable();				// enable application section
 457:bootSAH_3.c   **** 
 458:bootSAH_3.c   **** 
 459:bootSAH_3.c   **** 	asm volatile(
 460:bootSAH_3.c   **** 			"clr	r30		\n\t"
 461:bootSAH_3.c   **** 			"clr	r31		\n\t"
 462:bootSAH_3.c   **** 			"ijmp	\n\t"
 463:bootSAH_3.c   **** 			);
 464:bootSAH_3.c   **** 
 465:bootSAH_3.c   **** /*
 466:bootSAH_3.c   **** * Never return to stop GCC to generate exit return code
 467:bootSAH_3.c   **** * Actually we will never reach this point, but the compiler doesn't
 468:bootSAH_3.c   **** * understand this
 469:bootSAH_3.c   **** */
 470:bootSAH_3.c   **** 	for(;;);
 471:bootSAH_3.c   **** }
 472:bootSAH_3.c   **** 
 473:bootSAH_3.c   **** 
 474:bootSAH_3.c   **** uint8_t FLASH_Init()
 475:bootSAH_3.c   **** {
 476:bootSAH_3.c   **** 	PROG_DDR  |=  (1<<PROGCS_PIN); // chip select as output
 477:bootSAH_3.c   **** 	PROG_PORT |=  (1<<PROGCS_PIN); // pull high
 478:bootSAH_3.c   **** 	
 479:bootSAH_3.c   **** 	_delay_us(10);
 480:bootSAH_3.c   **** 	FLASH_UntilReady();
 481:bootSAH_3.c   **** 	FLASH_ResetEnable();
 482:bootSAH_3.c   **** 	FLASH_Reset();
 483:bootSAH_3.c   **** 	uint32_t temp=0;
 484:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);    // low
 485:bootSAH_3.c   **** 	SPI_Transfer(0x9F);
 486:bootSAH_3.c   **** 	temp = (uint32_t)SPI_Transfer(0) << 16;
 487:bootSAH_3.c   **** 	temp |= (uint32_t)SPI_Transfer(0) << 8;
 488:bootSAH_3.c   **** 	temp |= (uint32_t)SPI_Transfer(0);
 489:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);   // high
 490:bootSAH_3.c   **** 
 491:bootSAH_3.c   **** 	if(temp == EXMEM_JEDEC)
 492:bootSAH_3.c   **** 	return 1;
 493:bootSAH_3.c   **** 	
 494:bootSAH_3.c   **** 	return 0;
 495:bootSAH_3.c   **** }
 496:bootSAH_3.c   **** 
 497:bootSAH_3.c   **** void FLASH_WriteEnable()
 498:bootSAH_3.c   **** {
 499:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 500:bootSAH_3.c   **** 	SPI_Transfer(0x06);
 501:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 502:bootSAH_3.c   **** 	_delay_us(10);
 503:bootSAH_3.c   **** }
 504:bootSAH_3.c   **** 
 505:bootSAH_3.c   **** void FLASH_ResetEnable()
 506:bootSAH_3.c   **** {
 507:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 508:bootSAH_3.c   **** 	SPI_Transfer(0x66);
 509:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 510:bootSAH_3.c   **** 	_delay_us(10);
 511:bootSAH_3.c   **** }
 512:bootSAH_3.c   **** 
 513:bootSAH_3.c   **** void FLASH_Reset()
 514:bootSAH_3.c   **** {
 515:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 516:bootSAH_3.c   **** 	SPI_Transfer(0x99);
 517:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 518:bootSAH_3.c   **** 	_delay_us(10);
 519:bootSAH_3.c   **** }
 520:bootSAH_3.c   **** 
 521:bootSAH_3.c   **** void FLASH_UntilReady()
 522:bootSAH_3.c   **** {
 523:bootSAH_3.c   **** 	uint8_t stat=0xff;
 524:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 525:bootSAH_3.c   **** 	SPI_Transfer(0x05);
 526:bootSAH_3.c   **** 	while((stat & 0x01) == 0x01)
 527:bootSAH_3.c   **** 	{
 528:bootSAH_3.c   **** 		stat = SPI_Transfer(0);
 529:bootSAH_3.c   **** 	}
 530:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 531:bootSAH_3.c   **** 	_delay_us(10);
 532:bootSAH_3.c   **** }
 533:bootSAH_3.c   **** 
 534:bootSAH_3.c   **** void FLASH_ReadByte(uint32_t faddr, uint8_t *rdata)
 535:bootSAH_3.c   **** {
 536:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 537:bootSAH_3.c   **** 	SPI_Transfer(0x03);
 538:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 539:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 540:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 541:bootSAH_3.c   **** 	//  SPI_Transfer(0);
 542:bootSAH_3.c   **** 	*rdata = SPI_Transfer(0);
 543:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 544:bootSAH_3.c   **** 	_delay_us(10);
 545:bootSAH_3.c   **** }
 546:bootSAH_3.c   **** 
 547:bootSAH_3.c   **** void FLASH_ReadWord(uint32_t faddr, uint16_t *rdata)
 548:bootSAH_3.c   **** {
 549:bootSAH_3.c   **** 	uint8_t temp1=0, temp2=0;
 550:bootSAH_3.c   **** 	PROG_PORT &= ~(1<<PROGCS_PIN);
 551:bootSAH_3.c   **** 	SPI_Transfer(0x03);
 552:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 553:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 554:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 555:bootSAH_3.c   **** 	temp1 = SPI_Transfer(0);
 556:bootSAH_3.c   **** 	temp2 = SPI_Transfer(0);
 557:bootSAH_3.c   **** 	PROG_PORT |= (1<<PROGCS_PIN);
 558:bootSAH_3.c   **** 	*rdata = ((uint16_t)temp1 << 8) | temp2;
 559:bootSAH_3.c   **** 	_delay_us(10);
 560:bootSAH_3.c   **** }
 561:bootSAH_3.c   **** 
 562:bootSAH_3.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata)
 563:bootSAH_3.c   **** {
 564:bootSAH_3.c   **** 	FLASH_UntilReady();
 565:bootSAH_3.c   **** 	FLASH_WriteEnable();
 566:bootSAH_3.c   **** 	PROG_PORT &= ~(1<<PROGCS_PIN);
 567:bootSAH_3.c   **** 	SPI_Transfer(0x02);
 568:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 569:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 570:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 571:bootSAH_3.c   **** 	SPI_Transfer(wdata & 0xff);
 572:bootSAH_3.c   **** 	PROG_PORT |= (1<<PROGCS_PIN);
 573:bootSAH_3.c   **** 	_delay_us(10);
 574:bootSAH_3.c   **** 	FLASH_UntilReady();
 575:bootSAH_3.c   **** }
 576:bootSAH_3.c   **** 
 577:bootSAH_3.c   **** void FLASH_EraseSector(uint32_t faddr)
 578:bootSAH_3.c   **** {
 579:bootSAH_3.c   **** 	FLASH_UntilReady();
 580:bootSAH_3.c   **** 	FLASH_WriteEnable();
 581:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 582:bootSAH_3.c   **** 	SPI_Transfer(0x20);
 583:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 584:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 585:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 586:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 587:bootSAH_3.c   **** 	_delay_us(10);
 588:bootSAH_3.c   **** 	FLASH_UntilReady();
 589:bootSAH_3.c   **** }
 590:bootSAH_3.c   **** 
 591:bootSAH_3.c   **** void SPI_Init(void)
 592:bootSAH_3.c   **** {
 113               		.loc 1 592 0
 114               		.cfi_startproc
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 0 */
 118               	.L__stack_usage = 0
 593:bootSAH_3.c   **** 	DDRB = (1<<PB2)|(1<<PB1)|(1<<PB0);
 119               		.loc 1 593 0
 120 001e 87E0      		ldi r24,lo8(7)
 121 0020 84B9      		out 0x4,r24
 594:bootSAH_3.c   **** 
 595:bootSAH_3.c   **** 	SPCR = ((1<<SPE)|               // SPI Enable
 122               		.loc 1 595 0
 123 0022 81E5      		ldi r24,lo8(81)
 124 0024 8CBD      		out 0x2c,r24
 125 0026 0895      		ret
 126               		.cfi_endproc
 127               	.LFE23:
 129               	.global	SPI_Transfer
 131               	SPI_Transfer:
 132               	.LFB24:
 596:bootSAH_3.c   **** 	(0<<SPIE)|              // SPI Interupt Enable
 597:bootSAH_3.c   **** 	(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
 598:bootSAH_3.c   **** 	(1<<MSTR)|              // Master/Slave select
 599:bootSAH_3.c   **** 	(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
 600:bootSAH_3.c   **** 	(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
 601:bootSAH_3.c   **** 	(0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)
 602:bootSAH_3.c   **** }
 603:bootSAH_3.c   **** 
 604:bootSAH_3.c   **** uint8_t SPI_Transfer(uint8_t spidata)
 605:bootSAH_3.c   **** {
 133               		.loc 1 605 0
 134               		.cfi_startproc
 135               	.LVL5:
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 606:bootSAH_3.c   **** 	SPDR = spidata;
 140               		.loc 1 606 0
 141 0028 8EBD      		out 0x2e,r24
 607:bootSAH_3.c   **** 	asm volatile("nop");    // small delay
 142               		.loc 1 607 0
 143               	/* #APP */
 144               	 ;  607 "bootSAH_3.c" 1
 145 002a 0000      		nop
 146               	 ;  0 "" 2
 147               	/* #NOAPP */
 148               	.L9:
 608:bootSAH_3.c   **** 	while(!(SPSR & (1<<SPIF)));   // Wait for transmission complete
 149               		.loc 1 608 0 discriminator 1
 150 002c 0DB4      		in __tmp_reg__,0x2d
 151 002e 07FE      		sbrs __tmp_reg__,7
 152 0030 00C0      		rjmp .L9
 609:bootSAH_3.c   **** 
 610:bootSAH_3.c   **** 	return SPDR;
 153               		.loc 1 610 0
 154 0032 8EB5      		in r24,0x2e
 155               	.LVL6:
 611:bootSAH_3.c   **** }
 156               		.loc 1 611 0
 157 0034 0895      		ret
 158               		.cfi_endproc
 159               	.LFE24:
 161               	.global	FLASH_WriteEnable
 163               	FLASH_WriteEnable:
 164               	.LFB15:
 498:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 165               		.loc 1 498 0
 166               		.cfi_startproc
 167               	/* prologue: function */
 168               	/* frame size = 0 */
 169               	/* stack size = 0 */
 170               	.L__stack_usage = 0
 499:bootSAH_3.c   **** 	SPI_Transfer(0x06);
 171               		.loc 1 499 0
 172 0036 2898      		cbi 0x5,0
 500:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 173               		.loc 1 500 0
 174 0038 86E0      		ldi r24,lo8(6)
 175 003a 0E94 0000 		call SPI_Transfer
 176               	.LVL7:
 501:bootSAH_3.c   **** 	_delay_us(10);
 177               		.loc 1 501 0
 178 003e 289A      		sbi 0x5,0
 179               	.LVL8:
 180               	.LBB28:
 181               	.LBB29:
 188:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 182               		.loc 2 276 0
 183 0040 85E3      		ldi r24,lo8(53)
 184 0042 8A95      	1:	dec r24
 185 0044 01F4      		brne 1b
 186 0046 0000      		nop
 187               	.LVL9:
 188 0048 0895      		ret
 189               	.LBE29:
 190               	.LBE28:
 191               		.cfi_endproc
 192               	.LFE15:
 194               	.global	FLASH_ResetEnable
 196               	FLASH_ResetEnable:
 197               	.LFB16:
 506:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 198               		.loc 1 506 0
 199               		.cfi_startproc
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 0 */
 203               	.L__stack_usage = 0
 507:bootSAH_3.c   **** 	SPI_Transfer(0x66);
 204               		.loc 1 507 0
 205 004a 2898      		cbi 0x5,0
 508:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 206               		.loc 1 508 0
 207 004c 86E6      		ldi r24,lo8(102)
 208 004e 0E94 0000 		call SPI_Transfer
 209               	.LVL10:
 509:bootSAH_3.c   **** 	_delay_us(10);
 210               		.loc 1 509 0
 211 0052 289A      		sbi 0x5,0
 212               	.LVL11:
 213               	.LBB30:
 214               	.LBB31:
 215               		.loc 2 276 0
 216 0054 85E3      		ldi r24,lo8(53)
 217 0056 8A95      	1:	dec r24
 218 0058 01F4      		brne 1b
 219 005a 0000      		nop
 220               	.LVL12:
 221 005c 0895      		ret
 222               	.LBE31:
 223               	.LBE30:
 224               		.cfi_endproc
 225               	.LFE16:
 227               	.global	FLASH_Reset
 229               	FLASH_Reset:
 230               	.LFB17:
 514:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 231               		.loc 1 514 0
 232               		.cfi_startproc
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 0 */
 236               	.L__stack_usage = 0
 515:bootSAH_3.c   **** 	SPI_Transfer(0x99);
 237               		.loc 1 515 0
 238 005e 2898      		cbi 0x5,0
 516:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 239               		.loc 1 516 0
 240 0060 89E9      		ldi r24,lo8(-103)
 241 0062 0E94 0000 		call SPI_Transfer
 242               	.LVL13:
 517:bootSAH_3.c   **** 	_delay_us(10);
 243               		.loc 1 517 0
 244 0066 289A      		sbi 0x5,0
 245               	.LVL14:
 246               	.LBB32:
 247               	.LBB33:
 248               		.loc 2 276 0
 249 0068 85E3      		ldi r24,lo8(53)
 250 006a 8A95      	1:	dec r24
 251 006c 01F4      		brne 1b
 252 006e 0000      		nop
 253               	.LVL15:
 254 0070 0895      		ret
 255               	.LBE33:
 256               	.LBE32:
 257               		.cfi_endproc
 258               	.LFE17:
 260               	.global	FLASH_UntilReady
 262               	FLASH_UntilReady:
 263               	.LFB18:
 522:bootSAH_3.c   **** 	uint8_t stat=0xff;
 264               		.loc 1 522 0
 265               		.cfi_startproc
 266               	/* prologue: function */
 267               	/* frame size = 0 */
 268               	/* stack size = 0 */
 269               	.L__stack_usage = 0
 270               	.LVL16:
 524:bootSAH_3.c   **** 	SPI_Transfer(0x05);
 271               		.loc 1 524 0
 272 0072 2898      		cbi 0x5,0
 525:bootSAH_3.c   **** 	while((stat & 0x01) == 0x01)
 273               		.loc 1 525 0
 274 0074 85E0      		ldi r24,lo8(5)
 275 0076 0E94 0000 		call SPI_Transfer
 276               	.LVL17:
 523:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 277               		.loc 1 523 0
 278 007a 8FEF      		ldi r24,lo8(-1)
 279               	.LVL18:
 280               	.L15:
 526:bootSAH_3.c   **** 	{
 281               		.loc 1 526 0
 282 007c 80FF      		sbrs r24,0
 283 007e 00C0      		rjmp .L17
 528:bootSAH_3.c   **** 	}
 284               		.loc 1 528 0
 285 0080 80E0      		ldi r24,0
 286 0082 0E94 0000 		call SPI_Transfer
 287               	.LVL19:
 288 0086 00C0      		rjmp .L15
 289               	.LVL20:
 290               	.L17:
 530:bootSAH_3.c   **** 	_delay_us(10);
 291               		.loc 1 530 0
 292 0088 289A      		sbi 0x5,0
 293               	.LVL21:
 294               	.LBB34:
 295               	.LBB35:
 296               		.loc 2 276 0
 297 008a 85E3      		ldi r24,lo8(53)
 298 008c 8A95      	1:	dec r24
 299 008e 01F4      		brne 1b
 300 0090 0000      		nop
 301               	.LVL22:
 302 0092 0895      		ret
 303               	.LBE35:
 304               	.LBE34:
 305               		.cfi_endproc
 306               	.LFE18:
 308               	.global	FLASH_Init
 310               	FLASH_Init:
 311               	.LFB14:
 475:bootSAH_3.c   **** 	PROG_DDR  |=  (1<<PROGCS_PIN); // chip select as output
 312               		.loc 1 475 0
 313               		.cfi_startproc
 314 0094 CF92      		push r12
 315               	.LCFI0:
 316               		.cfi_def_cfa_offset 4
 317               		.cfi_offset 12, -3
 318 0096 DF92      		push r13
 319               	.LCFI1:
 320               		.cfi_def_cfa_offset 5
 321               		.cfi_offset 13, -4
 322 0098 EF92      		push r14
 323               	.LCFI2:
 324               		.cfi_def_cfa_offset 6
 325               		.cfi_offset 14, -5
 326 009a FF92      		push r15
 327               	.LCFI3:
 328               		.cfi_def_cfa_offset 7
 329               		.cfi_offset 15, -6
 330               	/* prologue: function */
 331               	/* frame size = 0 */
 332               	/* stack size = 4 */
 333               	.L__stack_usage = 4
 476:bootSAH_3.c   **** 	PROG_PORT |=  (1<<PROGCS_PIN); // pull high
 334               		.loc 1 476 0
 335 009c 209A      		sbi 0x4,0
 477:bootSAH_3.c   **** 	
 336               		.loc 1 477 0
 337 009e 289A      		sbi 0x5,0
 338               	.LVL23:
 339               	.LBB36:
 340               	.LBB37:
 341               		.loc 2 276 0
 342 00a0 85E3      		ldi r24,lo8(53)
 343 00a2 8A95      	1:	dec r24
 344 00a4 01F4      		brne 1b
 345 00a6 0000      		nop
 346               	.LVL24:
 347               	.LBE37:
 348               	.LBE36:
 480:bootSAH_3.c   **** 	FLASH_ResetEnable();
 349               		.loc 1 480 0
 350 00a8 0E94 0000 		call FLASH_UntilReady
 351               	.LVL25:
 481:bootSAH_3.c   **** 	FLASH_Reset();
 352               		.loc 1 481 0
 353 00ac 0E94 0000 		call FLASH_ResetEnable
 354               	.LVL26:
 482:bootSAH_3.c   **** 	uint32_t temp=0;
 355               		.loc 1 482 0
 356 00b0 0E94 0000 		call FLASH_Reset
 357               	.LVL27:
 484:bootSAH_3.c   **** 	SPI_Transfer(0x9F);
 358               		.loc 1 484 0
 359 00b4 2898      		cbi 0x5,0
 485:bootSAH_3.c   **** 	temp = (uint32_t)SPI_Transfer(0) << 16;
 360               		.loc 1 485 0
 361 00b6 8FE9      		ldi r24,lo8(-97)
 362 00b8 0E94 0000 		call SPI_Transfer
 363               	.LVL28:
 486:bootSAH_3.c   **** 	temp |= (uint32_t)SPI_Transfer(0) << 8;
 364               		.loc 1 486 0
 365 00bc 80E0      		ldi r24,0
 366 00be 0E94 0000 		call SPI_Transfer
 367               	.LVL29:
 368 00c2 C82E      		mov r12,r24
 369 00c4 D12C      		mov r13,__zero_reg__
 370 00c6 E12C      		mov r14,__zero_reg__
 371 00c8 F12C      		mov r15,__zero_reg__
 372 00ca 7601      		movw r14,r12
 373 00cc DD24      		clr r13
 374 00ce CC24      		clr r12
 375               	.LVL30:
 487:bootSAH_3.c   **** 	temp |= (uint32_t)SPI_Transfer(0);
 376               		.loc 1 487 0
 377 00d0 80E0      		ldi r24,0
 378 00d2 0E94 0000 		call SPI_Transfer
 379               	.LVL31:
 380 00d6 D82A      		or r13,r24
 488:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);   // high
 381               		.loc 1 488 0
 382 00d8 80E0      		ldi r24,0
 383 00da 0E94 0000 		call SPI_Transfer
 384               	.LVL32:
 489:bootSAH_3.c   **** 
 385               		.loc 1 489 0
 386 00de 289A      		sbi 0x5,0
 387 00e0 C82A      		or r12,r24
 388               	.LVL33:
 389 00e2 81E0      		ldi r24,lo8(1)
 390 00e4 97E1      		ldi r25,23
 391 00e6 C916      		cp r12,r25
 392 00e8 90E4      		ldi r25,64
 393 00ea D906      		cpc r13,r25
 394 00ec 9FEE      		ldi r25,-17
 395 00ee E906      		cpc r14,r25
 396 00f0 F104      		cpc r15,__zero_reg__
 397 00f2 01F0      		breq .L19
 398 00f4 80E0      		ldi r24,0
 399               	.L19:
 400               	/* epilogue start */
 495:bootSAH_3.c   **** 
 401               		.loc 1 495 0
 402 00f6 FF90      		pop r15
 403 00f8 EF90      		pop r14
 404 00fa DF90      		pop r13
 405 00fc CF90      		pop r12
 406 00fe 0895      		ret
 407               		.cfi_endproc
 408               	.LFE14:
 410               	.global	FLASH_ReadByte
 412               	FLASH_ReadByte:
 413               	.LFB19:
 535:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 414               		.loc 1 535 0
 415               		.cfi_startproc
 416               	.LVL34:
 417 0100 FF92      		push r15
 418               	.LCFI4:
 419               		.cfi_def_cfa_offset 4
 420               		.cfi_offset 15, -3
 421 0102 0F93      		push r16
 422               	.LCFI5:
 423               		.cfi_def_cfa_offset 5
 424               		.cfi_offset 16, -4
 425 0104 1F93      		push r17
 426               	.LCFI6:
 427               		.cfi_def_cfa_offset 6
 428               		.cfi_offset 17, -5
 429 0106 CF93      		push r28
 430               	.LCFI7:
 431               		.cfi_def_cfa_offset 7
 432               		.cfi_offset 28, -6
 433 0108 DF93      		push r29
 434               	.LCFI8:
 435               		.cfi_def_cfa_offset 8
 436               		.cfi_offset 29, -7
 437               	/* prologue: function */
 438               	/* frame size = 0 */
 439               	/* stack size = 5 */
 440               	.L__stack_usage = 5
 441 010a 162F      		mov r17,r22
 442 010c 072F      		mov r16,r23
 443 010e F82E      		mov r15,r24
 444 0110 EA01      		movw r28,r20
 536:bootSAH_3.c   **** 	SPI_Transfer(0x03);
 445               		.loc 1 536 0
 446 0112 2898      		cbi 0x5,0
 537:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 447               		.loc 1 537 0
 448 0114 83E0      		ldi r24,lo8(3)
 449 0116 0E94 0000 		call SPI_Transfer
 450               	.LVL35:
 538:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 451               		.loc 1 538 0
 452 011a 8F2D      		mov r24,r15
 453 011c 0E94 0000 		call SPI_Transfer
 454               	.LVL36:
 539:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 455               		.loc 1 539 0
 456 0120 802F      		mov r24,r16
 457 0122 0E94 0000 		call SPI_Transfer
 458               	.LVL37:
 540:bootSAH_3.c   **** 	//  SPI_Transfer(0);
 459               		.loc 1 540 0
 460 0126 812F      		mov r24,r17
 461 0128 0E94 0000 		call SPI_Transfer
 462               	.LVL38:
 542:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 463               		.loc 1 542 0
 464 012c 80E0      		ldi r24,0
 465 012e 0E94 0000 		call SPI_Transfer
 466               	.LVL39:
 467 0132 8883      		st Y,r24
 543:bootSAH_3.c   **** 	_delay_us(10);
 468               		.loc 1 543 0
 469 0134 289A      		sbi 0x5,0
 470               	.LVL40:
 471               	.LBB38:
 472               	.LBB39:
 473               		.loc 2 276 0
 474 0136 85E3      		ldi r24,lo8(53)
 475 0138 8A95      	1:	dec r24
 476 013a 01F4      		brne 1b
 477 013c 0000      		nop
 478               	.LVL41:
 479               	/* epilogue start */
 480               	.LBE39:
 481               	.LBE38:
 545:bootSAH_3.c   **** 
 482               		.loc 1 545 0
 483 013e DF91      		pop r29
 484 0140 CF91      		pop r28
 485               	.LVL42:
 486 0142 1F91      		pop r17
 487 0144 0F91      		pop r16
 488 0146 FF90      		pop r15
 489 0148 0895      		ret
 490               		.cfi_endproc
 491               	.LFE19:
 493               	.global	FLASH_ReadWord
 495               	FLASH_ReadWord:
 496               	.LFB20:
 548:bootSAH_3.c   **** 	uint8_t temp1=0, temp2=0;
 497               		.loc 1 548 0
 498               		.cfi_startproc
 499               	.LVL43:
 500 014a FF92      		push r15
 501               	.LCFI9:
 502               		.cfi_def_cfa_offset 4
 503               		.cfi_offset 15, -3
 504 014c 0F93      		push r16
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 5
 507               		.cfi_offset 16, -4
 508 014e 1F93      		push r17
 509               	.LCFI11:
 510               		.cfi_def_cfa_offset 6
 511               		.cfi_offset 17, -5
 512 0150 CF93      		push r28
 513               	.LCFI12:
 514               		.cfi_def_cfa_offset 7
 515               		.cfi_offset 28, -6
 516 0152 DF93      		push r29
 517               	.LCFI13:
 518               		.cfi_def_cfa_offset 8
 519               		.cfi_offset 29, -7
 520               	/* prologue: function */
 521               	/* frame size = 0 */
 522               	/* stack size = 5 */
 523               	.L__stack_usage = 5
 524 0154 EB01      		movw r28,r22
 525 0156 F82E      		mov r15,r24
 526 0158 8A01      		movw r16,r20
 527               	.LVL44:
 550:bootSAH_3.c   **** 	SPI_Transfer(0x03);
 528               		.loc 1 550 0
 529 015a 2898      		cbi 0x5,0
 551:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 530               		.loc 1 551 0
 531 015c 83E0      		ldi r24,lo8(3)
 532 015e 0E94 0000 		call SPI_Transfer
 533               	.LVL45:
 552:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 534               		.loc 1 552 0
 535 0162 8F2D      		mov r24,r15
 536 0164 0E94 0000 		call SPI_Transfer
 537               	.LVL46:
 553:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 538               		.loc 1 553 0
 539 0168 8D2F      		mov r24,r29
 540 016a 0E94 0000 		call SPI_Transfer
 541               	.LVL47:
 554:bootSAH_3.c   **** 	temp1 = SPI_Transfer(0);
 542               		.loc 1 554 0
 543 016e 8C2F      		mov r24,r28
 544 0170 0E94 0000 		call SPI_Transfer
 545               	.LVL48:
 555:bootSAH_3.c   **** 	temp2 = SPI_Transfer(0);
 546               		.loc 1 555 0
 547 0174 80E0      		ldi r24,0
 548 0176 0E94 0000 		call SPI_Transfer
 549               	.LVL49:
 550 017a C82F      		mov r28,r24
 551               	.LVL50:
 556:bootSAH_3.c   **** 	PROG_PORT |= (1<<PROGCS_PIN);
 552               		.loc 1 556 0
 553 017c 80E0      		ldi r24,0
 554               	.LVL51:
 555 017e 0E94 0000 		call SPI_Transfer
 556               	.LVL52:
 557:bootSAH_3.c   **** 	*rdata = ((uint16_t)temp1 << 8) | temp2;
 557               		.loc 1 557 0
 558 0182 289A      		sbi 0x5,0
 558:bootSAH_3.c   **** 	_delay_us(10);
 559               		.loc 1 558 0
 560 0184 2C2F      		mov r18,r28
 561 0186 30E0      		ldi r19,0
 562 0188 322F      		mov r19,r18
 563 018a 2227      		clr r18
 564 018c 282B      		or r18,r24
 565 018e F801      		movw r30,r16
 566 0190 3183      		std Z+1,r19
 567 0192 2083      		st Z,r18
 568               	.LVL53:
 569               	.LBB40:
 570               	.LBB41:
 571               		.loc 2 276 0
 572 0194 F5E3      		ldi r31,lo8(53)
 573 0196 FA95      	1:	dec r31
 574 0198 01F4      		brne 1b
 575 019a 0000      		nop
 576               	.LVL54:
 577               	/* epilogue start */
 578               	.LBE41:
 579               	.LBE40:
 560:bootSAH_3.c   **** 
 580               		.loc 1 560 0
 581 019c DF91      		pop r29
 582 019e CF91      		pop r28
 583               	.LVL55:
 584 01a0 1F91      		pop r17
 585 01a2 0F91      		pop r16
 586               	.LVL56:
 587 01a4 FF90      		pop r15
 588 01a6 0895      		ret
 589               		.cfi_endproc
 590               	.LFE20:
 592               	.global	FLASH_WriteByte
 594               	FLASH_WriteByte:
 595               	.LFB21:
 563:bootSAH_3.c   **** 	FLASH_UntilReady();
 596               		.loc 1 563 0
 597               		.cfi_startproc
 598               	.LVL57:
 599 01a8 0F93      		push r16
 600               	.LCFI14:
 601               		.cfi_def_cfa_offset 4
 602               		.cfi_offset 16, -3
 603 01aa 1F93      		push r17
 604               	.LCFI15:
 605               		.cfi_def_cfa_offset 5
 606               		.cfi_offset 17, -4
 607 01ac CF93      		push r28
 608               	.LCFI16:
 609               		.cfi_def_cfa_offset 6
 610               		.cfi_offset 28, -5
 611 01ae DF93      		push r29
 612               	.LCFI17:
 613               		.cfi_def_cfa_offset 7
 614               		.cfi_offset 29, -6
 615               	/* prologue: function */
 616               	/* frame size = 0 */
 617               	/* stack size = 4 */
 618               	.L__stack_usage = 4
 619 01b0 D62F      		mov r29,r22
 620 01b2 172F      		mov r17,r23
 621 01b4 082F      		mov r16,r24
 622 01b6 C42F      		mov r28,r20
 564:bootSAH_3.c   **** 	FLASH_WriteEnable();
 623               		.loc 1 564 0
 624 01b8 0E94 0000 		call FLASH_UntilReady
 625               	.LVL58:
 565:bootSAH_3.c   **** 	PROG_PORT &= ~(1<<PROGCS_PIN);
 626               		.loc 1 565 0
 627 01bc 0E94 0000 		call FLASH_WriteEnable
 628               	.LVL59:
 566:bootSAH_3.c   **** 	SPI_Transfer(0x02);
 629               		.loc 1 566 0
 630 01c0 2898      		cbi 0x5,0
 567:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 631               		.loc 1 567 0
 632 01c2 82E0      		ldi r24,lo8(2)
 633 01c4 0E94 0000 		call SPI_Transfer
 634               	.LVL60:
 568:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 635               		.loc 1 568 0
 636 01c8 802F      		mov r24,r16
 637 01ca 0E94 0000 		call SPI_Transfer
 638               	.LVL61:
 569:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 639               		.loc 1 569 0
 640 01ce 812F      		mov r24,r17
 641 01d0 0E94 0000 		call SPI_Transfer
 642               	.LVL62:
 570:bootSAH_3.c   **** 	SPI_Transfer(wdata & 0xff);
 643               		.loc 1 570 0
 644 01d4 8D2F      		mov r24,r29
 645 01d6 0E94 0000 		call SPI_Transfer
 646               	.LVL63:
 571:bootSAH_3.c   **** 	PROG_PORT |= (1<<PROGCS_PIN);
 647               		.loc 1 571 0
 648 01da 8C2F      		mov r24,r28
 649 01dc 0E94 0000 		call SPI_Transfer
 650               	.LVL64:
 572:bootSAH_3.c   **** 	_delay_us(10);
 651               		.loc 1 572 0
 652 01e0 289A      		sbi 0x5,0
 653               	.LVL65:
 654               	.LBB42:
 655               	.LBB43:
 656               		.loc 2 276 0
 657 01e2 85E3      		ldi r24,lo8(53)
 658 01e4 8A95      	1:	dec r24
 659 01e6 01F4      		brne 1b
 660 01e8 0000      		nop
 661               	.LVL66:
 662               	/* epilogue start */
 663               	.LBE43:
 664               	.LBE42:
 575:bootSAH_3.c   **** 
 665               		.loc 1 575 0
 666 01ea DF91      		pop r29
 667 01ec CF91      		pop r28
 668               	.LVL67:
 669 01ee 1F91      		pop r17
 670 01f0 0F91      		pop r16
 574:bootSAH_3.c   **** }
 671               		.loc 1 574 0
 672 01f2 0C94 0000 		jmp FLASH_UntilReady
 673               	.LVL68:
 674               		.cfi_endproc
 675               	.LFE21:
 677               	.global	FLASH_EraseSector
 679               	FLASH_EraseSector:
 680               	.LFB22:
 578:bootSAH_3.c   **** 	FLASH_UntilReady();
 681               		.loc 1 578 0
 682               		.cfi_startproc
 683               	.LVL69:
 684 01f6 1F93      		push r17
 685               	.LCFI18:
 686               		.cfi_def_cfa_offset 4
 687               		.cfi_offset 17, -3
 688 01f8 CF93      		push r28
 689               	.LCFI19:
 690               		.cfi_def_cfa_offset 5
 691               		.cfi_offset 28, -4
 692 01fa DF93      		push r29
 693               	.LCFI20:
 694               		.cfi_def_cfa_offset 6
 695               		.cfi_offset 29, -5
 696               	/* prologue: function */
 697               	/* frame size = 0 */
 698               	/* stack size = 3 */
 699               	.L__stack_usage = 3
 700 01fc EB01      		movw r28,r22
 701 01fe 182F      		mov r17,r24
 579:bootSAH_3.c   **** 	FLASH_WriteEnable();
 702               		.loc 1 579 0
 703 0200 0E94 0000 		call FLASH_UntilReady
 704               	.LVL70:
 580:bootSAH_3.c   **** 	PROG_PORT  &=  ~(1<<PROGCS_PIN);
 705               		.loc 1 580 0
 706 0204 0E94 0000 		call FLASH_WriteEnable
 707               	.LVL71:
 581:bootSAH_3.c   **** 	SPI_Transfer(0x20);
 708               		.loc 1 581 0
 709 0208 2898      		cbi 0x5,0
 582:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 710               		.loc 1 582 0
 711 020a 80E2      		ldi r24,lo8(32)
 712 020c 0E94 0000 		call SPI_Transfer
 713               	.LVL72:
 583:bootSAH_3.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 714               		.loc 1 583 0
 715 0210 812F      		mov r24,r17
 716 0212 0E94 0000 		call SPI_Transfer
 717               	.LVL73:
 584:bootSAH_3.c   **** 	SPI_Transfer(faddr & 0xff);
 718               		.loc 1 584 0
 719 0216 8D2F      		mov r24,r29
 720 0218 0E94 0000 		call SPI_Transfer
 721               	.LVL74:
 585:bootSAH_3.c   **** 	PROG_PORT  |=  (1<<PROGCS_PIN);
 722               		.loc 1 585 0
 723 021c 8C2F      		mov r24,r28
 724 021e 0E94 0000 		call SPI_Transfer
 725               	.LVL75:
 586:bootSAH_3.c   **** 	_delay_us(10);
 726               		.loc 1 586 0
 727 0222 289A      		sbi 0x5,0
 728               	.LVL76:
 729               	.LBB44:
 730               	.LBB45:
 731               		.loc 2 276 0
 732 0224 85E3      		ldi r24,lo8(53)
 733 0226 8A95      	1:	dec r24
 734 0228 01F4      		brne 1b
 735 022a 0000      		nop
 736               	.LVL77:
 737               	/* epilogue start */
 738               	.LBE45:
 739               	.LBE44:
 589:bootSAH_3.c   **** 
 740               		.loc 1 589 0
 741 022c DF91      		pop r29
 742 022e CF91      		pop r28
 743 0230 1F91      		pop r17
 588:bootSAH_3.c   **** }
 744               		.loc 1 588 0
 745 0232 0C94 0000 		jmp FLASH_UntilReady
 746               	.LVL78:
 747               		.cfi_endproc
 748               	.LFE22:
 750               		.section	.text.startup,"ax",@progbits
 751               	.global	main
 753               	main:
 754               	.LFB13:
 257:bootSAH_3.c   **** 	address_t		address			=	0;
 755               		.loc 1 257 0
 756               		.cfi_startproc
 757 0000 CF93      		push r28
 758               	.LCFI21:
 759               		.cfi_def_cfa_offset 4
 760               		.cfi_offset 28, -3
 761 0002 DF93      		push r29
 762               	.LCFI22:
 763               		.cfi_def_cfa_offset 5
 764               		.cfi_offset 29, -4
 765 0004 CDB7      		in r28,__SP_L__
 766 0006 DEB7      		in r29,__SP_H__
 767               	.LCFI23:
 768               		.cfi_def_cfa_register 28
 769 0008 C952      		subi r28,41
 770 000a D140      		sbci r29,1
 771               	.LCFI24:
 772               		.cfi_def_cfa_offset 302
 773 000c 0FB6      		in __tmp_reg__,__SREG__
 774 000e F894      		cli
 775 0010 DEBF      		out __SP_H__,r29
 776 0012 0FBE      		out __SREG__,__tmp_reg__
 777 0014 CDBF      		out __SP_L__,r28
 778               	/* prologue: function */
 779               	/* frame size = 297 */
 780               	/* stack size = 299 */
 781               	.L__stack_usage = 299
 782               	.LVL79:
 274:bootSAH_3.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 783               		.loc 1 274 0
 784               	/* #APP */
 785               	 ;  274 "bootSAH_3.c" 1
 786               		.set __stack, 8703
 787               	 ;  0 "" 2
 275:bootSAH_3.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 788               		.loc 1 275 0
 789               	 ;  275 "bootSAH_3.c" 1
 790 0016 01E2      		ldi	16, 33
 791               	 ;  0 "" 2
 276:bootSAH_3.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 792               		.loc 1 276 0
 793               	 ;  276 "bootSAH_3.c" 1
 794 0018 0EBF      		out 62,16
 795               	 ;  0 "" 2
 277:bootSAH_3.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 796               		.loc 1 277 0
 797               	 ;  277 "bootSAH_3.c" 1
 798 001a 0FEF      		ldi	16, 255
 799               	 ;  0 "" 2
 278:bootSAH_3.c   **** 
 800               		.loc 1 278 0
 801               	 ;  278 "bootSAH_3.c" 1
 802 001c 0DBF      		out 61,16
 803               	 ;  0 "" 2
 283:bootSAH_3.c   **** 
 804               		.loc 1 283 0
 805               	/* #NOAPP */
 806 001e 94B7      		in r25,0x34
 807               	.LVL80:
 285:bootSAH_3.c   **** 	__asm__ __volatile__ ("wdr");
 808               		.loc 1 285 0
 809               	/* #APP */
 810               	 ;  285 "bootSAH_3.c" 1
 811 0020 F894      		cli
 812               	 ;  0 "" 2
 286:bootSAH_3.c   **** 	MCUSR	=	0;
 813               		.loc 1 286 0
 814               	 ;  286 "bootSAH_3.c" 1
 815 0022 A895      		wdr
 816               	 ;  0 "" 2
 287:bootSAH_3.c   **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 817               		.loc 1 287 0
 818               	/* #NOAPP */
 819 0024 14BE      		out 0x34,__zero_reg__
 288:bootSAH_3.c   **** 	WDTCSR	=	0;
 820               		.loc 1 288 0
 821 0026 8091 6000 		lds r24,96
 822 002a 8861      		ori r24,lo8(24)
 823 002c 8093 6000 		sts 96,r24
 289:bootSAH_3.c   **** 	__asm__ __volatile__ ("sei");
 824               		.loc 1 289 0
 825 0030 1092 6000 		sts 96,__zero_reg__
 290:bootSAH_3.c   **** 	// check if WDT generated the reset, if so, go straight to app
 826               		.loc 1 290 0
 827               	/* #APP */
 828               	 ;  290 "bootSAH_3.c" 1
 829 0034 7894      		sei
 830               	 ;  0 "" 2
 292:bootSAH_3.c   **** 	{
 831               		.loc 1 292 0
 832               	/* #NOAPP */
 833 0036 93FF      		sbrs r25,3
 834 0038 00C0      		rjmp .L28
 294:bootSAH_3.c   **** 	}
 835               		.loc 1 294 0
 836 003a E091 0000 		lds r30,app_start
 837 003e F091 0000 		lds r31,app_start+1
 838 0042 1995      		eicall
 839               	.LVL81:
 840               	.L28:
 315:bootSAH_3.c   **** //	PROG_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 841               		.loc 1 315 0
 842 0044 269A      		sbi 0x4,6
 317:bootSAH_3.c   **** 
 843               		.loc 1 317 0
 844 0046 2E9A      		sbi 0x5,6
 331:bootSAH_3.c   **** 
 845               		.loc 1 331 0
 846               	/* #APP */
 847               	 ;  331 "bootSAH_3.c" 1
 848 0048 0000      		nop
 849               	 ;  0 "" 2
 333:bootSAH_3.c   **** 	if(FLASH_Init())
 850               		.loc 1 333 0
 851               	/* #NOAPP */
 852 004a 0E94 0000 		call SPI_Init
 853               	.LVL82:
 334:bootSAH_3.c   **** 	{
 854               		.loc 1 334 0
 855 004e 0E94 0000 		call FLASH_Init
 856               	.LVL83:
 857 0052 8823      		tst r24
 858 0054 01F4      		brne .+2
 859 0056 00C0      		rjmp .L29
 860               	.LVL84:
 861               	.LBB46:
 341:bootSAH_3.c   **** 		uint16_t fDataLen  = 0;
 862               		.loc 1 341 0
 863 0058 CE5D      		subi r28,lo8(-290)
 864 005a DE4F      		sbci r29,hi8(-290)
 865 005c 1982      		std Y+1,__zero_reg__
 866 005e 1882      		st Y,__zero_reg__
 867 0060 C252      		subi r28,lo8(290)
 868 0062 D140      		sbci r29,hi8(290)
 342:bootSAH_3.c   **** 		uint16_t fChSumCal = 0;
 869               		.loc 1 342 0
 870 0064 C05E      		subi r28,lo8(-288)
 871 0066 DE4F      		sbci r29,hi8(-288)
 872 0068 1982      		std Y+1,__zero_reg__
 873 006a 1882      		st Y,__zero_reg__
 874 006c C052      		subi r28,lo8(288)
 875 006e D140      		sbci r29,hi8(288)
 876               	.LVL85:
 344:bootSAH_3.c   **** 		uint32_t bootPageAddr = 0;
 877               		.loc 1 344 0
 878 0070 8E01      		movw r16,r28
 879 0072 025E      		subi r16,-30
 880 0074 1E4F      		sbci r17,-2
 881 0076 F801      		movw r30,r16
 882 0078 1182      		std Z+1,__zero_reg__
 883 007a 1082      		st Z,__zero_reg__
 884               	.LVL86:
 347:bootSAH_3.c   **** 		  
 885               		.loc 1 347 0
 886 007c AE01      		movw r20,r28
 887 007e 4E5D      		subi r20,-34
 888 0080 5E4F      		sbci r21,-2
 889 0082 60E0      		ldi r22,0
 890 0084 70E1      		ldi r23,lo8(16)
 891 0086 80E0      		ldi r24,0
 892 0088 90E0      		ldi r25,0
 893 008a 0E94 0000 		call FLASH_ReadWord
 894               	.LVL87:
 349:bootSAH_3.c   **** 		{
 895               		.loc 1 349 0
 896 008e CE5D      		subi r28,lo8(-290)
 897 0090 DE4F      		sbci r29,hi8(-290)
 898 0092 8881      		ld r24,Y
 899 0094 9981      		ldd r25,Y+1
 900 0096 C252      		subi r28,lo8(290)
 901 0098 D140      		sbci r29,hi8(290)
 902 009a 8332      		cpi r24,35
 903 009c 9342      		sbci r25,35
 904 009e 01F0      		breq .+2
 905 00a0 00C0      		rjmp .L29
 351:bootSAH_3.c   **** 
 906               		.loc 1 351 0
 907 00a2 AE01      		movw r20,r28
 908 00a4 405E      		subi r20,-32
 909 00a6 5E4F      		sbci r21,-2
 910 00a8 62E0      		ldi r22,lo8(2)
 911 00aa 70E1      		ldi r23,lo8(16)
 912 00ac 80E0      		ldi r24,0
 913 00ae 90E0      		ldi r25,0
 914 00b0 0E94 0000 		call FLASH_ReadWord
 915               	.LVL88:
 345:bootSAH_3.c   **** 
 916               		.loc 1 345 0
 917 00b4 C12C      		mov r12,__zero_reg__
 918 00b6 D12C      		mov r13,__zero_reg__
 919 00b8 7601      		movw r14,r12
 353:bootSAH_3.c   **** 			{
 920               		.loc 1 353 0
 921 00ba CA5D      		subi r28,lo8(-294)
 922 00bc DE4F      		sbci r29,hi8(-294)
 923 00be 1982      		std Y+1,__zero_reg__
 924 00c0 1882      		st Y,__zero_reg__
 925 00c2 C652      		subi r28,lo8(294)
 926 00c4 D140      		sbci r29,hi8(294)
 338:bootSAH_3.c   **** 		uint8_t  fRdTries  = 0;
 927               		.loc 1 338 0
 928 00c6 812C      		mov r8,__zero_reg__
 929 00c8 31E1      		ldi r19,lo8(17)
 930 00ca 932E      		mov r9,r19
 931 00cc A12C      		mov r10,__zero_reg__
 932 00ce B12C      		mov r11,__zero_reg__
 337:bootSAH_3.c   **** 		uint32_t fCsumAddr = BOOT_CSUM_ADDR;
 933               		.loc 1 337 0
 934 00d0 412C      		mov r4,__zero_reg__
 935 00d2 40E2      		ldi r20,lo8(32)
 936 00d4 542E      		mov r5,r20
 937 00d6 612C      		mov r6,__zero_reg__
 938 00d8 712C      		mov r7,__zero_reg__
 939 00da 9E01      		movw r18,r28
 940 00dc 2F5F      		subi r18,-1
 941 00de 3E4F      		sbci r19,-2
 942 00e0 CC5D      		subi r28,lo8(-292)
 943 00e2 DE4F      		sbci r29,hi8(-292)
 944 00e4 3983      		std Y+1,r19
 945 00e6 2883      		st Y,r18
 946 00e8 C452      		subi r28,lo8(292)
 947 00ea D140      		sbci r29,hi8(292)
 948               	.LVL89:
 949               	.L31:
 353:bootSAH_3.c   **** 			{
 950               		.loc 1 353 0 discriminator 1
 951 00ec C05E      		subi r28,lo8(-288)
 952 00ee DE4F      		sbci r29,hi8(-288)
 953 00f0 8881      		ld r24,Y
 954 00f2 9981      		ldd r25,Y+1
 955 00f4 C052      		subi r28,lo8(288)
 956 00f6 D140      		sbci r29,hi8(288)
 957 00f8 CA5D      		subi r28,lo8(-294)
 958 00fa DE4F      		sbci r29,hi8(-294)
 959 00fc E881      		ld r30,Y
 960 00fe F981      		ldd r31,Y+1
 961 0100 C652      		subi r28,lo8(294)
 962 0102 D140      		sbci r29,hi8(294)
 963 0104 E817      		cp r30,r24
 964 0106 F907      		cpc r31,r25
 965 0108 00F0      		brlo .+2
 966 010a 00C0      		rjmp .L51
 967               	.LVL90:
 357:bootSAH_3.c   **** 				SPI_Transfer(0x03);
 968               		.loc 1 357 0
 969 010c 2898      		cbi 0x5,0
 358:bootSAH_3.c   **** 				SPI_Transfer((fDataAddr >> 16) & 0xff);
 970               		.loc 1 358 0
 971 010e 83E0      		ldi r24,lo8(3)
 972 0110 0E94 0000 		call SPI_Transfer
 973               	.LVL91:
 359:bootSAH_3.c   **** 				SPI_Transfer((fDataAddr >> 8) & 0xff);
 974               		.loc 1 359 0
 975 0114 862D      		mov r24,r6
 976 0116 0E94 0000 		call SPI_Transfer
 977               	.LVL92:
 360:bootSAH_3.c   **** 				SPI_Transfer(fDataAddr & 0xff);
 978               		.loc 1 360 0
 979 011a 852D      		mov r24,r5
 980 011c 0E94 0000 		call SPI_Transfer
 981               	.LVL93:
 361:bootSAH_3.c   **** 				for(fii=0; fii<256; fii++)
 982               		.loc 1 361 0
 983 0120 80E0      		ldi r24,0
 984 0122 0E94 0000 		call SPI_Transfer
 985               	.LVL94:
 986 0126 CE01      		movw r24,r28
 987 0128 0196      		adiw r24,1
 988 012a 1C01      		movw r2,r24
 989 012c C85D      		subi r28,lo8(-296)
 990 012e DE4F      		sbci r29,hi8(-296)
 991 0130 9983      		std Y+1,r25
 992 0132 8883      		st Y,r24
 993 0134 C852      		subi r28,lo8(296)
 994 0136 D140      		sbci r29,hi8(296)
 356:bootSAH_3.c   **** 				PROG_PORT &= ~(1<<PROGCS_PIN);
 995               		.loc 1 356 0
 996 0138 00E0      		ldi r16,0
 997 013a 10E0      		ldi r17,0
 998               	.LVL95:
 999               	.L32:
 364:bootSAH_3.c   **** 					fChSumCal += msgBuffer[fii];
 1000               		.loc 1 364 0 discriminator 3
 1001 013c 80E0      		ldi r24,0
 1002 013e 0E94 0000 		call SPI_Transfer
 1003               	.LVL96:
 1004 0142 C85D      		subi r28,lo8(-296)
 1005 0144 DE4F      		sbci r29,hi8(-296)
 1006 0146 E881      		ld r30,Y
 1007 0148 F981      		ldd r31,Y+1
 1008 014a C852      		subi r28,lo8(296)
 1009 014c D140      		sbci r29,hi8(296)
 1010 014e 8193      		st Z+,r24
 1011 0150 C85D      		subi r28,lo8(-296)
 1012 0152 DE4F      		sbci r29,hi8(-296)
 1013 0154 F983      		std Y+1,r31
 1014 0156 E883      		st Y,r30
 1015 0158 C852      		subi r28,lo8(296)
 1016 015a D140      		sbci r29,hi8(296)
 365:bootSAH_3.c   **** 				}
 1017               		.loc 1 365 0 discriminator 3
 1018 015c 080F      		add r16,r24
 1019 015e 111D      		adc r17,__zero_reg__
 1020               	.LVL97:
 362:bootSAH_3.c   **** 				{
 1021               		.loc 1 362 0 discriminator 3
 1022 0160 CC5D      		subi r28,lo8(-292)
 1023 0162 DE4F      		sbci r29,hi8(-292)
 1024 0164 2881      		ld r18,Y
 1025 0166 3981      		ldd r19,Y+1
 1026 0168 C452      		subi r28,lo8(292)
 1027 016a D140      		sbci r29,hi8(292)
 1028 016c 2E17      		cp r18,r30
 1029 016e 3F07      		cpc r19,r31
 1030 0170 01F4      		brne .L32
 367:bootSAH_3.c   **** 				fDataAddr += EXMEM_PAGE_SIZE;
 1031               		.loc 1 367 0
 1032 0172 289A      		sbi 0x5,0
 368:bootSAH_3.c   **** 				_delay_us(10);
 1033               		.loc 1 368 0
 1034 0174 3FEF      		ldi r19,-1
 1035 0176 531A      		sub r5,r19
 1036 0178 630A      		sbc r6,r19
 1037 017a 730A      		sbc r7,r19
 1038               	.LVL98:
 1039               	.LBB47:
 1040               	.LBB48:
 1041               		.loc 2 276 0
 1042 017c 85E3      		ldi r24,lo8(53)
 1043 017e 8A95      	1:	dec r24
 1044 0180 01F4      		brne 1b
 1045 0182 0000      		nop
 1046               	.LVL99:
 1047               	.LBE48:
 1048               	.LBE47:
 371:bootSAH_3.c   **** 				  
 1049               		.loc 1 371 0
 1050 0184 AE01      		movw r20,r28
 1051 0186 425E      		subi r20,-30
 1052 0188 5E4F      		sbci r21,-2
 1053 018a C501      		movw r24,r10
 1054 018c B401      		movw r22,r8
 1055 018e 0E94 0000 		call FLASH_ReadWord
 1056               	.LVL100:
 373:bootSAH_3.c   **** 				{
 1057               		.loc 1 373 0
 1058 0192 C25E      		subi r28,lo8(-286)
 1059 0194 DE4F      		sbci r29,hi8(-286)
 1060 0196 8881      		ld r24,Y
 1061 0198 9981      		ldd r25,Y+1
 1062 019a CE51      		subi r28,lo8(286)
 1063 019c D140      		sbci r29,hi8(286)
 1064 019e 8017      		cp r24,r16
 1065 01a0 9107      		cpc r25,r17
 1066 01a2 01F0      		breq .+2
 1067 01a4 00C0      		rjmp .L33
 1068               	.LVL101:
 1069               	.LBB49:
 381:bootSAH_3.c   **** 					{
 1070               		.loc 1 381 0
 1071 01a6 C114      		cp r12,__zero_reg__
 1072 01a8 90EC      		ldi r25,-64
 1073 01aa D906      		cpc r13,r25
 1074 01ac 93E0      		ldi r25,3
 1075 01ae E906      		cpc r14,r25
 1076 01b0 F104      		cpc r15,__zero_reg__
 1077 01b2 00F4      		brsh .L39
 383:bootSAH_3.c   **** 					    boot_spm_busy_wait();				// Wait until the memory is erased.
 1078               		.loc 1 383 0
 1079 01b4 83E0      		ldi r24,lo8(3)
 1080               	/* #APP */
 1081               	 ;  383 "bootSAH_3.c" 1
 1082 01b6 F601      		movw r30, r12
 1083 01b8 E092 5B00 		sts  91, r14
 1084 01bc 8093 5700 		sts 87, r24
 1085 01c0 E895      		spm
 1086               		
 1087               	 ;  0 "" 2
 1088               	/* #NOAPP */
 1089               	.L35:
 384:bootSAH_3.c   **** 					}
 1090               		.loc 1 384 0 discriminator 1
 1091 01c2 07B6      		in __tmp_reg__,0x37
 1092 01c4 00FC      		sbrc __tmp_reg__,0
 1093 01c6 00C0      		rjmp .L35
 1094               	.L39:
 1095 01c8 B701      		movw r22,r14
 1096 01ca A601      		movw r20,r12
 1097               	.LVL102:
 1098               	.L44:
 393:bootSAH_3.c   **** 						address += 2;						// inc boot page address
 1099               		.loc 1 393 0 discriminator 3
 1100 01cc F101      		movw r30,r2
 1101 01ce 8181      		ldd r24,Z+1
 1102 01d0 90E0      		ldi r25,0
 1103 01d2 982F      		mov r25,r24
 1104 01d4 8827      		clr r24
 1105 01d6 2081      		ld r18,Z
 1106 01d8 822B      		or r24,r18
 1107 01da 21E0      		ldi r18,lo8(1)
 1108               	/* #APP */
 1109               	 ;  393 "bootSAH_3.c" 1
 1110 01dc 0C01      		movw  r0, r24
 1111 01de FA01      		movw r30, r20
 1112 01e0 6093 5B00 		sts 91, r22
 1113 01e4 2093 5700 		sts 87, r18
 1114 01e8 E895      		spm
 1115 01ea 1124      		clr  r1
 1116               		
 1117               	 ;  0 "" 2
 394:bootSAH_3.c   **** 					}
 1118               		.loc 1 394 0 discriminator 3
 1119               	/* #NOAPP */
 1120 01ec 4E5F      		subi r20,-2
 1121 01ee 5F4F      		sbci r21,-1
 1122 01f0 6F4F      		sbci r22,-1
 1123 01f2 7F4F      		sbci r23,-1
 1124               	.LVL103:
 1125 01f4 32E0      		ldi r19,2
 1126 01f6 230E      		add r2,r19
 1127 01f8 311C      		adc r3,__zero_reg__
 1128               	.LVL104:
 387:bootSAH_3.c   **** 					{
 1129               		.loc 1 387 0 discriminator 3
 1130 01fa CC5D      		subi r28,lo8(-292)
 1131 01fc DE4F      		sbci r29,hi8(-292)
 1132 01fe 8881      		ld r24,Y
 1133 0200 9981      		ldd r25,Y+1
 1134 0202 C452      		subi r28,lo8(292)
 1135 0204 D140      		sbci r29,hi8(292)
 1136 0206 8215      		cp r24,r2
 1137 0208 9305      		cpc r25,r3
 1138 020a 01F4      		brne .L44
 397:bootSAH_3.c   **** 					boot_spm_busy_wait();
 1139               		.loc 1 397 0
 1140 020c 95E0      		ldi r25,lo8(5)
 1141               	/* #APP */
 1142               	 ;  397 "bootSAH_3.c" 1
 1143 020e F601      		movw r30, r12
 1144 0210 E092 5B00 		sts 91, r14
 1145 0214 9093 5700 		sts 87, r25
 1146 0218 E895      		spm
 1147               		
 1148               	 ;  0 "" 2
 1149               	/* #NOAPP */
 1150               	.L36:
 398:bootSAH_3.c   **** 					boot_rww_enable();						// Re-enable the RWW section
 1151               		.loc 1 398 0 discriminator 1
 1152 021a 07B6      		in __tmp_reg__,0x37
 1153 021c 00FC      		sbrc __tmp_reg__,0
 1154 021e 00C0      		rjmp .L36
 399:bootSAH_3.c   **** 					
 1155               		.loc 1 399 0
 1156 0220 E1E1      		ldi r30,lo8(17)
 1157               	/* #APP */
 1158               	 ;  399 "bootSAH_3.c" 1
 1159 0222 E093 5700 		sts 87, r30
 1160 0226 E895      		spm
 1161               		
 1162               	 ;  0 "" 2
 401:bootSAH_3.c   **** 					fCsumAddr += 2;
 1163               		.loc 1 401 0
 1164               	/* #NOAPP */
 1165 0228 FFEF      		ldi r31,-1
 1166 022a DF1A      		sub r13,r31
 1167 022c EF0A      		sbc r14,r31
 1168 022e FF0A      		sbc r15,r31
 1169               	.LVL105:
 402:bootSAH_3.c   **** 
 1170               		.loc 1 402 0
 1171 0230 22E0      		ldi r18,2
 1172 0232 820E      		add r8,r18
 1173 0234 911C      		adc r9,__zero_reg__
 1174 0236 A11C      		adc r10,__zero_reg__
 1175 0238 B11C      		adc r11,__zero_reg__
 1176               	.LVL106:
 1177               	.L33:
 1178               	.LBE49:
 353:bootSAH_3.c   **** 			{
 1179               		.loc 1 353 0 discriminator 2
 1180 023a CA5D      		subi r28,lo8(-294)
 1181 023c DE4F      		sbci r29,hi8(-294)
 1182 023e 8881      		ld r24,Y
 1183 0240 9981      		ldd r25,Y+1
 1184 0242 C652      		subi r28,lo8(294)
 1185 0244 D140      		sbci r29,hi8(294)
 1186 0246 0196      		adiw r24,1
 1187 0248 CA5D      		subi r28,lo8(-294)
 1188 024a DE4F      		sbci r29,hi8(-294)
 1189 024c 9983      		std Y+1,r25
 1190 024e 8883      		st Y,r24
 1191 0250 C652      		subi r28,lo8(294)
 1192 0252 D140      		sbci r29,hi8(294)
 1193               	.LVL107:
 1194 0254 00C0      		rjmp .L31
 1195               	.LVL108:
 1196               	.L51:
 419:bootSAH_3.c   **** 			//app_start();
 1197               		.loc 1 419 0
 1198 0256 60E0      		ldi r22,0
 1199 0258 70E1      		ldi r23,lo8(16)
 1200 025a 80E0      		ldi r24,0
 1201 025c 90E0      		ldi r25,0
 1202 025e 0E94 0000 		call FLASH_EraseSector
 1203               	.LVL109:
 1204               	.L29:
 1205               	.LBE46:
 442:bootSAH_3.c   **** 	PROG_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 1206               		.loc 1 442 0
 1207 0262 2698      		cbi 0x4,6
 443:bootSAH_3.c   **** //	PROG_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 1208               		.loc 1 443 0
 1209 0264 2E98      		cbi 0x5,6
 445:bootSAH_3.c   **** #endif
 1210               		.loc 1 445 0
 1211 0266 84E6      		ldi r24,lo8(100)
 1212 0268 90E0      		ldi r25,0
 1213 026a 0E94 0000 		call delay_ms
 1214               	.LVL110:
 449:bootSAH_3.c   **** 
 1215               		.loc 1 449 0
 1216               	/* #APP */
 1217               	 ;  449 "bootSAH_3.c" 1
 1218 026e 0000      		nop
 1219               	 ;  0 "" 2
 456:bootSAH_3.c   **** 
 1220               		.loc 1 456 0
 1221               	/* #NOAPP */
 1222 0270 81E1      		ldi r24,lo8(17)
 1223               	/* #APP */
 1224               	 ;  456 "bootSAH_3.c" 1
 1225 0272 8093 5700 		sts 87, r24
 1226 0276 E895      		spm
 1227               		
 1228               	 ;  0 "" 2
 459:bootSAH_3.c   **** 			"clr	r30		\n\t"
 1229               		.loc 1 459 0
 1230               	 ;  459 "bootSAH_3.c" 1
 1231 0278 EE27      		clr	r30		
 1232 027a FF27      		clr	r31		
 1233 027c 0994      		ijmp	
 1234               		
 1235               	 ;  0 "" 2
 1236               	/* #NOAPP */
 1237               	.L38:
 1238 027e 00C0      		rjmp .L38
 1239               		.cfi_endproc
 1240               	.LFE13:
 1242               	.global	app_start
 1243               		.section .bss
 1246               	app_start:
 1247 0000 0000      		.zero	2
 1248               		.text
 1249               	.Letext0:
 1250               		.file 3 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\st
DEFINED SYMBOLS
                            *ABS*:00000000 bootSAH_3.c
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:2      *ABS*:0000003e __SP_H__
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:3      *ABS*:0000003d __SP_L__
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:4      *ABS*:0000003f __SREG__
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:7      *ABS*:00000001 __zero_reg__
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:14     .init9:00000000 __jumpMain
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:26     *ABS*:000021ff __stack
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:753    .text.startup:00000000 main
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:65     .text:00000000 delay_ms
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:111    .text:0000001e SPI_Init
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:131    .text:00000028 SPI_Transfer
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:163    .text:00000036 FLASH_WriteEnable
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:196    .text:0000004a FLASH_ResetEnable
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:229    .text:0000005e FLASH_Reset
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:262    .text:00000072 FLASH_UntilReady
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:310    .text:00000094 FLASH_Init
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:412    .text:00000100 FLASH_ReadByte
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:495    .text:0000014a FLASH_ReadWord
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:594    .text:000001a8 FLASH_WriteByte
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:679    .text:000001f6 FLASH_EraseSector
C:\Users\supun\AppData\Local\Temp\ccXm3y02.s:1246   .bss:00000000 app_start

UNDEFINED SYMBOLS
__do_clear_bss
