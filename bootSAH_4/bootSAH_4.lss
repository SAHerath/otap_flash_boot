
bootSAH_4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800200  0003e4a8  0000053c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004a8  0003e000  0003e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800210  00800210  0000054c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000054c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000057c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000030  00000000  00000000  000005bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000015ba  00000000  00000000  000005ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d92  00000000  00000000  00001ba6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000508  00000000  00000000  00002938  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000014c  00000000  00000000  00002e40  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006c4  00000000  00000000  00002f8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000041b  00000000  00000000  00003650  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000020  00000000  00000000  00003a6b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0003e000 <__vectors>:
   3e000:	0d 94 72 f0 	jmp	0x3e0e4	; 0x3e0e4 <__ctors_end>
   3e004:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e008:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e00c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e010:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e014:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e018:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e01c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e020:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e024:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e028:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e02c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e030:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e034:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e038:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e03c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e040:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e044:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e048:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e04c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e050:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e054:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e058:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e05c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e060:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e064:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e068:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e06c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e070:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e074:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e078:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e07c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e080:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e084:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e088:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e08c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e090:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e094:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e098:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e09c:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0a0:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0a4:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0a8:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0ac:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0b0:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0b4:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0b8:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0bc:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0c0:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0c4:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0c8:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0cc:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0d0:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0d4:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0d8:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0dc:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>
   3e0e0:	0d 94 9b f0 	jmp	0x3e136	; 0x3e136 <__bad_interrupt>

0003e0e4 <__ctors_end>:
   3e0e4:	11 24       	eor	r1, r1
   3e0e6:	1f be       	out	0x3f, r1	; 63
   3e0e8:	cf ef       	ldi	r28, 0xFF	; 255
   3e0ea:	d1 e2       	ldi	r29, 0x21	; 33
   3e0ec:	de bf       	out	0x3e, r29	; 62
   3e0ee:	cd bf       	out	0x3d, r28	; 61
   3e0f0:	01 e0       	ldi	r16, 0x01	; 1
   3e0f2:	0c bf       	out	0x3c, r16	; 60

0003e0f4 <__do_copy_data>:
   3e0f4:	12 e0       	ldi	r17, 0x02	; 2
   3e0f6:	a0 e0       	ldi	r26, 0x00	; 0
   3e0f8:	b2 e0       	ldi	r27, 0x02	; 2
   3e0fa:	e8 ea       	ldi	r30, 0xA8	; 168
   3e0fc:	f4 ee       	ldi	r31, 0xE4	; 228
   3e0fe:	03 e0       	ldi	r16, 0x03	; 3
   3e100:	0b bf       	out	0x3b, r16	; 59
   3e102:	02 c0       	rjmp	.+4      	; 0x3e108 <__do_copy_data+0x14>
   3e104:	07 90       	elpm	r0, Z+
   3e106:	0d 92       	st	X+, r0
   3e108:	a0 31       	cpi	r26, 0x10	; 16
   3e10a:	b1 07       	cpc	r27, r17
   3e10c:	d9 f7       	brne	.-10     	; 0x3e104 <__do_copy_data+0x10>

0003e10e <__do_clear_bss>:
   3e10e:	22 e0       	ldi	r18, 0x02	; 2
   3e110:	a0 e1       	ldi	r26, 0x10	; 16
   3e112:	b2 e0       	ldi	r27, 0x02	; 2
   3e114:	01 c0       	rjmp	.+2      	; 0x3e118 <.do_clear_bss_start>

0003e116 <.do_clear_bss_loop>:
   3e116:	1d 92       	st	X+, r1

0003e118 <.do_clear_bss_start>:
   3e118:	a2 31       	cpi	r26, 0x12	; 18
   3e11a:	b2 07       	cpc	r27, r18
   3e11c:	e1 f7       	brne	.-8      	; 0x3e116 <.do_clear_bss_loop>
   3e11e:	0f 94 8f f1 	call	0x3e31e	; 0x3e31e <main>
   3e122:	0d 94 52 f2 	jmp	0x3e4a4	; 0x3e4a4 <_exit>

0003e126 <__jumpMain>:

	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );

//*	set stack pointer to top of RAM

	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
   3e126:	01 e2       	ldi	r16, 0x21	; 33
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
   3e128:	0e bf       	out	0x3e, r16	; 62

	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
   3e12a:	0f ef       	ldi	r16, 0xFF	; 255
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
   3e12c:	0d bf       	out	0x3d, r16	; 61

	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
   3e12e:	11 24       	eor	r1, r1
	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
   3e130:	1f be       	out	0x3f, r1	; 63
	asm volatile ( "jmp main");												// jump to main()
   3e132:	0d 94 8f f1 	jmp	0x3e31e	; 0x3e31e <main>

0003e136 <__bad_interrupt>:
   3e136:	0d 94 00 f0 	jmp	0x3e000	; 0x3e000 <__vectors>

0003e13a <sendchar>:

//*****************************************************************************

static void sendchar(char c)
{
	UART_DATA_REG	=	c;										// prepare transmission
   3e13a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
   3e13e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
   3e142:	86 ff       	sbrs	r24, 6
   3e144:	fc cf       	rjmp	.-8      	; 0x3e13e <sendchar+0x4>
	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
   3e146:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
   3e14a:	80 64       	ori	r24, 0x40	; 64
   3e14c:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
   3e150:	08 95       	ret

0003e152 <SPI_Transfer>:
	return UART_DATA_REG;
}

static uint8_t SPI_Transfer(uint8_t spidata)
{
	SPDR = spidata;
   3e152:	8e bd       	out	0x2e, r24	; 46
	asm volatile("nop");			// small delay
   3e154:	00 00       	nop
	while(!(SPSR & (1<<SPIF)));		// Wait for transmission complete
   3e156:	0d b4       	in	r0, 0x2d	; 45
   3e158:	07 fe       	sbrs	r0, 7
   3e15a:	fd cf       	rjmp	.-6      	; 0x3e156 <SPI_Transfer+0x4>

	return SPDR;
   3e15c:	8e b5       	in	r24, 0x2e	; 46
}
   3e15e:	08 95       	ret

0003e160 <delay_ms>:

//*****************************************************************************
void delay_ms(unsigned int timedelay)
{
	unsigned int i;
	for (i=0;i<timedelay;i++)
   3e160:	20 e0       	ldi	r18, 0x00	; 0
   3e162:	30 e0       	ldi	r19, 0x00	; 0
   3e164:	28 17       	cp	r18, r24
   3e166:	39 07       	cpc	r19, r25
   3e168:	49 f0       	breq	.+18     	; 0x3e17c <delay_ms+0x1c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   3e16a:	ef ec       	ldi	r30, 0xCF	; 207
   3e16c:	f7 e0       	ldi	r31, 0x07	; 7
   3e16e:	31 97       	sbiw	r30, 0x01	; 1
   3e170:	f1 f7       	brne	.-4      	; 0x3e16e <delay_ms+0xe>
   3e172:	00 c0       	rjmp	.+0      	; 0x3e174 <delay_ms+0x14>
   3e174:	00 00       	nop
   3e176:	2f 5f       	subi	r18, 0xFF	; 255
   3e178:	3f 4f       	sbci	r19, 0xFF	; 255
   3e17a:	f4 cf       	rjmp	.-24     	; 0x3e164 <delay_ms+0x4>
	{
		_delay_ms(0.5);
	}
}
   3e17c:	08 95       	ret

0003e17e <tiny_delay>:
	...
//** small delay
void tiny_delay()		
{
	asm volatile(
   3e186:	00 00       	nop
   3e188:	08 95       	ret

0003e18a <printByte>:
	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
}

void printByte(uint8_t numData)
{
   3e18a:	1f 93       	push	r17
   3e18c:	cf 93       	push	r28
   3e18e:	df 93       	push	r29
   3e190:	cd b7       	in	r28, 0x3d	; 61
   3e192:	de b7       	in	r29, 0x3e	; 62
   3e194:	60 97       	sbiw	r28, 0x10	; 16
   3e196:	0f b6       	in	r0, 0x3f	; 63
   3e198:	f8 94       	cli
   3e19a:	de bf       	out	0x3e, r29	; 62
   3e19c:	0f be       	out	0x3f, r0	; 63
   3e19e:	cd bf       	out	0x3d, r28	; 61
   3e1a0:	18 2f       	mov	r17, r24
	char chData;
	const char hexArr[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
   3e1a2:	80 e1       	ldi	r24, 0x10	; 16
   3e1a4:	e0 e0       	ldi	r30, 0x00	; 0
   3e1a6:	f2 e0       	ldi	r31, 0x02	; 2
   3e1a8:	de 01       	movw	r26, r28
   3e1aa:	11 96       	adiw	r26, 0x01	; 1
   3e1ac:	01 90       	ld	r0, Z+
   3e1ae:	0d 92       	st	X+, r0
   3e1b0:	8a 95       	dec	r24
   3e1b2:	e1 f7       	brne	.-8      	; 0x3e1ac <printByte+0x22>
	chData = hexArr[numData>>4];
   3e1b4:	81 2f       	mov	r24, r17
   3e1b6:	82 95       	swap	r24
   3e1b8:	8f 70       	andi	r24, 0x0F	; 15
   3e1ba:	e1 e0       	ldi	r30, 0x01	; 1
   3e1bc:	f0 e0       	ldi	r31, 0x00	; 0
   3e1be:	ec 0f       	add	r30, r28
   3e1c0:	fd 1f       	adc	r31, r29
   3e1c2:	e8 0f       	add	r30, r24
   3e1c4:	f1 1d       	adc	r31, r1
	sendchar(chData);
   3e1c6:	80 81       	ld	r24, Z
   3e1c8:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	chData = hexArr[numData&0xF];
   3e1cc:	1f 70       	andi	r17, 0x0F	; 15
   3e1ce:	e1 e0       	ldi	r30, 0x01	; 1
   3e1d0:	f0 e0       	ldi	r31, 0x00	; 0
   3e1d2:	ec 0f       	add	r30, r28
   3e1d4:	fd 1f       	adc	r31, r29
   3e1d6:	e1 0f       	add	r30, r17
   3e1d8:	f1 1d       	adc	r31, r1
	sendchar(chData);
   3e1da:	80 81       	ld	r24, Z
}
   3e1dc:	60 96       	adiw	r28, 0x10	; 16
   3e1de:	0f b6       	in	r0, 0x3f	; 63
   3e1e0:	f8 94       	cli
   3e1e2:	de bf       	out	0x3e, r29	; 62
   3e1e4:	0f be       	out	0x3f, r0	; 63
   3e1e6:	cd bf       	out	0x3d, r28	; 61
   3e1e8:	df 91       	pop	r29
   3e1ea:	cf 91       	pop	r28
   3e1ec:	1f 91       	pop	r17
	char chData;
	const char hexArr[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
	chData = hexArr[numData>>4];
	sendchar(chData);
	chData = hexArr[numData&0xF];
	sendchar(chData);
   3e1ee:	0d 94 9d f0 	jmp	0x3e13a	; 0x3e13a <sendchar>

0003e1f2 <FLASH_UntilReady>:
}

void FLASH_UntilReady()
{
	uint8_t stat=0xff;
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e1f2:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x05);
   3e1f4:	85 e0       	ldi	r24, 0x05	; 5
   3e1f6:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	return SPDR;
}

void FLASH_UntilReady()
{
	uint8_t stat=0xff;
   3e1fa:	8f ef       	ldi	r24, 0xFF	; 255
	SPI_PORT  &=  ~(1<<SPI_CS);
	SPI_Transfer(0x05);
	while((stat & 0x01) == 0x01)
   3e1fc:	80 ff       	sbrs	r24, 0
   3e1fe:	04 c0       	rjmp	.+8      	; 0x3e208 <FLASH_UntilReady+0x16>
	{
		stat = SPI_Transfer(0);
   3e200:	80 e0       	ldi	r24, 0x00	; 0
   3e202:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
   3e206:	fa cf       	rjmp	.-12     	; 0x3e1fc <FLASH_UntilReady+0xa>
	}
	SPI_PORT  |=   (1<<SPI_CS);
   3e208:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e20a:	0d 94 bf f0 	jmp	0x3e17e	; 0x3e17e <tiny_delay>

0003e20e <FLASH_ResetEnable>:
}

void FLASH_ResetEnable()
{
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e20e:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x66);
   3e210:	86 e6       	ldi	r24, 0x66	; 102
   3e212:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e216:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e218:	0d 94 bf f0 	jmp	0x3e17e	; 0x3e17e <tiny_delay>

0003e21c <FLASH_Reset>:
}

void FLASH_Reset()
{
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e21c:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x99);
   3e21e:	89 e9       	ldi	r24, 0x99	; 153
   3e220:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e224:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e226:	0d 94 bf f0 	jmp	0x3e17e	; 0x3e17e <tiny_delay>

0003e22a <FLASH_WriteEnable>:
}

void FLASH_WriteEnable()
{
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e22a:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x06);
   3e22c:	86 e0       	ldi	r24, 0x06	; 6
   3e22e:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e232:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e234:	0d 94 bf f0 	jmp	0x3e17e	; 0x3e17e <tiny_delay>

0003e238 <FLASH_ReadWord>:
}

uint16_t FLASH_ReadWord(uint32_t faddr)
{
   3e238:	1f 93       	push	r17
   3e23a:	cf 93       	push	r28
   3e23c:	df 93       	push	r29
   3e23e:	eb 01       	movw	r28, r22
   3e240:	18 2f       	mov	r17, r24
	uint16_t temp1=0, temp2=0;
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e242:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x03);
   3e244:	83 e0       	ldi	r24, 0x03	; 3
   3e246:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e24a:	81 2f       	mov	r24, r17
   3e24c:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e250:	8d 2f       	mov	r24, r29
   3e252:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e256:	8c 2f       	mov	r24, r28
   3e258:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	temp1 = SPI_Transfer(0);
   3e25c:	80 e0       	ldi	r24, 0x00	; 0
   3e25e:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
   3e262:	d8 2f       	mov	r29, r24
	temp2 = SPI_Transfer(0);
   3e264:	80 e0       	ldi	r24, 0x00	; 0
   3e266:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
   3e26a:	c8 2f       	mov	r28, r24
	SPI_PORT  |=   (1<<SPI_CS);
   3e26c:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e26e:	0f 94 bf f0 	call	0x3e17e	; 0x3e17e <tiny_delay>
							sendchar(temp1 & 0xff);
   3e272:	8d 2f       	mov	r24, r29
   3e274:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
							sendchar(temp2 & 0xff);
   3e278:	8c 2f       	mov	r24, r28
   3e27a:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
							sendchar(0x0d);
   3e27e:	8d e0       	ldi	r24, 0x0D	; 13
   3e280:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
							sendchar(0x0a);
   3e284:	8a e0       	ldi	r24, 0x0A	; 10
   3e286:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
							
	return ((temp1 << 8) | (temp2 & 0x00ff));
   3e28a:	8c 2f       	mov	r24, r28
   3e28c:	90 e0       	ldi	r25, 0x00	; 0

}
   3e28e:	9d 2b       	or	r25, r29
   3e290:	df 91       	pop	r29
   3e292:	cf 91       	pop	r28
   3e294:	1f 91       	pop	r17
   3e296:	08 95       	ret

0003e298 <FLASH_EraseSector>:

void FLASH_EraseSector(uint32_t faddr)
{
   3e298:	1f 93       	push	r17
   3e29a:	cf 93       	push	r28
   3e29c:	df 93       	push	r29
   3e29e:	eb 01       	movw	r28, r22
   3e2a0:	18 2f       	mov	r17, r24
	FLASH_UntilReady();
   3e2a2:	0f 94 f9 f0 	call	0x3e1f2	; 0x3e1f2 <FLASH_UntilReady>
	FLASH_WriteEnable();
   3e2a6:	0f 94 15 f1 	call	0x3e22a	; 0x3e22a <FLASH_WriteEnable>
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e2aa:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x20);
   3e2ac:	80 e2       	ldi	r24, 0x20	; 32
   3e2ae:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e2b2:	81 2f       	mov	r24, r17
   3e2b4:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e2b8:	8d 2f       	mov	r24, r29
   3e2ba:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e2be:	8c 2f       	mov	r24, r28
   3e2c0:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e2c4:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e2c6:	0f 94 bf f0 	call	0x3e17e	; 0x3e17e <tiny_delay>
	FLASH_UntilReady();
}
   3e2ca:	df 91       	pop	r29
   3e2cc:	cf 91       	pop	r28
   3e2ce:	1f 91       	pop	r17
	SPI_Transfer((faddr >> 16) & 0xff);
	SPI_Transfer((faddr >> 8) & 0xff);
	SPI_Transfer(faddr & 0xff);
	SPI_PORT  |=   (1<<SPI_CS);
	tiny_delay();
	FLASH_UntilReady();
   3e2d0:	0d 94 f9 f0 	jmp	0x3e1f2	; 0x3e1f2 <FLASH_UntilReady>

0003e2d4 <FLASH_WriteByte>:
}

void FLASH_WriteByte(uint32_t faddr, uint8_t wdata)
{
   3e2d4:	0f 93       	push	r16
   3e2d6:	1f 93       	push	r17
   3e2d8:	cf 93       	push	r28
   3e2da:	df 93       	push	r29
   3e2dc:	d6 2f       	mov	r29, r22
   3e2de:	17 2f       	mov	r17, r23
   3e2e0:	08 2f       	mov	r16, r24
   3e2e2:	c4 2f       	mov	r28, r20
	FLASH_UntilReady();
   3e2e4:	0f 94 f9 f0 	call	0x3e1f2	; 0x3e1f2 <FLASH_UntilReady>
	FLASH_WriteEnable();
   3e2e8:	0f 94 15 f1 	call	0x3e22a	; 0x3e22a <FLASH_WriteEnable>
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e2ec:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x02);
   3e2ee:	82 e0       	ldi	r24, 0x02	; 2
   3e2f0:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e2f4:	80 2f       	mov	r24, r16
   3e2f6:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e2fa:	81 2f       	mov	r24, r17
   3e2fc:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e300:	8d 2f       	mov	r24, r29
   3e302:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_Transfer(wdata & 0xff);
   3e306:	8c 2f       	mov	r24, r28
   3e308:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e30c:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e30e:	0f 94 bf f0 	call	0x3e17e	; 0x3e17e <tiny_delay>
	FLASH_UntilReady();
}
   3e312:	df 91       	pop	r29
   3e314:	cf 91       	pop	r28
   3e316:	1f 91       	pop	r17
   3e318:	0f 91       	pop	r16
	SPI_Transfer((faddr >> 8) & 0xff);
	SPI_Transfer(faddr & 0xff);
	SPI_Transfer(wdata & 0xff);
	SPI_PORT  |=   (1<<SPI_CS);
	tiny_delay();
	FLASH_UntilReady();
   3e31a:	0d 94 f9 f0 	jmp	0x3e1f2	; 0x3e1f2 <FLASH_UntilReady>

0003e31e <main>:

//************************************************************************
	
	//*	some chips dont set the stack properly
	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
   3e31e:	01 e2       	ldi	r16, 0x21	; 33
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
   3e320:	0e bf       	out	0x3e, r16	; 62
	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
   3e322:	0f ef       	ldi	r16, 0xFF	; 255
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
   3e324:	0d bf       	out	0x3d, r16	; 61
	
//************************************************************************

//*	handle the watch dog timer
	uint8_t	mcuStatusReg;
	mcuStatusReg	=	MCUSR;
   3e326:	94 b7       	in	r25, 0x34	; 52

	__asm__ __volatile__ ("cli");
   3e328:	f8 94       	cli
	__asm__ __volatile__ ("wdr");
   3e32a:	a8 95       	wdr
	//MCUSR	=	0;
	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
   3e32c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
   3e330:	88 61       	ori	r24, 0x18	; 24
   3e332:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	WDTCSR	=	0;
   3e336:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	__asm__ __volatile__ ("sei");
   3e33a:	78 94       	sei
	// check if WDT generated the reset, if so, go straight to app
	if (mcuStatusReg & _BV(WDRF))
   3e33c:	93 ff       	sbrs	r25, 3
   3e33e:	05 c0       	rjmp	.+10     	; 0x3e34a <main+0x2c>
	{
		app_start();
   3e340:	e0 91 10 02 	lds	r30, 0x0210	; 0x800210 <__data_end>
   3e344:	f0 91 11 02 	lds	r31, 0x0211	; 0x800211 <__data_end+0x1>
   3e348:	19 95       	eicall

//* Init UART
//*set baudrate and enable USART receiver and transmiter without interrupts

#if UART_BAUDRATE_DOUBLE_SPEED
	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
   3e34a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
   3e34e:	82 60       	ori	r24, 0x02	; 2
   3e350:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
#endif
	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
   3e354:	80 e1       	ldi	r24, 0x10	; 16
   3e356:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
   3e35a:	88 e1       	ldi	r24, 0x18	; 24
   3e35c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>

	asm volatile ("nop");			// wait until port has changed
   3e360:	00 00       	nop

//************************************************************************

//* Init SPI
	SPI_DDR = (	(0<<SPI_MISO)|
   3e362:	87 e0       	ldi	r24, 0x07	; 7
   3e364:	84 b9       	out	0x04, r24	; 4
				(1<<SPI_MOSI)|
				(1<<SPI_SCK) |
				(1<<SPI_CS)
			  );

	SPCR = (	(1<<SPE) |              // SPI Enable
   3e366:	81 e5       	ldi	r24, 0x51	; 81
   3e368:	8c bd       	out	0x2c, r24	; 44
				(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
				(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
				(0<<CPHA)               // Clock Phase (0:leading / 1:trailing edge sampling)
			);
			
	SPI_PORT |=  (1<<SPI_CS); 			// pull high
   3e36a:	28 9a       	sbi	0x05, 0	; 5
	
	asm volatile ("nop");				// wait until port has changed
   3e36c:	00 00       	nop
	
//************************************************************************
	
#ifdef _DEBUG_SERIAL_

	sendchar('u');
   3e36e:	85 e7       	ldi	r24, 0x75	; 117
   3e370:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar('t');
   3e374:	84 e7       	ldi	r24, 0x74	; 116
   3e376:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar('e');
   3e37a:	85 e6       	ldi	r24, 0x65	; 101
   3e37c:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar('c');
   3e380:	83 e6       	ldi	r24, 0x63	; 99
   3e382:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar('h');
   3e386:	88 e6       	ldi	r24, 0x68	; 104
   3e388:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar('_');
   3e38c:	8f e5       	ldi	r24, 0x5F	; 95
   3e38e:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar('B');
   3e392:	82 e4       	ldi	r24, 0x42	; 66
   3e394:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar('B');
   3e398:	82 e4       	ldi	r24, 0x42	; 66
   3e39a:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>

	sendchar(0x0d);
   3e39e:	8d e0       	ldi	r24, 0x0D	; 13
   3e3a0:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
	sendchar(0x0a);
   3e3a4:	8a e0       	ldi	r24, 0x0A	; 10
   3e3a6:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>

	delay_ms(100);
   3e3aa:	84 e6       	ldi	r24, 0x64	; 100
   3e3ac:	90 e0       	ldi	r25, 0x00	; 0
   3e3ae:	0f 94 b0 f0 	call	0x3e160	; 0x3e160 <delay_ms>
	fDataAddr = 8192;
	fCsumAddr = 4352;
	
//************************************************************************	
//* Init ExFlash
	FLASH_UntilReady();
   3e3b2:	0f 94 f9 f0 	call	0x3e1f2	; 0x3e1f2 <FLASH_UntilReady>
	FLASH_ResetEnable();
   3e3b6:	0f 94 07 f1 	call	0x3e20e	; 0x3e20e <FLASH_ResetEnable>
	FLASH_Reset();
   3e3ba:	0f 94 0e f1 	call	0x3e21c	; 0x3e21c <FLASH_Reset>
	
	uint32_t temp=0;
	SPI_PORT  &=  ~(1<<SPI_CS);			// low
   3e3be:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x9F);
   3e3c0:	8f e9       	ldi	r24, 0x9F	; 159
   3e3c2:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	temp = (uint32_t)SPI_Transfer(0) << 16;
   3e3c6:	80 e0       	ldi	r24, 0x00	; 0
   3e3c8:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
   3e3cc:	c8 2e       	mov	r12, r24
   3e3ce:	d1 2c       	mov	r13, r1
   3e3d0:	e1 2c       	mov	r14, r1
   3e3d2:	f1 2c       	mov	r15, r1
   3e3d4:	76 01       	movw	r14, r12
   3e3d6:	dd 24       	eor	r13, r13
   3e3d8:	cc 24       	eor	r12, r12
	temp |= (uint32_t)SPI_Transfer(0) << 8;
   3e3da:	80 e0       	ldi	r24, 0x00	; 0
   3e3dc:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
   3e3e0:	d8 2a       	or	r13, r24
	temp |= (uint32_t)SPI_Transfer(0);
   3e3e2:	80 e0       	ldi	r24, 0x00	; 0
   3e3e4:	0f 94 a9 f0 	call	0x3e152	; 0x3e152 <SPI_Transfer>
	SPI_PORT |=  (1<<SPI_CS);     		// high
   3e3e8:	28 9a       	sbi	0x05, 0	; 5

	if(temp == EXMEM_JEDEC)
   3e3ea:	c8 2a       	or	r12, r24
   3e3ec:	87 e1       	ldi	r24, 0x17	; 23
   3e3ee:	c8 16       	cp	r12, r24
   3e3f0:	80 e4       	ldi	r24, 0x40	; 64
   3e3f2:	d8 06       	cpc	r13, r24
   3e3f4:	8f ee       	ldi	r24, 0xEF	; 239
   3e3f6:	e8 06       	cpc	r14, r24
   3e3f8:	f1 04       	cpc	r15, r1
   3e3fa:	09 f0       	breq	.+2      	; 0x3e3fe <main+0xe0>
   3e3fc:	40 c0       	rjmp	.+128    	; 0x3e47e <main+0x160>
	{
		fBootStat = FLASH_ReadWord(4096);
   3e3fe:	60 e0       	ldi	r22, 0x00	; 0
   3e400:	70 e1       	ldi	r23, 0x10	; 16
   3e402:	80 e0       	ldi	r24, 0x00	; 0
   3e404:	90 e0       	ldi	r25, 0x00	; 0
   3e406:	0f 94 1c f1 	call	0x3e238	; 0x3e238 <FLASH_ReadWord>
   3e40a:	7c 01       	movw	r14, r24
			printByte(fBootStat>>8);
   3e40c:	8f 2d       	mov	r24, r15
   3e40e:	0f 94 c5 f0 	call	0x3e18a	; 0x3e18a <printByte>
			printByte(fBootStat&0xff);
   3e412:	8e 2d       	mov	r24, r14
   3e414:	0f 94 c5 f0 	call	0x3e18a	; 0x3e18a <printByte>
			sendchar(0x0d);		sendchar(0x0a);
   3e418:	8d e0       	ldi	r24, 0x0D	; 13
   3e41a:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
   3e41e:	8a e0       	ldi	r24, 0x0A	; 10
   3e420:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
		if(fBootStat == 0x2323)
   3e424:	83 e2       	ldi	r24, 0x23	; 35
   3e426:	e8 16       	cp	r14, r24
   3e428:	f8 06       	cpc	r15, r24
   3e42a:	49 f5       	brne	.+82     	; 0x3e47e <main+0x160>
		{
			sendchar('S');		sendchar(0x0d);		sendchar(0x0a);
   3e42c:	83 e5       	ldi	r24, 0x53	; 83
   3e42e:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
   3e432:	8d e0       	ldi	r24, 0x0D	; 13
   3e434:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
   3e438:	8a e0       	ldi	r24, 0x0A	; 10
   3e43a:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
			fDataLen = FLASH_ReadWord(4098);
   3e43e:	62 e0       	ldi	r22, 0x02	; 2
   3e440:	70 e1       	ldi	r23, 0x10	; 16
   3e442:	80 e0       	ldi	r24, 0x00	; 0
   3e444:	90 e0       	ldi	r25, 0x00	; 0
   3e446:	0f 94 1c f1 	call	0x3e238	; 0x3e238 <FLASH_ReadWord>
   3e44a:	7c 01       	movw	r14, r24
				printByte(fDataLen>>8);
   3e44c:	8f 2d       	mov	r24, r15
   3e44e:	0f 94 c5 f0 	call	0x3e18a	; 0x3e18a <printByte>
				printByte(fDataLen&0xff);
   3e452:	8e 2d       	mov	r24, r14
   3e454:	0f 94 c5 f0 	call	0x3e18a	; 0x3e18a <printByte>
				sendchar(0x0d);		sendchar(0x0a);
   3e458:	8d e0       	ldi	r24, 0x0D	; 13
   3e45a:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
   3e45e:	8a e0       	ldi	r24, 0x0A	; 10
   3e460:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
			if(fDataLen == 0x0B)
   3e464:	8b e0       	ldi	r24, 0x0B	; 11
   3e466:	e8 16       	cp	r14, r24
   3e468:	f1 04       	cpc	r15, r1
   3e46a:	49 f4       	brne	.+18     	; 0x3e47e <main+0x160>
			{
				sendchar('L');		sendchar(0x0d);		sendchar(0x0a);
   3e46c:	8c e4       	ldi	r24, 0x4C	; 76
   3e46e:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
   3e472:	8d e0       	ldi	r24, 0x0D	; 13
   3e474:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
   3e478:	8a e0       	ldi	r24, 0x0A	; 10
   3e47a:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
			FLASH_WriteByte(513, 0x4B);
*/
		}
	}
	
	tiny_delay();
   3e47e:	0f 94 bf f0 	call	0x3e17e	; 0x3e17e <tiny_delay>
	
	//boot_rww_enable();				// enable application section

	// leaving bootloader  # bye bye # sayonara #
	asm volatile(
   3e482:	ee 27       	eor	r30, r30
   3e484:	ff 27       	eor	r31, r31
   3e486:	09 94       	ijmp
					"ijmp			\n\t"
				);
	
    for(;;)
    {
		sendchar('V');
   3e488:	86 e5       	ldi	r24, 0x56	; 86
   3e48a:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
		sendchar(0x0d);
   3e48e:	8d e0       	ldi	r24, 0x0D	; 13
   3e490:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
		sendchar(0x0a);
   3e494:	8a e0       	ldi	r24, 0x0A	; 10
   3e496:	0f 94 9d f0 	call	0x3e13a	; 0x3e13a <sendchar>
		delay_ms(200);
   3e49a:	88 ec       	ldi	r24, 0xC8	; 200
   3e49c:	90 e0       	ldi	r25, 0x00	; 0
   3e49e:	0f 94 b0 f0 	call	0x3e160	; 0x3e160 <delay_ms>
   3e4a2:	f2 cf       	rjmp	.-28     	; 0x3e488 <main+0x16a>

0003e4a4 <_exit>:
   3e4a4:	f8 94       	cli

0003e4a6 <__stop_program>:
   3e4a6:	ff cf       	rjmp	.-2      	; 0x3e4a6 <__stop_program>
