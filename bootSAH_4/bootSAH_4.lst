   1               		.file	"bootSAH_4.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB15:
  14               		.file 1 "bootSAH_4.c"
   1:bootSAH_4.c   **** /*
   2:bootSAH_4.c   ****  * bootSAH_4.c
   3:bootSAH_4.c   ****  *
   4:bootSAH_4.c   ****  * Created: 19/09/09 10:07:13 PM
   5:bootSAH_4.c   ****  * Author : supun
   6:bootSAH_4.c   ****  */ 
   7:bootSAH_4.c   **** 
   8:bootSAH_4.c   **** #include	<inttypes.h>
   9:bootSAH_4.c   **** #include	<avr/io.h>
  10:bootSAH_4.c   **** #include	<avr/interrupt.h>
  11:bootSAH_4.c   **** #include	<avr/boot.h>
  12:bootSAH_4.c   **** #include	<avr/pgmspace.h>
  13:bootSAH_4.c   **** #include	<util/delay.h>
  14:bootSAH_4.c   **** #include	<avr/eeprom.h>
  15:bootSAH_4.c   **** #include	<avr/common.h>
  16:bootSAH_4.c   **** #include	<stdlib.h>
  17:bootSAH_4.c   **** 
  18:bootSAH_4.c   **** // #ifdef __AVR_ATmega2560__
  19:bootSAH_4.c   **** 	// #define PROGLED_PORT	PORTB
  20:bootSAH_4.c   **** 	// #define PROGLED_DDR		DDRB
  21:bootSAH_4.c   **** 	// #define PROGLED_PIN		PINB7
  22:bootSAH_4.c   **** // #endif
  23:bootSAH_4.c   **** 
  24:bootSAH_4.c   **** #ifdef __AVR_ATmega2560__
  25:bootSAH_4.c   **** 	#define SPI_PORT	PORTB
  26:bootSAH_4.c   **** 	#define	SPI_DDR		DDRB
  27:bootSAH_4.c   **** 	#define	SPI_MISO	PB3
  28:bootSAH_4.c   **** 	#define	SPI_MOSI	PB2
  29:bootSAH_4.c   **** 	#define	SPI_SCK		PB1
  30:bootSAH_4.c   **** 	#define SPI_CS		PB0
  31:bootSAH_4.c   **** #endif
  32:bootSAH_4.c   **** 
  33:bootSAH_4.c   **** #define EXMEM_JEDEC		0xEF4017
  34:bootSAH_4.c   **** #define EXMEM_SECT_SIZE	4096		// bytes
  35:bootSAH_4.c   **** #define EXMEM_PAGE_SIZE 256			// bytes
  36:bootSAH_4.c   **** 
  37:bootSAH_4.c   **** #define BOOT_EROR_ADDR  256
  38:bootSAH_4.c   **** #define BOOT_STAT_ADDR  4096    // byte addr
  39:bootSAH_4.c   **** #define BOOT_CSUM_ADDR  4352    // byte addr
  40:bootSAH_4.c   **** #define BOOT_DATA_ADDR  8192    // byte addr
  41:bootSAH_4.c   **** 
  42:bootSAH_4.c   **** #define	_DEBUG_SERIAL_
  43:bootSAH_4.c   **** 
  44:bootSAH_4.c   **** #ifndef BAUDRATE
  45:bootSAH_4.c   **** 	#define BAUDRATE 115200
  46:bootSAH_4.c   **** #endif
  47:bootSAH_4.c   **** 
  48:bootSAH_4.c   **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
  49:bootSAH_4.c   **** 	#if defined (__AVR_ATmega32__)
  50:bootSAH_4.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
  51:bootSAH_4.c   **** 	#else
  52:bootSAH_4.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
  53:bootSAH_4.c   **** 	#endif
  54:bootSAH_4.c   **** #endif
  55:bootSAH_4.c   **** 
  56:bootSAH_4.c   **** /* 
  57:bootSAH_4.c   ****  * ATMega with two USART, use UART0 
  58:bootSAH_4.c   ****  * configured for atmega2560 
  59:bootSAH_4.c   ****  */
  60:bootSAH_4.c   **** #define	UART_BAUD_RATE_LOW			UBRR0L
  61:bootSAH_4.c   **** #define	UART_STATUS_REG				UCSR0A
  62:bootSAH_4.c   **** #define	UART_CONTROL_REG			UCSR0B
  63:bootSAH_4.c   **** #define	UART_ENABLE_TRANSMITTER		TXEN0
  64:bootSAH_4.c   **** #define	UART_ENABLE_RECEIVER		RXEN0
  65:bootSAH_4.c   **** #define	UART_TRANSMIT_COMPLETE		TXC0
  66:bootSAH_4.c   **** #define	UART_RECEIVE_COMPLETE		RXC0
  67:bootSAH_4.c   **** #define	UART_DATA_REG				UDR0
  68:bootSAH_4.c   **** #define	UART_DOUBLE_SPEED			U2X0
  69:bootSAH_4.c   **** 
  70:bootSAH_4.c   **** /*
  71:bootSAH_4.c   ****  * Macro to calculate UBBR from XTAL and baudrate
  72:bootSAH_4.c   ****  */
  73:bootSAH_4.c   **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
  74:bootSAH_4.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
  75:bootSAH_4.c   **** #elif defined(__AVR_ATmega32__)
  76:bootSAH_4.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
  77:bootSAH_4.c   **** #elif UART_BAUDRATE_DOUBLE_SPEED
  78:bootSAH_4.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
  79:bootSAH_4.c   **** #else
  80:bootSAH_4.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
  81:bootSAH_4.c   **** #endif
  82:bootSAH_4.c   **** 
  83:bootSAH_4.c   **** 
  84:bootSAH_4.c   **** 
  85:bootSAH_4.c   **** /*
  86:bootSAH_4.c   ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
  87:bootSAH_4.c   ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
  88:bootSAH_4.c   ****  */
  89:bootSAH_4.c   **** //#define BOOTSIZE 1024
  90:bootSAH_4.c   **** #if FLASHEND > 0x0F000
  91:bootSAH_4.c   **** 	#define BOOTSIZE 8192
  92:bootSAH_4.c   **** #else
  93:bootSAH_4.c   **** 	#define BOOTSIZE 2048
  94:bootSAH_4.c   **** #endif
  95:bootSAH_4.c   **** 
  96:bootSAH_4.c   **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
  97:bootSAH_4.c   **** 
  98:bootSAH_4.c   **** /*
  99:bootSAH_4.c   ****  * use 16bit address variable for ATmegas with <= 64K flash
 100:bootSAH_4.c   ****  */
 101:bootSAH_4.c   **** #if defined(RAMPZ)
 102:bootSAH_4.c   **** 	typedef uint32_t address_t;
 103:bootSAH_4.c   **** #else
 104:bootSAH_4.c   **** 	typedef uint16_t address_t;
 105:bootSAH_4.c   **** #endif
 106:bootSAH_4.c   **** 
 107:bootSAH_4.c   **** /*
 108:bootSAH_4.c   ****  * function prototypes
 109:bootSAH_4.c   ****  */
 110:bootSAH_4.c   **** static void sendchar(char c);
 111:bootSAH_4.c   **** void printByte(uint8_t numData);
 112:bootSAH_4.c   **** static int	Serial_Available(void);
 113:bootSAH_4.c   **** static unsigned char recchar(void);
 114:bootSAH_4.c   **** void delay_ms(unsigned int timedelay);
 115:bootSAH_4.c   **** void tiny_delay(void);		
 116:bootSAH_4.c   **** static uint8_t SPI_Transfer(uint8_t spidata);
 117:bootSAH_4.c   **** void FLASH_UntilReady(void);
 118:bootSAH_4.c   **** void FLASH_ResetEnable(void);
 119:bootSAH_4.c   **** void FLASH_Reset(void);
 120:bootSAH_4.c   **** void FLASH_WriteEnable(void);
 121:bootSAH_4.c   **** uint16_t FLASH_ReadWord(uint32_t faddr);
 122:bootSAH_4.c   **** void FLASH_EraseSector(uint32_t faddr);
 123:bootSAH_4.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata);
 124:bootSAH_4.c   **** 
 125:bootSAH_4.c   **** 
 126:bootSAH_4.c   **** 
 127:bootSAH_4.c   **** /*
 128:bootSAH_4.c   ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 129:bootSAH_4.c   ****  * to reduce the code size, we need to provide our own initialization
 130:bootSAH_4.c   ****  */
 131:bootSAH_4.c   **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 132:bootSAH_4.c   **** #include <avr/sfr_defs.h>
 133:bootSAH_4.c   **** 
 134:bootSAH_4.c   **** //*	for watch dog timer startup
 135:bootSAH_4.c   **** void (*app_start)(void) = 0x0000;
 136:bootSAH_4.c   **** 
 137:bootSAH_4.c   **** int main(void)
 138:bootSAH_4.c   **** {
 139:bootSAH_4.c   **** 	address_t		address			=	0;
 140:bootSAH_4.c   **** 	uint32_t fDataAddr = 0;
 141:bootSAH_4.c   **** 	uint32_t fCsumAddr = 0;
 142:bootSAH_4.c   **** 	uint8_t  fRdTries  = 0;
 143:bootSAH_4.c   **** 	uint16_t fii, fjj;
 144:bootSAH_4.c   **** 	uint16_t fBootStat = 0;
 145:bootSAH_4.c   **** 	uint16_t fDataLen  = 0;
 146:bootSAH_4.c   **** 	uint16_t fChSumCal = 0;
 147:bootSAH_4.c   **** 	uint16_t fChSumRev = 0;
 148:bootSAH_4.c   **** 	uint32_t bootPageAddr = 0;
 149:bootSAH_4.c   **** 	unsigned char	msgBuffer[285];
 150:bootSAH_4.c   **** 			
 151:bootSAH_4.c   **** 	//unsigned long	boot_timeout;
 152:bootSAH_4.c   **** 	//unsigned long	boot_timer;
 153:bootSAH_4.c   **** 	//unsigned int	boot_state;
 154:bootSAH_4.c   **** 
 155:bootSAH_4.c   **** //************************************************************************
 156:bootSAH_4.c   **** 	
 157:bootSAH_4.c   **** 	//*	some chips dont set the stack properly
 158:bootSAH_4.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 159:bootSAH_4.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 160:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 161:bootSAH_4.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 162:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 163:bootSAH_4.c   **** 	
 164:bootSAH_4.c   **** //************************************************************************
 165:bootSAH_4.c   **** 
 166:bootSAH_4.c   **** //*	handle the watch dog timer
 167:bootSAH_4.c   **** 	uint8_t	mcuStatusReg;
 168:bootSAH_4.c   **** 	mcuStatusReg	=	MCUSR;
 169:bootSAH_4.c   **** 
 170:bootSAH_4.c   **** 	__asm__ __volatile__ ("cli");
 171:bootSAH_4.c   **** 	__asm__ __volatile__ ("wdr");
 172:bootSAH_4.c   **** 	//MCUSR	=	0;
 173:bootSAH_4.c   **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 174:bootSAH_4.c   **** 	WDTCSR	=	0;
 175:bootSAH_4.c   **** 	__asm__ __volatile__ ("sei");
 176:bootSAH_4.c   **** 	// check if WDT generated the reset, if so, go straight to app
 177:bootSAH_4.c   **** 	if (mcuStatusReg & _BV(WDRF))
 178:bootSAH_4.c   **** 	{
 179:bootSAH_4.c   **** 		app_start();
 180:bootSAH_4.c   **** 	}
 181:bootSAH_4.c   **** 	
 182:bootSAH_4.c   **** //************************************************************************
 183:bootSAH_4.c   **** 
 184:bootSAH_4.c   **** //* Init UART
 185:bootSAH_4.c   **** //*set baudrate and enable USART receiver and transmiter without interrupts
 186:bootSAH_4.c   **** 
 187:bootSAH_4.c   **** #if UART_BAUDRATE_DOUBLE_SPEED
 188:bootSAH_4.c   **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 189:bootSAH_4.c   **** #endif
 190:bootSAH_4.c   **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 191:bootSAH_4.c   **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 192:bootSAH_4.c   **** 
 193:bootSAH_4.c   **** 	asm volatile ("nop");			// wait until port has changed
 194:bootSAH_4.c   **** 
 195:bootSAH_4.c   **** //************************************************************************
 196:bootSAH_4.c   **** 
 197:bootSAH_4.c   **** //* Init SPI
 198:bootSAH_4.c   **** 	SPI_DDR = (	(0<<SPI_MISO)|
 199:bootSAH_4.c   **** 				(1<<SPI_MOSI)|
 200:bootSAH_4.c   **** 				(1<<SPI_SCK) |
 201:bootSAH_4.c   **** 				(1<<SPI_CS)
 202:bootSAH_4.c   **** 			  );
 203:bootSAH_4.c   **** 
 204:bootSAH_4.c   **** 	SPCR = (	(1<<SPE) |              // SPI Enable
 205:bootSAH_4.c   **** 				(0<<SPIE)|              // SPI Interupt Enable
 206:bootSAH_4.c   **** 				(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
 207:bootSAH_4.c   **** 				(1<<MSTR)|              // Master/Slave select
 208:bootSAH_4.c   **** 				(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
 209:bootSAH_4.c   **** 				(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
 210:bootSAH_4.c   **** 				(0<<CPHA)               // Clock Phase (0:leading / 1:trailing edge sampling)
 211:bootSAH_4.c   **** 			);
 212:bootSAH_4.c   **** 			
 213:bootSAH_4.c   **** 	SPI_PORT |=  (1<<SPI_CS); 			// pull high
 214:bootSAH_4.c   **** 	
 215:bootSAH_4.c   **** 	asm volatile ("nop");				// wait until port has changed
 216:bootSAH_4.c   **** 	
 217:bootSAH_4.c   **** //************************************************************************
 218:bootSAH_4.c   **** 	
 219:bootSAH_4.c   **** #ifdef _DEBUG_SERIAL_
 220:bootSAH_4.c   **** 
 221:bootSAH_4.c   **** 	sendchar('u');
 222:bootSAH_4.c   **** 	sendchar('t');
 223:bootSAH_4.c   **** 	sendchar('e');
 224:bootSAH_4.c   **** 	sendchar('c');
 225:bootSAH_4.c   **** 	sendchar('h');
 226:bootSAH_4.c   **** 	sendchar('_');
 227:bootSAH_4.c   **** 	sendchar('B');
 228:bootSAH_4.c   **** 	sendchar('B');
 229:bootSAH_4.c   **** 
 230:bootSAH_4.c   **** 	sendchar(0x0d);
 231:bootSAH_4.c   **** 	sendchar(0x0a);
 232:bootSAH_4.c   **** 
 233:bootSAH_4.c   **** 	delay_ms(100);
 234:bootSAH_4.c   **** #endif
 235:bootSAH_4.c   **** 
 236:bootSAH_4.c   **** 	//boot_timer	 =	0;
 237:bootSAH_4.c   **** 	//boot_state	 =	0;
 238:bootSAH_4.c   **** 	//boot_timeout =	3500000;		// 7 seconds , approx 2us per step when optimize "s"
 239:bootSAH_4.c   **** 	
 240:bootSAH_4.c   **** 	fDataAddr = 8192;
 241:bootSAH_4.c   **** 	fCsumAddr = 4352;
 242:bootSAH_4.c   **** 	
 243:bootSAH_4.c   **** //************************************************************************	
 244:bootSAH_4.c   **** //* Init ExFlash
 245:bootSAH_4.c   **** 	FLASH_UntilReady();
 246:bootSAH_4.c   **** 	FLASH_ResetEnable();
 247:bootSAH_4.c   **** 	FLASH_Reset();
 248:bootSAH_4.c   **** 	
 249:bootSAH_4.c   **** 	uint32_t temp=0;
 250:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);			// low
 251:bootSAH_4.c   **** 	SPI_Transfer(0x9F);
 252:bootSAH_4.c   **** 	temp = (uint32_t)SPI_Transfer(0) << 16;
 253:bootSAH_4.c   **** 	temp |= (uint32_t)SPI_Transfer(0) << 8;
 254:bootSAH_4.c   **** 	temp |= (uint32_t)SPI_Transfer(0);
 255:bootSAH_4.c   **** 	SPI_PORT |=  (1<<SPI_CS);     		// high
 256:bootSAH_4.c   **** 
 257:bootSAH_4.c   **** 	if(temp == EXMEM_JEDEC)
 258:bootSAH_4.c   **** 	{
 259:bootSAH_4.c   **** 		fBootStat = FLASH_ReadWord(4096);
 260:bootSAH_4.c   **** 			printByte(fBootStat>>8);
 261:bootSAH_4.c   **** 			printByte(fBootStat&0xff);
 262:bootSAH_4.c   **** 			sendchar(0x0d);		sendchar(0x0a);
 263:bootSAH_4.c   **** 		if(fBootStat == 0x2323)
 264:bootSAH_4.c   **** 		{
 265:bootSAH_4.c   **** 			sendchar('S');		sendchar(0x0d);		sendchar(0x0a);
 266:bootSAH_4.c   **** 			fDataLen = FLASH_ReadWord(4098);
 267:bootSAH_4.c   **** 				printByte(fDataLen>>8);
 268:bootSAH_4.c   **** 				printByte(fDataLen&0xff);
 269:bootSAH_4.c   **** 				sendchar(0x0d);		sendchar(0x0a);
 270:bootSAH_4.c   **** 			if(fDataLen == 0x0B)
 271:bootSAH_4.c   **** 			{
 272:bootSAH_4.c   **** 				sendchar('L');		sendchar(0x0d);		sendchar(0x0a);
 273:bootSAH_4.c   **** 			}
 274:bootSAH_4.c   **** /*			
 275:bootSAH_4.c   **** 			for(fjj=0; fjj<fDataLen; fjj++)
 276:bootSAH_4.c   **** 			{
 277:bootSAH_4.c   **** 				fRdTries  = 0;
 278:bootSAH_4.c   **** 				fChSumCal = 0;
 279:bootSAH_4.c   **** 				SPI_PORT  &=  ~(1<<SPI_CS);
 280:bootSAH_4.c   **** 				SPI_Transfer(0x03);
 281:bootSAH_4.c   **** 				SPI_Transfer((fDataAddr >> 16) & 0xff);
 282:bootSAH_4.c   **** 				SPI_Transfer((fDataAddr >> 8) & 0xff);
 283:bootSAH_4.c   **** 				SPI_Transfer(fDataAddr & 0xff);
 284:bootSAH_4.c   **** 				for(fii=0; fii<256; fii++)
 285:bootSAH_4.c   **** 				{
 286:bootSAH_4.c   **** 					msgBuffer[fii] = SPI_Transfer(0);
 287:bootSAH_4.c   **** 					fChSumCal += msgBuffer[fii];
 288:bootSAH_4.c   **** 				}
 289:bootSAH_4.c   **** 				SPI_PORT  |=   (1<<SPI_CS);
 290:bootSAH_4.c   **** 				tiny_delay();
 291:bootSAH_4.c   **** 				
 292:bootSAH_4.c   **** 				fChSumRev = FLASH_ReadWord(fCsumAddr);
 293:bootSAH_4.c   **** 				
 294:bootSAH_4.c   **** 				if(fChSumRev == fChSumCal)
 295:bootSAH_4.c   **** 				{
 296:bootSAH_4.c   **** 					/////////////////checksum Matched
 297:bootSAH_4.c   **** 					sendchar('C');		sendchar(0x0d);		sendchar(0x0a);
 298:bootSAH_4.c   **** 					
 299:bootSAH_4.c   **** 					uint8_t  fLSByte, fMSByte;
 300:bootSAH_4.c   **** 					uint16_t fData;
 301:bootSAH_4.c   **** 					uint16_t fSize;
 302:bootSAH_4.c   **** 					
 303:bootSAH_4.c   **** 					fSize = 256;
 304:bootSAH_4.c   **** 					address = bootPageAddr;
 305:bootSAH_4.c   **** 					
 306:bootSAH_4.c   **** 					if(bootPageAddr < APP_END)				// erase only main section (bootloader protection)
 307:bootSAH_4.c   **** 					{
 308:bootSAH_4.c   **** 						
 309:bootSAH_4.c   **** 						sendchar('B');		sendchar(0x0d);		sendchar(0x0a);
 310:bootSAH_4.c   **** 						asm volatile ("nop");
 311:bootSAH_4.c   **** 						
 312:bootSAH_4.c   **** 						//boot_page_erase(bootPageAddr);		// Perform page erase
 313:bootSAH_4.c   **** 						//boot_spm_busy_wait();				// Wait until the memory is erased
 314:bootSAH_4.c   **** 
 315:bootSAH_4.c   **** 						do
 316:bootSAH_4.c   **** 						{
 317:bootSAH_4.c   **** 							fLSByte = msgBuffer[fii];
 318:bootSAH_4.c   **** 							fMSByte = msgBuffer[fii+1];
 319:bootSAH_4.c   **** 							fData   = ((uint16_t)fMSByte << 8) | fLSByte;
 320:bootSAH_4.c   **** 							
 321:bootSAH_4.c   **** 								printByte(fData>>8);
 322:bootSAH_4.c   **** 								printByte(fData&0xff);
 323:bootSAH_4.c   **** 								sendchar(',');
 324:bootSAH_4.c   **** 							
 325:bootSAH_4.c   **** 							//boot_page_fill(address, fData);		// fill boot page
 326:bootSAH_4.c   **** 							address += 2;						// inc boot page address
 327:bootSAH_4.c   **** 							
 328:bootSAH_4.c   **** 							fSize	-=	2;
 329:bootSAH_4.c   **** 						} while(fSize);
 330:bootSAH_4.c   **** 
 331:bootSAH_4.c   **** 						
 332:bootSAH_4.c   **** 						for(fii=0; fii<256; fii+=2)
 333:bootSAH_4.c   **** 						{
 334:bootSAH_4.c   **** 							fLSByte = msgBuffer[fii];
 335:bootSAH_4.c   **** 							fMSByte = msgBuffer[fii+1];
 336:bootSAH_4.c   **** 							fData   = ((uint16_t)fMSByte << 8) | fLSByte;
 337:bootSAH_4.c   **** 							
 338:bootSAH_4.c   **** 								printByte(fii>>8);
 339:bootSAH_4.c   **** 								printByte(fii&0xff);
 340:bootSAH_4.c   **** 								sendchar(',');
 341:bootSAH_4.c   **** 							
 342:bootSAH_4.c   **** 							//boot_page_fill(address, fData);		// fill boot page
 343:bootSAH_4.c   **** 							address += 2;						// inc boot page address
 344:bootSAH_4.c   **** 							
 345:bootSAH_4.c   **** 							
 346:bootSAH_4.c   **** 						}
 347:bootSAH_4.c   **** 						sendchar(0x0d);		sendchar(0x0a);
 348:bootSAH_4.c   **** 						
 349:bootSAH_4.c   **** 						//boot_page_write(bootPageAddr);			// write boot page
 350:bootSAH_4.c   **** 						//boot_spm_busy_wait();
 351:bootSAH_4.c   **** 						
 352:bootSAH_4.c   **** 						bootPageAddr += 256;			// SPM_PAGESIZE=256  point to next page to be erase
 353:bootSAH_4.c   **** 
 354:bootSAH_4.c   **** 					}
 355:bootSAH_4.c   **** 					else
 356:bootSAH_4.c   **** 					{
 357:bootSAH_4.c   **** 						// write something on flash status
 358:bootSAH_4.c   **** 						sendchar('A');		sendchar(0x0d);		sendchar(0x0a);
 359:bootSAH_4.c   **** 						break;
 360:bootSAH_4.c   **** 					}					
 361:bootSAH_4.c   **** 					
 362:bootSAH_4.c   **** 					fDataAddr += 256;					//EXMEM_PAGE_SIZE;
 363:bootSAH_4.c   **** 					fCsumAddr += 2;
 364:bootSAH_4.c   **** 					tiny_delay();
 365:bootSAH_4.c   **** 				}
 366:bootSAH_4.c   **** 				else
 367:bootSAH_4.c   **** 				{
 368:bootSAH_4.c   **** 					///////////////////checksum Wrong
 369:bootSAH_4.c   **** 					fRdTries++;
 370:bootSAH_4.c   **** 					if(fRdTries>3)
 371:bootSAH_4.c   **** 					{
 372:bootSAH_4.c   **** 						////////////fail to read page
 373:bootSAH_4.c   **** 						sendchar('R');		sendchar(0x0d);		sendchar(0x0a);
 374:bootSAH_4.c   **** 						FLASH_WriteByte(BOOT_EROR_ADDR, (fjj >> 8));
 375:bootSAH_4.c   **** 						FLASH_WriteByte(BOOT_EROR_ADDR, (fjj & 0x00ff));
 376:bootSAH_4.c   **** 						break;
 377:bootSAH_4.c   **** 					}
 378:bootSAH_4.c   **** 				}
 379:bootSAH_4.c   **** 			}
 380:bootSAH_4.c   **** 			FLASH_EraseSector(4096);
 381:bootSAH_4.c   **** 			tiny_delay();
 382:bootSAH_4.c   **** 			FLASH_WriteByte(512, 0x4F);
 383:bootSAH_4.c   **** 			FLASH_WriteByte(513, 0x4B);
 384:bootSAH_4.c   **** */
 385:bootSAH_4.c   **** 		}
 386:bootSAH_4.c   **** 	}
 387:bootSAH_4.c   **** 	
 388:bootSAH_4.c   **** 	tiny_delay();
 389:bootSAH_4.c   **** 	
 390:bootSAH_4.c   **** 	//boot_rww_enable();				// enable application section
 391:bootSAH_4.c   **** 
 392:bootSAH_4.c   **** 	// leaving bootloader  # bye bye # sayonara #
 393:bootSAH_4.c   **** 	asm volatile(
 394:bootSAH_4.c   **** 					"clr	r30		\n\t"
 395:bootSAH_4.c   **** 					"clr	r31		\n\t"
 396:bootSAH_4.c   **** 					"ijmp			\n\t"
 397:bootSAH_4.c   **** 				);
 398:bootSAH_4.c   **** 	
 399:bootSAH_4.c   ****     for(;;)
 400:bootSAH_4.c   ****     {
 401:bootSAH_4.c   **** 		sendchar('V');
 402:bootSAH_4.c   **** 		sendchar(0x0d);
 403:bootSAH_4.c   **** 		sendchar(0x0a);
 404:bootSAH_4.c   **** 		delay_ms(200);
 405:bootSAH_4.c   ****     }
 406:bootSAH_4.c   **** }
 407:bootSAH_4.c   **** 
 408:bootSAH_4.c   **** //*****************************************************************************
 409:bootSAH_4.c   **** void __jumpMain(void)
 410:bootSAH_4.c   **** {
 411:bootSAH_4.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 412:bootSAH_4.c   **** //*	the first line did not do the job on the ATmega128
 413:bootSAH_4.c   **** 
 414:bootSAH_4.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 415:bootSAH_4.c   **** 
 416:bootSAH_4.c   **** //*	set stack pointer to top of RAM
 417:bootSAH_4.c   **** 
 418:bootSAH_4.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 419:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 420:bootSAH_4.c   **** 
 421:bootSAH_4.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 422:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 423:bootSAH_4.c   **** 
 424:bootSAH_4.c   **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 425:bootSAH_4.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 426:bootSAH_4.c   **** 	asm volatile ( "jmp main");												// jump to main()
 427:bootSAH_4.c   **** }
 428:bootSAH_4.c   **** 
 429:bootSAH_4.c   **** 
 430:bootSAH_4.c   **** //*****************************************************************************
 431:bootSAH_4.c   **** void delay_ms(unsigned int timedelay)
 432:bootSAH_4.c   **** {
 433:bootSAH_4.c   **** 	unsigned int i;
 434:bootSAH_4.c   **** 	for (i=0;i<timedelay;i++)
 435:bootSAH_4.c   **** 	{
 436:bootSAH_4.c   **** 		_delay_ms(0.5);
 437:bootSAH_4.c   **** 	}
 438:bootSAH_4.c   **** }
 439:bootSAH_4.c   **** //** small delay
 440:bootSAH_4.c   **** void tiny_delay()		
 441:bootSAH_4.c   **** {
 442:bootSAH_4.c   **** 	asm volatile(
 443:bootSAH_4.c   **** 					"nop	\n\t"
 444:bootSAH_4.c   **** 					"nop	\n\t"
 445:bootSAH_4.c   **** 					"nop	\n\t"
 446:bootSAH_4.c   **** 					"nop	\n\t"
 447:bootSAH_4.c   **** 					"nop	\n\t"
 448:bootSAH_4.c   **** 				); 
 449:bootSAH_4.c   **** }
 450:bootSAH_4.c   ****    
 451:bootSAH_4.c   **** 
 452:bootSAH_4.c   **** //*****************************************************************************
 453:bootSAH_4.c   **** 
 454:bootSAH_4.c   **** static void sendchar(char c)
 455:bootSAH_4.c   **** {
  15               		.loc 1 455 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 456:bootSAH_4.c   **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 456 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 457:bootSAH_4.c   **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 457 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 458:bootSAH_4.c   **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 458 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE15:
  40               	SPI_Transfer:
  41               	.LFB19:
 459:bootSAH_4.c   **** }
 460:bootSAH_4.c   **** 
 461:bootSAH_4.c   **** void printByte(uint8_t numData)
 462:bootSAH_4.c   **** {
 463:bootSAH_4.c   **** 	char chData;
 464:bootSAH_4.c   **** 	const char hexArr[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
 465:bootSAH_4.c   **** 	chData = hexArr[numData>>4];
 466:bootSAH_4.c   **** 	sendchar(chData);
 467:bootSAH_4.c   **** 	chData = hexArr[numData&0xF];
 468:bootSAH_4.c   **** 	sendchar(chData);
 469:bootSAH_4.c   **** }
 470:bootSAH_4.c   **** 
 471:bootSAH_4.c   **** //************************************************************************
 472:bootSAH_4.c   **** static int	Serial_Available(void)
 473:bootSAH_4.c   **** {
 474:bootSAH_4.c   **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 475:bootSAH_4.c   **** }
 476:bootSAH_4.c   **** 
 477:bootSAH_4.c   **** static unsigned char recchar(void)
 478:bootSAH_4.c   **** {
 479:bootSAH_4.c   **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 480:bootSAH_4.c   **** 	{
 481:bootSAH_4.c   **** 		// wait for data
 482:bootSAH_4.c   **** 	}
 483:bootSAH_4.c   **** 	return UART_DATA_REG;
 484:bootSAH_4.c   **** }
 485:bootSAH_4.c   **** 
 486:bootSAH_4.c   **** static uint8_t SPI_Transfer(uint8_t spidata)
 487:bootSAH_4.c   **** {
  42               		.loc 1 487 0
  43               		.cfi_startproc
  44               	.LVL3:
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
 488:bootSAH_4.c   **** 	SPDR = spidata;
  49               		.loc 1 488 0
  50 0018 8EBD      		out 0x2e,r24
 489:bootSAH_4.c   **** 	asm volatile("nop");			// small delay
  51               		.loc 1 489 0
  52               	/* #APP */
  53               	 ;  489 "bootSAH_4.c" 1
  54 001a 0000      		nop
  55               	 ;  0 "" 2
  56               	/* #NOAPP */
  57               	.L7:
 490:bootSAH_4.c   **** 	while(!(SPSR & (1<<SPIF)));		// Wait for transmission complete
  58               		.loc 1 490 0 discriminator 1
  59 001c 0DB4      		in __tmp_reg__,0x2d
  60 001e 07FE      		sbrs __tmp_reg__,7
  61 0020 00C0      		rjmp .L7
 491:bootSAH_4.c   **** 
 492:bootSAH_4.c   **** 	return SPDR;
  62               		.loc 1 492 0
  63 0022 8EB5      		in r24,0x2e
  64               	.LVL4:
 493:bootSAH_4.c   **** }
  65               		.loc 1 493 0
  66 0024 0895      		ret
  67               		.cfi_endproc
  68               	.LFE19:
  70               		.section	.init9,"ax",@progbits
  71               	.global	__jumpMain
  73               	__jumpMain:
  74               	.LFB12:
 410:bootSAH_4.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  75               		.loc 1 410 0
  76               		.cfi_startproc
  77               	/* prologue: naked */
  78               	/* frame size = 0 */
  79               	/* stack size = 0 */
  80               	.L__stack_usage = 0
 414:bootSAH_4.c   **** 
  81               		.loc 1 414 0
  82               	/* #APP */
  83               	 ;  414 "bootSAH_4.c" 1
  84               		.set __stack, 8703
  85               	 ;  0 "" 2
 418:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  86               		.loc 1 418 0
  87               	 ;  418 "bootSAH_4.c" 1
  88 0000 01E2      		ldi	16, 33
  89               	 ;  0 "" 2
 419:bootSAH_4.c   **** 
  90               		.loc 1 419 0
  91               	 ;  419 "bootSAH_4.c" 1
  92 0002 0EBF      		out 62,16
  93               	 ;  0 "" 2
 421:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  94               		.loc 1 421 0
  95               	 ;  421 "bootSAH_4.c" 1
  96 0004 0FEF      		ldi	16, 255
  97               	 ;  0 "" 2
 422:bootSAH_4.c   **** 
  98               		.loc 1 422 0
  99               	 ;  422 "bootSAH_4.c" 1
 100 0006 0DBF      		out 61,16
 101               	 ;  0 "" 2
 424:bootSAH_4.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 102               		.loc 1 424 0
 103               	 ;  424 "bootSAH_4.c" 1
 104 0008 1124      		clr __zero_reg__
 105               	 ;  0 "" 2
 425:bootSAH_4.c   **** 	asm volatile ( "jmp main");												// jump to main()
 106               		.loc 1 425 0
 107               	 ;  425 "bootSAH_4.c" 1
 108 000a 1FBE      		out 63, __zero_reg__
 109               	 ;  0 "" 2
 426:bootSAH_4.c   **** }
 110               		.loc 1 426 0
 111               	 ;  426 "bootSAH_4.c" 1
 112 000c 0C94 0000 		jmp main
 113               	 ;  0 "" 2
 114               	/* epilogue start */
 427:bootSAH_4.c   **** 
 115               		.loc 1 427 0
 116               	/* #NOAPP */
 117               		.cfi_endproc
 118               	.LFE12:
 120               		.text
 121               	.global	delay_ms
 123               	delay_ms:
 124               	.LFB13:
 432:bootSAH_4.c   **** 	unsigned int i;
 125               		.loc 1 432 0
 126               		.cfi_startproc
 127               	.LVL5:
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
 434:bootSAH_4.c   **** 	{
 132               		.loc 1 434 0
 133 0026 20E0      		ldi r18,0
 134 0028 30E0      		ldi r19,0
 135               	.LVL6:
 136               	.L11:
 434:bootSAH_4.c   **** 	{
 137               		.loc 1 434 0 is_stmt 0 discriminator 1
 138 002a 2817      		cp r18,r24
 139 002c 3907      		cpc r19,r25
 140 002e 01F0      		breq .L13
 141               	.LVL7:
 142               	.LBB4:
 143               	.LBB5:
 144               		.file 2 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ut
   1:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 145               		.loc 2 187 0 is_stmt 1
 146 0030 EFEC      		ldi r30,lo8(1999)
 147 0032 F7E0      		ldi r31,hi8(1999)
 148 0034 3197      	1:	sbiw r30,1
 149 0036 01F4      		brne 1b
 150 0038 00C0      		rjmp .
 151 003a 0000      		nop
 152               	.LVL8:
 153               	.LBE5:
 154               	.LBE4:
 434:bootSAH_4.c   **** 	{
 155               		.loc 1 434 0
 156 003c 2F5F      		subi r18,-1
 157 003e 3F4F      		sbci r19,-1
 158               	.LVL9:
 159 0040 00C0      		rjmp .L11
 160               	.L13:
 161               	/* epilogue start */
 438:bootSAH_4.c   **** //** small delay
 162               		.loc 1 438 0
 163 0042 0895      		ret
 164               		.cfi_endproc
 165               	.LFE13:
 167               	.global	tiny_delay
 169               	tiny_delay:
 170               	.LFB14:
 441:bootSAH_4.c   **** 	asm volatile(
 171               		.loc 1 441 0
 172               		.cfi_startproc
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 0 */
 176               	.L__stack_usage = 0
 442:bootSAH_4.c   **** 					"nop	\n\t"
 177               		.loc 1 442 0
 178               	/* #APP */
 179               	 ;  442 "bootSAH_4.c" 1
 180 0044 0000      		nop	
 181 0046 0000      		nop	
 182 0048 0000      		nop	
 183 004a 0000      		nop	
 184 004c 0000      		nop	
 185               		
 186               	 ;  0 "" 2
 187               	/* #NOAPP */
 188 004e 0895      		ret
 189               		.cfi_endproc
 190               	.LFE14:
 192               		.section	.rodata
 193               	.LC0:
 194 0000 30        		.byte	48
 195 0001 31        		.byte	49
 196 0002 32        		.byte	50
 197 0003 33        		.byte	51
 198 0004 34        		.byte	52
 199 0005 35        		.byte	53
 200 0006 36        		.byte	54
 201 0007 37        		.byte	55
 202 0008 38        		.byte	56
 203 0009 39        		.byte	57
 204 000a 41        		.byte	65
 205 000b 42        		.byte	66
 206 000c 43        		.byte	67
 207 000d 44        		.byte	68
 208 000e 45        		.byte	69
 209 000f 46        		.byte	70
 210               		.text
 211               	.global	printByte
 213               	printByte:
 214               	.LFB16:
 462:bootSAH_4.c   **** 	char chData;
 215               		.loc 1 462 0
 216               		.cfi_startproc
 217               	.LVL10:
 218 0050 1F93      		push r17
 219               	.LCFI0:
 220               		.cfi_def_cfa_offset 4
 221               		.cfi_offset 17, -3
 222 0052 CF93      		push r28
 223               	.LCFI1:
 224               		.cfi_def_cfa_offset 5
 225               		.cfi_offset 28, -4
 226 0054 DF93      		push r29
 227               	.LCFI2:
 228               		.cfi_def_cfa_offset 6
 229               		.cfi_offset 29, -5
 230 0056 CDB7      		in r28,__SP_L__
 231 0058 DEB7      		in r29,__SP_H__
 232               	.LCFI3:
 233               		.cfi_def_cfa_register 28
 234 005a 6097      		sbiw r28,16
 235               	.LCFI4:
 236               		.cfi_def_cfa_offset 22
 237 005c 0FB6      		in __tmp_reg__,__SREG__
 238 005e F894      		cli
 239 0060 DEBF      		out __SP_H__,r29
 240 0062 0FBE      		out __SREG__,__tmp_reg__
 241 0064 CDBF      		out __SP_L__,r28
 242               	/* prologue: function */
 243               	/* frame size = 16 */
 244               	/* stack size = 19 */
 245               	.L__stack_usage = 19
 246 0066 182F      		mov r17,r24
 464:bootSAH_4.c   **** 	chData = hexArr[numData>>4];
 247               		.loc 1 464 0
 248 0068 80E1      		ldi r24,lo8(16)
 249               	.LVL11:
 250 006a E0E0      		ldi r30,lo8(.LC0)
 251 006c F0E0      		ldi r31,hi8(.LC0)
 252 006e DE01      		movw r26,r28
 253 0070 1196      		adiw r26,1
 254               		0:
 255 0072 0190      		ld r0,Z+
 256 0074 0D92      		st X+,r0
 257 0076 8A95      		dec r24
 258 0078 01F4      		brne 0b
 465:bootSAH_4.c   **** 	sendchar(chData);
 259               		.loc 1 465 0
 260 007a 812F      		mov r24,r17
 261 007c 8295      		swap r24
 262 007e 8F70      		andi r24,lo8(15)
 263 0080 E1E0      		ldi r30,lo8(1)
 264 0082 F0E0      		ldi r31,0
 265 0084 EC0F      		add r30,r28
 266 0086 FD1F      		adc r31,r29
 267 0088 E80F      		add r30,r24
 268 008a F11D      		adc r31,__zero_reg__
 466:bootSAH_4.c   **** 	chData = hexArr[numData&0xF];
 269               		.loc 1 466 0
 270 008c 8081      		ld r24,Z
 271 008e 0E94 0000 		call sendchar
 272               	.LVL12:
 467:bootSAH_4.c   **** 	sendchar(chData);
 273               		.loc 1 467 0
 274 0092 1F70      		andi r17,lo8(15)
 275               	.LVL13:
 276 0094 E1E0      		ldi r30,lo8(1)
 277 0096 F0E0      		ldi r31,0
 278 0098 EC0F      		add r30,r28
 279 009a FD1F      		adc r31,r29
 280 009c E10F      		add r30,r17
 281 009e F11D      		adc r31,__zero_reg__
 468:bootSAH_4.c   **** }
 282               		.loc 1 468 0
 283 00a0 8081      		ld r24,Z
 284               	/* epilogue start */
 469:bootSAH_4.c   **** 
 285               		.loc 1 469 0
 286 00a2 6096      		adiw r28,16
 287 00a4 0FB6      		in __tmp_reg__,__SREG__
 288 00a6 F894      		cli
 289 00a8 DEBF      		out __SP_H__,r29
 290 00aa 0FBE      		out __SREG__,__tmp_reg__
 291 00ac CDBF      		out __SP_L__,r28
 292 00ae DF91      		pop r29
 293 00b0 CF91      		pop r28
 294 00b2 1F91      		pop r17
 468:bootSAH_4.c   **** }
 295               		.loc 1 468 0
 296 00b4 0C94 0000 		jmp sendchar
 297               	.LVL14:
 298               		.cfi_endproc
 299               	.LFE16:
 301               	.global	FLASH_UntilReady
 303               	FLASH_UntilReady:
 304               	.LFB20:
 494:bootSAH_4.c   **** 
 495:bootSAH_4.c   **** void FLASH_UntilReady()
 496:bootSAH_4.c   **** {
 305               		.loc 1 496 0
 306               		.cfi_startproc
 307               	/* prologue: function */
 308               	/* frame size = 0 */
 309               	/* stack size = 0 */
 310               	.L__stack_usage = 0
 311               	.LVL15:
 497:bootSAH_4.c   **** 	uint8_t stat=0xff;
 498:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 312               		.loc 1 498 0
 313 00b8 2898      		cbi 0x5,0
 499:bootSAH_4.c   **** 	SPI_Transfer(0x05);
 314               		.loc 1 499 0
 315 00ba 85E0      		ldi r24,lo8(5)
 316 00bc 0E94 0000 		call SPI_Transfer
 317               	.LVL16:
 497:bootSAH_4.c   **** 	uint8_t stat=0xff;
 318               		.loc 1 497 0
 319 00c0 8FEF      		ldi r24,lo8(-1)
 320               	.LVL17:
 321               	.L17:
 500:bootSAH_4.c   **** 	while((stat & 0x01) == 0x01)
 322               		.loc 1 500 0
 323 00c2 80FF      		sbrs r24,0
 324 00c4 00C0      		rjmp .L19
 501:bootSAH_4.c   **** 	{
 502:bootSAH_4.c   **** 		stat = SPI_Transfer(0);
 325               		.loc 1 502 0
 326 00c6 80E0      		ldi r24,0
 327 00c8 0E94 0000 		call SPI_Transfer
 328               	.LVL18:
 329 00cc 00C0      		rjmp .L17
 330               	.LVL19:
 331               	.L19:
 503:bootSAH_4.c   **** 	}
 504:bootSAH_4.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 332               		.loc 1 504 0
 333 00ce 289A      		sbi 0x5,0
 505:bootSAH_4.c   **** 	tiny_delay();
 334               		.loc 1 505 0
 335 00d0 0C94 0000 		jmp tiny_delay
 336               	.LVL20:
 337               		.cfi_endproc
 338               	.LFE20:
 340               	.global	FLASH_ResetEnable
 342               	FLASH_ResetEnable:
 343               	.LFB21:
 506:bootSAH_4.c   **** }
 507:bootSAH_4.c   **** 
 508:bootSAH_4.c   **** void FLASH_ResetEnable()
 509:bootSAH_4.c   **** {
 344               		.loc 1 509 0
 345               		.cfi_startproc
 346               	/* prologue: function */
 347               	/* frame size = 0 */
 348               	/* stack size = 0 */
 349               	.L__stack_usage = 0
 510:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 350               		.loc 1 510 0
 351 00d4 2898      		cbi 0x5,0
 511:bootSAH_4.c   **** 	SPI_Transfer(0x66);
 352               		.loc 1 511 0
 353 00d6 86E6      		ldi r24,lo8(102)
 354 00d8 0E94 0000 		call SPI_Transfer
 355               	.LVL21:
 512:bootSAH_4.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 356               		.loc 1 512 0
 357 00dc 289A      		sbi 0x5,0
 513:bootSAH_4.c   **** 	tiny_delay();
 358               		.loc 1 513 0
 359 00de 0C94 0000 		jmp tiny_delay
 360               	.LVL22:
 361               		.cfi_endproc
 362               	.LFE21:
 364               	.global	FLASH_Reset
 366               	FLASH_Reset:
 367               	.LFB22:
 514:bootSAH_4.c   **** }
 515:bootSAH_4.c   **** 
 516:bootSAH_4.c   **** void FLASH_Reset()
 517:bootSAH_4.c   **** {
 368               		.loc 1 517 0
 369               		.cfi_startproc
 370               	/* prologue: function */
 371               	/* frame size = 0 */
 372               	/* stack size = 0 */
 373               	.L__stack_usage = 0
 518:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 374               		.loc 1 518 0
 375 00e2 2898      		cbi 0x5,0
 519:bootSAH_4.c   **** 	SPI_Transfer(0x99);
 376               		.loc 1 519 0
 377 00e4 89E9      		ldi r24,lo8(-103)
 378 00e6 0E94 0000 		call SPI_Transfer
 379               	.LVL23:
 520:bootSAH_4.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 380               		.loc 1 520 0
 381 00ea 289A      		sbi 0x5,0
 521:bootSAH_4.c   **** 	tiny_delay();
 382               		.loc 1 521 0
 383 00ec 0C94 0000 		jmp tiny_delay
 384               	.LVL24:
 385               		.cfi_endproc
 386               	.LFE22:
 388               	.global	FLASH_WriteEnable
 390               	FLASH_WriteEnable:
 391               	.LFB23:
 522:bootSAH_4.c   **** }
 523:bootSAH_4.c   **** 
 524:bootSAH_4.c   **** void FLASH_WriteEnable()
 525:bootSAH_4.c   **** {
 392               		.loc 1 525 0
 393               		.cfi_startproc
 394               	/* prologue: function */
 395               	/* frame size = 0 */
 396               	/* stack size = 0 */
 397               	.L__stack_usage = 0
 526:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 398               		.loc 1 526 0
 399 00f0 2898      		cbi 0x5,0
 527:bootSAH_4.c   **** 	SPI_Transfer(0x06);
 400               		.loc 1 527 0
 401 00f2 86E0      		ldi r24,lo8(6)
 402 00f4 0E94 0000 		call SPI_Transfer
 403               	.LVL25:
 528:bootSAH_4.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 404               		.loc 1 528 0
 405 00f8 289A      		sbi 0x5,0
 529:bootSAH_4.c   **** 	tiny_delay();
 406               		.loc 1 529 0
 407 00fa 0C94 0000 		jmp tiny_delay
 408               	.LVL26:
 409               		.cfi_endproc
 410               	.LFE23:
 412               	.global	FLASH_ReadWord
 414               	FLASH_ReadWord:
 415               	.LFB24:
 530:bootSAH_4.c   **** }
 531:bootSAH_4.c   **** 
 532:bootSAH_4.c   **** uint16_t FLASH_ReadWord(uint32_t faddr)
 533:bootSAH_4.c   **** {
 416               		.loc 1 533 0
 417               		.cfi_startproc
 418               	.LVL27:
 419 00fe 1F93      		push r17
 420               	.LCFI5:
 421               		.cfi_def_cfa_offset 4
 422               		.cfi_offset 17, -3
 423 0100 CF93      		push r28
 424               	.LCFI6:
 425               		.cfi_def_cfa_offset 5
 426               		.cfi_offset 28, -4
 427 0102 DF93      		push r29
 428               	.LCFI7:
 429               		.cfi_def_cfa_offset 6
 430               		.cfi_offset 29, -5
 431               	/* prologue: function */
 432               	/* frame size = 0 */
 433               	/* stack size = 3 */
 434               	.L__stack_usage = 3
 435 0104 EB01      		movw r28,r22
 436 0106 182F      		mov r17,r24
 437               	.LVL28:
 534:bootSAH_4.c   **** 	uint16_t temp1=0, temp2=0;
 535:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 438               		.loc 1 535 0
 439 0108 2898      		cbi 0x5,0
 536:bootSAH_4.c   **** 	SPI_Transfer(0x03);
 440               		.loc 1 536 0
 441 010a 83E0      		ldi r24,lo8(3)
 442 010c 0E94 0000 		call SPI_Transfer
 443               	.LVL29:
 537:bootSAH_4.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 444               		.loc 1 537 0
 445 0110 812F      		mov r24,r17
 446 0112 0E94 0000 		call SPI_Transfer
 447               	.LVL30:
 538:bootSAH_4.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 448               		.loc 1 538 0
 449 0116 8D2F      		mov r24,r29
 450 0118 0E94 0000 		call SPI_Transfer
 451               	.LVL31:
 539:bootSAH_4.c   **** 	SPI_Transfer(faddr & 0xff);
 452               		.loc 1 539 0
 453 011c 8C2F      		mov r24,r28
 454 011e 0E94 0000 		call SPI_Transfer
 455               	.LVL32:
 540:bootSAH_4.c   **** 	temp1 = SPI_Transfer(0);
 456               		.loc 1 540 0
 457 0122 80E0      		ldi r24,0
 458 0124 0E94 0000 		call SPI_Transfer
 459               	.LVL33:
 460 0128 D82F      		mov r29,r24
 461               	.LVL34:
 541:bootSAH_4.c   **** 	temp2 = SPI_Transfer(0);
 462               		.loc 1 541 0
 463 012a 80E0      		ldi r24,0
 464               	.LVL35:
 465 012c 0E94 0000 		call SPI_Transfer
 466               	.LVL36:
 467 0130 C82F      		mov r28,r24
 468               	.LVL37:
 542:bootSAH_4.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 469               		.loc 1 542 0
 470 0132 289A      		sbi 0x5,0
 543:bootSAH_4.c   **** 	tiny_delay();
 471               		.loc 1 543 0
 472 0134 0E94 0000 		call tiny_delay
 473               	.LVL38:
 544:bootSAH_4.c   **** 							sendchar(temp1 & 0xff);
 474               		.loc 1 544 0
 475 0138 8D2F      		mov r24,r29
 476 013a 0E94 0000 		call sendchar
 477               	.LVL39:
 545:bootSAH_4.c   **** 							sendchar(temp2 & 0xff);
 478               		.loc 1 545 0
 479 013e 8C2F      		mov r24,r28
 480 0140 0E94 0000 		call sendchar
 481               	.LVL40:
 546:bootSAH_4.c   **** 							sendchar(0x0d);
 482               		.loc 1 546 0
 483 0144 8DE0      		ldi r24,lo8(13)
 484 0146 0E94 0000 		call sendchar
 485               	.LVL41:
 547:bootSAH_4.c   **** 							sendchar(0x0a);
 486               		.loc 1 547 0
 487 014a 8AE0      		ldi r24,lo8(10)
 488 014c 0E94 0000 		call sendchar
 489               	.LVL42:
 548:bootSAH_4.c   **** 							
 549:bootSAH_4.c   **** 	return ((temp1 << 8) | (temp2 & 0x00ff));
 490               		.loc 1 549 0
 491 0150 8C2F      		mov r24,r28
 492 0152 90E0      		ldi r25,0
 550:bootSAH_4.c   **** 
 551:bootSAH_4.c   **** }
 493               		.loc 1 551 0
 494 0154 9D2B      		or r25,r29
 495               	/* epilogue start */
 496 0156 DF91      		pop r29
 497               	.LVL43:
 498 0158 CF91      		pop r28
 499               	.LVL44:
 500 015a 1F91      		pop r17
 501 015c 0895      		ret
 502               		.cfi_endproc
 503               	.LFE24:
 505               		.section	.text.startup,"ax",@progbits
 506               	.global	main
 508               	main:
 509               	.LFB11:
 138:bootSAH_4.c   **** 	address_t		address			=	0;
 510               		.loc 1 138 0
 511               		.cfi_startproc
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 0 */
 515               	.L__stack_usage = 0
 516               	.LVL45:
 158:bootSAH_4.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 517               		.loc 1 158 0
 518               	/* #APP */
 519               	 ;  158 "bootSAH_4.c" 1
 520               		.set __stack, 8703
 521               	 ;  0 "" 2
 159:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 522               		.loc 1 159 0
 523               	 ;  159 "bootSAH_4.c" 1
 524 0000 01E2      		ldi	16, 33
 525               	 ;  0 "" 2
 160:bootSAH_4.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 526               		.loc 1 160 0
 527               	 ;  160 "bootSAH_4.c" 1
 528 0002 0EBF      		out 62,16
 529               	 ;  0 "" 2
 161:bootSAH_4.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 530               		.loc 1 161 0
 531               	 ;  161 "bootSAH_4.c" 1
 532 0004 0FEF      		ldi	16, 255
 533               	 ;  0 "" 2
 162:bootSAH_4.c   **** 	
 534               		.loc 1 162 0
 535               	 ;  162 "bootSAH_4.c" 1
 536 0006 0DBF      		out 61,16
 537               	 ;  0 "" 2
 168:bootSAH_4.c   **** 
 538               		.loc 1 168 0
 539               	/* #NOAPP */
 540 0008 94B7      		in r25,0x34
 541               	.LVL46:
 170:bootSAH_4.c   **** 	__asm__ __volatile__ ("wdr");
 542               		.loc 1 170 0
 543               	/* #APP */
 544               	 ;  170 "bootSAH_4.c" 1
 545 000a F894      		cli
 546               	 ;  0 "" 2
 171:bootSAH_4.c   **** 	//MCUSR	=	0;
 547               		.loc 1 171 0
 548               	 ;  171 "bootSAH_4.c" 1
 549 000c A895      		wdr
 550               	 ;  0 "" 2
 173:bootSAH_4.c   **** 	WDTCSR	=	0;
 551               		.loc 1 173 0
 552               	/* #NOAPP */
 553 000e 8091 6000 		lds r24,96
 554 0012 8861      		ori r24,lo8(24)
 555 0014 8093 6000 		sts 96,r24
 174:bootSAH_4.c   **** 	__asm__ __volatile__ ("sei");
 556               		.loc 1 174 0
 557 0018 1092 6000 		sts 96,__zero_reg__
 175:bootSAH_4.c   **** 	// check if WDT generated the reset, if so, go straight to app
 558               		.loc 1 175 0
 559               	/* #APP */
 560               	 ;  175 "bootSAH_4.c" 1
 561 001c 7894      		sei
 562               	 ;  0 "" 2
 177:bootSAH_4.c   **** 	{
 563               		.loc 1 177 0
 564               	/* #NOAPP */
 565 001e 93FF      		sbrs r25,3
 566 0020 00C0      		rjmp .L25
 179:bootSAH_4.c   **** 	}
 567               		.loc 1 179 0
 568 0022 E091 0000 		lds r30,app_start
 569 0026 F091 0000 		lds r31,app_start+1
 570 002a 1995      		eicall
 571               	.LVL47:
 572               	.L25:
 188:bootSAH_4.c   **** #endif
 573               		.loc 1 188 0
 574 002c 8091 C000 		lds r24,192
 575 0030 8260      		ori r24,lo8(2)
 576 0032 8093 C000 		sts 192,r24
 190:bootSAH_4.c   **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 577               		.loc 1 190 0
 578 0036 80E1      		ldi r24,lo8(16)
 579 0038 8093 C400 		sts 196,r24
 191:bootSAH_4.c   **** 
 580               		.loc 1 191 0
 581 003c 88E1      		ldi r24,lo8(24)
 582 003e 8093 C100 		sts 193,r24
 193:bootSAH_4.c   **** 
 583               		.loc 1 193 0
 584               	/* #APP */
 585               	 ;  193 "bootSAH_4.c" 1
 586 0042 0000      		nop
 587               	 ;  0 "" 2
 198:bootSAH_4.c   **** 				(1<<SPI_MOSI)|
 588               		.loc 1 198 0
 589               	/* #NOAPP */
 590 0044 87E0      		ldi r24,lo8(7)
 591 0046 84B9      		out 0x4,r24
 204:bootSAH_4.c   **** 				(0<<SPIE)|              // SPI Interupt Enable
 592               		.loc 1 204 0
 593 0048 81E5      		ldi r24,lo8(81)
 594 004a 8CBD      		out 0x2c,r24
 213:bootSAH_4.c   **** 	
 595               		.loc 1 213 0
 596 004c 289A      		sbi 0x5,0
 215:bootSAH_4.c   **** 	
 597               		.loc 1 215 0
 598               	/* #APP */
 599               	 ;  215 "bootSAH_4.c" 1
 600 004e 0000      		nop
 601               	 ;  0 "" 2
 221:bootSAH_4.c   **** 	sendchar('t');
 602               		.loc 1 221 0
 603               	/* #NOAPP */
 604 0050 85E7      		ldi r24,lo8(117)
 605 0052 0E94 0000 		call sendchar
 606               	.LVL48:
 222:bootSAH_4.c   **** 	sendchar('e');
 607               		.loc 1 222 0
 608 0056 84E7      		ldi r24,lo8(116)
 609 0058 0E94 0000 		call sendchar
 610               	.LVL49:
 223:bootSAH_4.c   **** 	sendchar('c');
 611               		.loc 1 223 0
 612 005c 85E6      		ldi r24,lo8(101)
 613 005e 0E94 0000 		call sendchar
 614               	.LVL50:
 224:bootSAH_4.c   **** 	sendchar('h');
 615               		.loc 1 224 0
 616 0062 83E6      		ldi r24,lo8(99)
 617 0064 0E94 0000 		call sendchar
 618               	.LVL51:
 225:bootSAH_4.c   **** 	sendchar('_');
 619               		.loc 1 225 0
 620 0068 88E6      		ldi r24,lo8(104)
 621 006a 0E94 0000 		call sendchar
 622               	.LVL52:
 226:bootSAH_4.c   **** 	sendchar('B');
 623               		.loc 1 226 0
 624 006e 8FE5      		ldi r24,lo8(95)
 625 0070 0E94 0000 		call sendchar
 626               	.LVL53:
 227:bootSAH_4.c   **** 	sendchar('B');
 627               		.loc 1 227 0
 628 0074 82E4      		ldi r24,lo8(66)
 629 0076 0E94 0000 		call sendchar
 630               	.LVL54:
 228:bootSAH_4.c   **** 
 631               		.loc 1 228 0
 632 007a 82E4      		ldi r24,lo8(66)
 633 007c 0E94 0000 		call sendchar
 634               	.LVL55:
 230:bootSAH_4.c   **** 	sendchar(0x0a);
 635               		.loc 1 230 0
 636 0080 8DE0      		ldi r24,lo8(13)
 637 0082 0E94 0000 		call sendchar
 638               	.LVL56:
 231:bootSAH_4.c   **** 
 639               		.loc 1 231 0
 640 0086 8AE0      		ldi r24,lo8(10)
 641 0088 0E94 0000 		call sendchar
 642               	.LVL57:
 233:bootSAH_4.c   **** #endif
 643               		.loc 1 233 0
 644 008c 84E6      		ldi r24,lo8(100)
 645 008e 90E0      		ldi r25,0
 646 0090 0E94 0000 		call delay_ms
 647               	.LVL58:
 245:bootSAH_4.c   **** 	FLASH_ResetEnable();
 648               		.loc 1 245 0
 649 0094 0E94 0000 		call FLASH_UntilReady
 650               	.LVL59:
 246:bootSAH_4.c   **** 	FLASH_Reset();
 651               		.loc 1 246 0
 652 0098 0E94 0000 		call FLASH_ResetEnable
 653               	.LVL60:
 247:bootSAH_4.c   **** 	
 654               		.loc 1 247 0
 655 009c 0E94 0000 		call FLASH_Reset
 656               	.LVL61:
 250:bootSAH_4.c   **** 	SPI_Transfer(0x9F);
 657               		.loc 1 250 0
 658 00a0 2898      		cbi 0x5,0
 251:bootSAH_4.c   **** 	temp = (uint32_t)SPI_Transfer(0) << 16;
 659               		.loc 1 251 0
 660 00a2 8FE9      		ldi r24,lo8(-97)
 661 00a4 0E94 0000 		call SPI_Transfer
 662               	.LVL62:
 252:bootSAH_4.c   **** 	temp |= (uint32_t)SPI_Transfer(0) << 8;
 663               		.loc 1 252 0
 664 00a8 80E0      		ldi r24,0
 665 00aa 0E94 0000 		call SPI_Transfer
 666               	.LVL63:
 667 00ae C82E      		mov r12,r24
 668 00b0 D12C      		mov r13,__zero_reg__
 669 00b2 E12C      		mov r14,__zero_reg__
 670 00b4 F12C      		mov r15,__zero_reg__
 671 00b6 7601      		movw r14,r12
 672 00b8 DD24      		clr r13
 673 00ba CC24      		clr r12
 674               	.LVL64:
 253:bootSAH_4.c   **** 	temp |= (uint32_t)SPI_Transfer(0);
 675               		.loc 1 253 0
 676 00bc 80E0      		ldi r24,0
 677 00be 0E94 0000 		call SPI_Transfer
 678               	.LVL65:
 679 00c2 D82A      		or r13,r24
 254:bootSAH_4.c   **** 	SPI_PORT |=  (1<<SPI_CS);     		// high
 680               		.loc 1 254 0
 681 00c4 80E0      		ldi r24,0
 682 00c6 0E94 0000 		call SPI_Transfer
 683               	.LVL66:
 255:bootSAH_4.c   **** 
 684               		.loc 1 255 0
 685 00ca 289A      		sbi 0x5,0
 257:bootSAH_4.c   **** 	{
 686               		.loc 1 257 0
 687 00cc C82A      		or r12,r24
 688               	.LVL67:
 689 00ce 87E1      		ldi r24,23
 690 00d0 C816      		cp r12,r24
 691 00d2 80E4      		ldi r24,64
 692 00d4 D806      		cpc r13,r24
 693 00d6 8FEE      		ldi r24,-17
 694 00d8 E806      		cpc r14,r24
 695 00da F104      		cpc r15,__zero_reg__
 696 00dc 01F0      		breq .+2
 697 00de 00C0      		rjmp .L27
 259:bootSAH_4.c   **** 			printByte(fBootStat>>8);
 698               		.loc 1 259 0
 699 00e0 60E0      		ldi r22,0
 700 00e2 70E1      		ldi r23,lo8(16)
 701 00e4 80E0      		ldi r24,0
 702 00e6 90E0      		ldi r25,0
 703 00e8 0E94 0000 		call FLASH_ReadWord
 704               	.LVL68:
 705 00ec 7C01      		movw r14,r24
 706               	.LVL69:
 260:bootSAH_4.c   **** 			printByte(fBootStat&0xff);
 707               		.loc 1 260 0
 708 00ee 8F2D      		mov r24,r15
 709 00f0 0E94 0000 		call printByte
 710               	.LVL70:
 261:bootSAH_4.c   **** 			sendchar(0x0d);		sendchar(0x0a);
 711               		.loc 1 261 0
 712 00f4 8E2D      		mov r24,r14
 713 00f6 0E94 0000 		call printByte
 714               	.LVL71:
 262:bootSAH_4.c   **** 		if(fBootStat == 0x2323)
 715               		.loc 1 262 0
 716 00fa 8DE0      		ldi r24,lo8(13)
 717 00fc 0E94 0000 		call sendchar
 718               	.LVL72:
 719 0100 8AE0      		ldi r24,lo8(10)
 720 0102 0E94 0000 		call sendchar
 721               	.LVL73:
 263:bootSAH_4.c   **** 		{
 722               		.loc 1 263 0
 723 0106 83E2      		ldi r24,35
 724 0108 E816      		cp r14,r24
 725 010a F806      		cpc r15,r24
 726 010c 01F4      		brne .L27
 265:bootSAH_4.c   **** 			fDataLen = FLASH_ReadWord(4098);
 727               		.loc 1 265 0
 728 010e 83E5      		ldi r24,lo8(83)
 729 0110 0E94 0000 		call sendchar
 730               	.LVL74:
 731 0114 8DE0      		ldi r24,lo8(13)
 732 0116 0E94 0000 		call sendchar
 733               	.LVL75:
 734 011a 8AE0      		ldi r24,lo8(10)
 735 011c 0E94 0000 		call sendchar
 736               	.LVL76:
 266:bootSAH_4.c   **** 				printByte(fDataLen>>8);
 737               		.loc 1 266 0
 738 0120 62E0      		ldi r22,lo8(2)
 739 0122 70E1      		ldi r23,lo8(16)
 740 0124 80E0      		ldi r24,0
 741 0126 90E0      		ldi r25,0
 742 0128 0E94 0000 		call FLASH_ReadWord
 743               	.LVL77:
 744 012c 7C01      		movw r14,r24
 745               	.LVL78:
 267:bootSAH_4.c   **** 				printByte(fDataLen&0xff);
 746               		.loc 1 267 0
 747 012e 8F2D      		mov r24,r15
 748 0130 0E94 0000 		call printByte
 749               	.LVL79:
 268:bootSAH_4.c   **** 				sendchar(0x0d);		sendchar(0x0a);
 750               		.loc 1 268 0
 751 0134 8E2D      		mov r24,r14
 752 0136 0E94 0000 		call printByte
 753               	.LVL80:
 269:bootSAH_4.c   **** 			if(fDataLen == 0x0B)
 754               		.loc 1 269 0
 755 013a 8DE0      		ldi r24,lo8(13)
 756 013c 0E94 0000 		call sendchar
 757               	.LVL81:
 758 0140 8AE0      		ldi r24,lo8(10)
 759 0142 0E94 0000 		call sendchar
 760               	.LVL82:
 270:bootSAH_4.c   **** 			{
 761               		.loc 1 270 0
 762 0146 8BE0      		ldi r24,11
 763 0148 E816      		cp r14,r24
 764 014a F104      		cpc r15,__zero_reg__
 765 014c 01F4      		brne .L27
 272:bootSAH_4.c   **** 			}
 766               		.loc 1 272 0
 767 014e 8CE4      		ldi r24,lo8(76)
 768 0150 0E94 0000 		call sendchar
 769               	.LVL83:
 770 0154 8DE0      		ldi r24,lo8(13)
 771 0156 0E94 0000 		call sendchar
 772               	.LVL84:
 773 015a 8AE0      		ldi r24,lo8(10)
 774 015c 0E94 0000 		call sendchar
 775               	.LVL85:
 776               	.L27:
 388:bootSAH_4.c   **** 	
 777               		.loc 1 388 0
 778 0160 0E94 0000 		call tiny_delay
 779               	.LVL86:
 393:bootSAH_4.c   **** 					"clr	r30		\n\t"
 780               		.loc 1 393 0
 781               	/* #APP */
 782               	 ;  393 "bootSAH_4.c" 1
 783 0164 EE27      		clr	r30		
 784 0166 FF27      		clr	r31		
 785 0168 0994      		ijmp			
 786               		
 787               	 ;  0 "" 2
 788               	/* #NOAPP */
 789               	.L29:
 401:bootSAH_4.c   **** 		sendchar(0x0d);
 790               		.loc 1 401 0 discriminator 1
 791 016a 86E5      		ldi r24,lo8(86)
 792 016c 0E94 0000 		call sendchar
 793               	.LVL87:
 402:bootSAH_4.c   **** 		sendchar(0x0a);
 794               		.loc 1 402 0 discriminator 1
 795 0170 8DE0      		ldi r24,lo8(13)
 796 0172 0E94 0000 		call sendchar
 797               	.LVL88:
 403:bootSAH_4.c   **** 		delay_ms(200);
 798               		.loc 1 403 0 discriminator 1
 799 0176 8AE0      		ldi r24,lo8(10)
 800 0178 0E94 0000 		call sendchar
 801               	.LVL89:
 404:bootSAH_4.c   ****     }
 802               		.loc 1 404 0 discriminator 1
 803 017c 88EC      		ldi r24,lo8(-56)
 804 017e 90E0      		ldi r25,0
 805 0180 0E94 0000 		call delay_ms
 806               	.LVL90:
 807 0184 00C0      		rjmp .L29
 808               		.cfi_endproc
 809               	.LFE11:
 811               		.text
 812               	.global	FLASH_EraseSector
 814               	FLASH_EraseSector:
 815               	.LFB25:
 552:bootSAH_4.c   **** 
 553:bootSAH_4.c   **** void FLASH_EraseSector(uint32_t faddr)
 554:bootSAH_4.c   **** {
 816               		.loc 1 554 0
 817               		.cfi_startproc
 818               	.LVL91:
 819 015e 1F93      		push r17
 820               	.LCFI8:
 821               		.cfi_def_cfa_offset 4
 822               		.cfi_offset 17, -3
 823 0160 CF93      		push r28
 824               	.LCFI9:
 825               		.cfi_def_cfa_offset 5
 826               		.cfi_offset 28, -4
 827 0162 DF93      		push r29
 828               	.LCFI10:
 829               		.cfi_def_cfa_offset 6
 830               		.cfi_offset 29, -5
 831               	/* prologue: function */
 832               	/* frame size = 0 */
 833               	/* stack size = 3 */
 834               	.L__stack_usage = 3
 835 0164 EB01      		movw r28,r22
 836 0166 182F      		mov r17,r24
 555:bootSAH_4.c   **** 	FLASH_UntilReady();
 837               		.loc 1 555 0
 838 0168 0E94 0000 		call FLASH_UntilReady
 839               	.LVL92:
 556:bootSAH_4.c   **** 	FLASH_WriteEnable();
 840               		.loc 1 556 0
 841 016c 0E94 0000 		call FLASH_WriteEnable
 842               	.LVL93:
 557:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 843               		.loc 1 557 0
 844 0170 2898      		cbi 0x5,0
 558:bootSAH_4.c   **** 	SPI_Transfer(0x20);
 845               		.loc 1 558 0
 846 0172 80E2      		ldi r24,lo8(32)
 847 0174 0E94 0000 		call SPI_Transfer
 848               	.LVL94:
 559:bootSAH_4.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 849               		.loc 1 559 0
 850 0178 812F      		mov r24,r17
 851 017a 0E94 0000 		call SPI_Transfer
 852               	.LVL95:
 560:bootSAH_4.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 853               		.loc 1 560 0
 854 017e 8D2F      		mov r24,r29
 855 0180 0E94 0000 		call SPI_Transfer
 856               	.LVL96:
 561:bootSAH_4.c   **** 	SPI_Transfer(faddr & 0xff);
 857               		.loc 1 561 0
 858 0184 8C2F      		mov r24,r28
 859 0186 0E94 0000 		call SPI_Transfer
 860               	.LVL97:
 562:bootSAH_4.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 861               		.loc 1 562 0
 862 018a 289A      		sbi 0x5,0
 563:bootSAH_4.c   **** 	tiny_delay();
 863               		.loc 1 563 0
 864 018c 0E94 0000 		call tiny_delay
 865               	.LVL98:
 866               	/* epilogue start */
 564:bootSAH_4.c   **** 	FLASH_UntilReady();
 565:bootSAH_4.c   **** }
 867               		.loc 1 565 0
 868 0190 DF91      		pop r29
 869 0192 CF91      		pop r28
 870 0194 1F91      		pop r17
 564:bootSAH_4.c   **** 	FLASH_UntilReady();
 871               		.loc 1 564 0
 872 0196 0C94 0000 		jmp FLASH_UntilReady
 873               	.LVL99:
 874               		.cfi_endproc
 875               	.LFE25:
 877               	.global	FLASH_WriteByte
 879               	FLASH_WriteByte:
 880               	.LFB26:
 566:bootSAH_4.c   **** 
 567:bootSAH_4.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata)
 568:bootSAH_4.c   **** {
 881               		.loc 1 568 0
 882               		.cfi_startproc
 883               	.LVL100:
 884 019a 0F93      		push r16
 885               	.LCFI11:
 886               		.cfi_def_cfa_offset 4
 887               		.cfi_offset 16, -3
 888 019c 1F93      		push r17
 889               	.LCFI12:
 890               		.cfi_def_cfa_offset 5
 891               		.cfi_offset 17, -4
 892 019e CF93      		push r28
 893               	.LCFI13:
 894               		.cfi_def_cfa_offset 6
 895               		.cfi_offset 28, -5
 896 01a0 DF93      		push r29
 897               	.LCFI14:
 898               		.cfi_def_cfa_offset 7
 899               		.cfi_offset 29, -6
 900               	/* prologue: function */
 901               	/* frame size = 0 */
 902               	/* stack size = 4 */
 903               	.L__stack_usage = 4
 904 01a2 D62F      		mov r29,r22
 905 01a4 172F      		mov r17,r23
 906 01a6 082F      		mov r16,r24
 907 01a8 C42F      		mov r28,r20
 569:bootSAH_4.c   **** 	FLASH_UntilReady();
 908               		.loc 1 569 0
 909 01aa 0E94 0000 		call FLASH_UntilReady
 910               	.LVL101:
 570:bootSAH_4.c   **** 	FLASH_WriteEnable();
 911               		.loc 1 570 0
 912 01ae 0E94 0000 		call FLASH_WriteEnable
 913               	.LVL102:
 571:bootSAH_4.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 914               		.loc 1 571 0
 915 01b2 2898      		cbi 0x5,0
 572:bootSAH_4.c   **** 	SPI_Transfer(0x02);
 916               		.loc 1 572 0
 917 01b4 82E0      		ldi r24,lo8(2)
 918 01b6 0E94 0000 		call SPI_Transfer
 919               	.LVL103:
 573:bootSAH_4.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 920               		.loc 1 573 0
 921 01ba 802F      		mov r24,r16
 922 01bc 0E94 0000 		call SPI_Transfer
 923               	.LVL104:
 574:bootSAH_4.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 924               		.loc 1 574 0
 925 01c0 812F      		mov r24,r17
 926 01c2 0E94 0000 		call SPI_Transfer
 927               	.LVL105:
 575:bootSAH_4.c   **** 	SPI_Transfer(faddr & 0xff);
 928               		.loc 1 575 0
 929 01c6 8D2F      		mov r24,r29
 930 01c8 0E94 0000 		call SPI_Transfer
 931               	.LVL106:
 576:bootSAH_4.c   **** 	SPI_Transfer(wdata & 0xff);
 932               		.loc 1 576 0
 933 01cc 8C2F      		mov r24,r28
 934 01ce 0E94 0000 		call SPI_Transfer
 935               	.LVL107:
 577:bootSAH_4.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 936               		.loc 1 577 0
 937 01d2 289A      		sbi 0x5,0
 578:bootSAH_4.c   **** 	tiny_delay();
 938               		.loc 1 578 0
 939 01d4 0E94 0000 		call tiny_delay
 940               	.LVL108:
 941               	/* epilogue start */
 579:bootSAH_4.c   **** 	FLASH_UntilReady();
 580:bootSAH_4.c   **** }
 942               		.loc 1 580 0
 943 01d8 DF91      		pop r29
 944 01da CF91      		pop r28
 945               	.LVL109:
 946 01dc 1F91      		pop r17
 947 01de 0F91      		pop r16
 579:bootSAH_4.c   **** 	FLASH_UntilReady();
 948               		.loc 1 579 0
 949 01e0 0C94 0000 		jmp FLASH_UntilReady
 950               	.LVL110:
 951               		.cfi_endproc
 952               	.LFE26:
 954               	.global	app_start
 955               		.section .bss
 958               	app_start:
 959 0000 0000      		.zero	2
 960               		.text
 961               	.Letext0:
 962               		.file 3 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\st
DEFINED SYMBOLS
                            *ABS*:00000000 bootSAH_4.c
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:2      *ABS*:0000003e __SP_H__
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:3      *ABS*:0000003d __SP_L__
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:4      *ABS*:0000003f __SREG__
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:7      *ABS*:00000001 __zero_reg__
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:12     .text:00000000 sendchar
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:40     .text:00000018 SPI_Transfer
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:73     .init9:00000000 __jumpMain
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:84     *ABS*:000021ff __stack
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:508    .text.startup:00000000 main
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:123    .text:00000026 delay_ms
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:169    .text:00000044 tiny_delay
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:213    .text:00000050 printByte
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:303    .text:000000b8 FLASH_UntilReady
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:342    .text:000000d4 FLASH_ResetEnable
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:366    .text:000000e2 FLASH_Reset
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:390    .text:000000f0 FLASH_WriteEnable
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:414    .text:000000fe FLASH_ReadWord
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:958    .bss:00000000 app_start
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:814    .text:0000015e FLASH_EraseSector
C:\Users\supun\AppData\Local\Temp\ccOTSAbx.s:879    .text:0000019a FLASH_WriteByte

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
