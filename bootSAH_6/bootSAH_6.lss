
bootSAH_6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  0003e590  00000624  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000590  0003e000  0003e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000002  00800200  00800200  00000624  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000624  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000654  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000030  00000000  00000000  00000694  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001485  00000000  00000000  000006c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d40  00000000  00000000  00001b49  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000061b  00000000  00000000  00002889  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000128  00000000  00000000  00002ea4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006e1  00000000  00000000  00002fcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000062d  00000000  00000000  000036ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000020  00000000  00000000  00003cda  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0003e000 <__vectors>:
   3e000:	0d 94 72 f0 	jmp	0x3e0e4	; 0x3e0e4 <__ctors_end>
   3e004:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e008:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e00c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e010:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e014:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e018:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e01c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e020:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e024:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e028:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e02c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e030:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e034:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e038:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e03c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e040:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e044:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e048:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e04c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e050:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e054:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e058:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e05c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e060:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e064:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e068:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e06c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e070:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e074:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e078:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e07c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e080:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e084:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e088:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e08c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e090:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e094:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e098:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e09c:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0a0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0a4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0a8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0ac:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0b0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0b4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0b8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0bc:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0c0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0c4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0c8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0cc:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0d0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0d4:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0d8:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0dc:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>
   3e0e0:	0d 94 8e f0 	jmp	0x3e11c	; 0x3e11c <__bad_interrupt>

0003e0e4 <__ctors_end>:
   3e0e4:	11 24       	eor	r1, r1
   3e0e6:	1f be       	out	0x3f, r1	; 63
   3e0e8:	cf ef       	ldi	r28, 0xFF	; 255
   3e0ea:	d1 e2       	ldi	r29, 0x21	; 33
   3e0ec:	de bf       	out	0x3e, r29	; 62
   3e0ee:	cd bf       	out	0x3d, r28	; 61
   3e0f0:	01 e0       	ldi	r16, 0x01	; 1
   3e0f2:	0c bf       	out	0x3c, r16	; 60

0003e0f4 <__do_clear_bss>:
   3e0f4:	22 e0       	ldi	r18, 0x02	; 2
   3e0f6:	a0 e0       	ldi	r26, 0x00	; 0
   3e0f8:	b2 e0       	ldi	r27, 0x02	; 2
   3e0fa:	01 c0       	rjmp	.+2      	; 0x3e0fe <.do_clear_bss_start>

0003e0fc <.do_clear_bss_loop>:
   3e0fc:	1d 92       	st	X+, r1

0003e0fe <.do_clear_bss_start>:
   3e0fe:	a2 30       	cpi	r26, 0x02	; 2
   3e100:	b2 07       	cpc	r27, r18
   3e102:	e1 f7       	brne	.-8      	; 0x3e0fc <.do_clear_bss_loop>
   3e104:	0f 94 36 f1 	call	0x3e26c	; 0x3e26c <main>
   3e108:	0d 94 c6 f2 	jmp	0x3e58c	; 0x3e58c <_exit>

0003e10c <__jumpMain>:

	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );

//*	set stack pointer to top of RAM

	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
   3e10c:	01 e2       	ldi	r16, 0x21	; 33
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
   3e10e:	0e bf       	out	0x3e, r16	; 62

	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
   3e110:	0f ef       	ldi	r16, 0xFF	; 255
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
   3e112:	0d bf       	out	0x3d, r16	; 61

	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
   3e114:	11 24       	eor	r1, r1
	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
   3e116:	1f be       	out	0x3f, r1	; 63
	asm volatile ( "jmp main");												// jump to main()
   3e118:	0d 94 36 f1 	jmp	0x3e26c	; 0x3e26c <main>

0003e11c <__bad_interrupt>:
   3e11c:	0d 94 00 f0 	jmp	0x3e000	; 0x3e000 <__vectors>

0003e120 <SPI_Transfer>:
#include <avr/sfr_defs.h>


static uint8_t SPI_Transfer(uint8_t spidata)
{
	SPDR = spidata;
   3e120:	8e bd       	out	0x2e, r24	; 46
	asm volatile("nop");			// small delay
   3e122:	00 00       	nop
	while(!(SPSR & (1<<SPIF)));		// Wait for transmission complete
   3e124:	0d b4       	in	r0, 0x2d	; 45
   3e126:	07 fe       	sbrs	r0, 7
   3e128:	fd cf       	rjmp	.-6      	; 0x3e124 <SPI_Transfer+0x4>

	return SPDR;
   3e12a:	8e b5       	in	r24, 0x2e	; 46
}
   3e12c:	08 95       	ret

0003e12e <delay_ms>:

//*****************************************************************************
void delay_ms(unsigned int timedelay)
{
	unsigned int i;
	for (i=0;i<timedelay;i++)
   3e12e:	20 e0       	ldi	r18, 0x00	; 0
   3e130:	30 e0       	ldi	r19, 0x00	; 0
   3e132:	28 17       	cp	r18, r24
   3e134:	39 07       	cpc	r19, r25
   3e136:	49 f0       	breq	.+18     	; 0x3e14a <delay_ms+0x1c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   3e138:	ef ec       	ldi	r30, 0xCF	; 207
   3e13a:	f7 e0       	ldi	r31, 0x07	; 7
   3e13c:	31 97       	sbiw	r30, 0x01	; 1
   3e13e:	f1 f7       	brne	.-4      	; 0x3e13c <delay_ms+0xe>
   3e140:	00 c0       	rjmp	.+0      	; 0x3e142 <delay_ms+0x14>
   3e142:	00 00       	nop
   3e144:	2f 5f       	subi	r18, 0xFF	; 255
   3e146:	3f 4f       	sbci	r19, 0xFF	; 255
   3e148:	f4 cf       	rjmp	.-24     	; 0x3e132 <delay_ms+0x4>
	{
		_delay_ms(0.5);
	}
}
   3e14a:	08 95       	ret

0003e14c <tiny_delay>:
	...
//** small delay
void tiny_delay()		
{
	asm volatile(
   3e154:	00 00       	nop
   3e156:	08 95       	ret

0003e158 <FLASH_UntilReady>:


void FLASH_UntilReady()
{
	uint8_t stat=0xff;
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e158:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x05);
   3e15a:	85 e0       	ldi	r24, 0x05	; 5
   3e15c:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
//************************************************************************


void FLASH_UntilReady()
{
	uint8_t stat=0xff;
   3e160:	8f ef       	ldi	r24, 0xFF	; 255
	SPI_PORT  &=  ~(1<<SPI_CS);
	SPI_Transfer(0x05);
	while((stat & 0x01) == 0x01)
   3e162:	80 ff       	sbrs	r24, 0
   3e164:	04 c0       	rjmp	.+8      	; 0x3e16e <FLASH_UntilReady+0x16>
	{
		stat = SPI_Transfer(0);
   3e166:	80 e0       	ldi	r24, 0x00	; 0
   3e168:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e16c:	fa cf       	rjmp	.-12     	; 0x3e162 <FLASH_UntilReady+0xa>
	}
	SPI_PORT  |=   (1<<SPI_CS);
   3e16e:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e170:	0d 94 a6 f0 	jmp	0x3e14c	; 0x3e14c <tiny_delay>

0003e174 <FLASH_ResetEnable>:
}

void FLASH_ResetEnable()
{
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e174:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x66);
   3e176:	86 e6       	ldi	r24, 0x66	; 102
   3e178:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e17c:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e17e:	0d 94 a6 f0 	jmp	0x3e14c	; 0x3e14c <tiny_delay>

0003e182 <FLASH_Reset>:
}

void FLASH_Reset()
{
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e182:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x99);
   3e184:	89 e9       	ldi	r24, 0x99	; 153
   3e186:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e18a:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e18c:	0d 94 a6 f0 	jmp	0x3e14c	; 0x3e14c <tiny_delay>

0003e190 <FLASH_WriteEnable>:
}

void FLASH_WriteEnable()
{
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e190:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x06);
   3e192:	86 e0       	ldi	r24, 0x06	; 6
   3e194:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e198:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e19a:	0d 94 a6 f0 	jmp	0x3e14c	; 0x3e14c <tiny_delay>

0003e19e <FLASH_ReadWord>:
}

uint16_t FLASH_ReadWord(uint32_t faddr)
{
   3e19e:	1f 93       	push	r17
   3e1a0:	cf 93       	push	r28
   3e1a2:	df 93       	push	r29
   3e1a4:	eb 01       	movw	r28, r22
   3e1a6:	18 2f       	mov	r17, r24
	uint16_t temp1=0, temp2=0;
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e1a8:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x03);
   3e1aa:	83 e0       	ldi	r24, 0x03	; 3
   3e1ac:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e1b0:	81 2f       	mov	r24, r17
   3e1b2:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e1b6:	8d 2f       	mov	r24, r29
   3e1b8:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e1bc:	8c 2f       	mov	r24, r28
   3e1be:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	temp1 = SPI_Transfer(0);
   3e1c2:	80 e0       	ldi	r24, 0x00	; 0
   3e1c4:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e1c8:	d8 2f       	mov	r29, r24
	temp2 = SPI_Transfer(0);
   3e1ca:	80 e0       	ldi	r24, 0x00	; 0
   3e1cc:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e1d0:	c8 2f       	mov	r28, r24
	SPI_PORT  |=   (1<<SPI_CS);
   3e1d2:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e1d4:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
				
	return ((temp1 << 8) | (temp2 & 0x00ff));
   3e1d8:	8c 2f       	mov	r24, r28
   3e1da:	90 e0       	ldi	r25, 0x00	; 0
}
   3e1dc:	9d 2b       	or	r25, r29
   3e1de:	df 91       	pop	r29
   3e1e0:	cf 91       	pop	r28
   3e1e2:	1f 91       	pop	r17
   3e1e4:	08 95       	ret

0003e1e6 <FLASH_EraseSector>:

void FLASH_EraseSector(uint32_t faddr)
{
   3e1e6:	1f 93       	push	r17
   3e1e8:	cf 93       	push	r28
   3e1ea:	df 93       	push	r29
   3e1ec:	eb 01       	movw	r28, r22
   3e1ee:	18 2f       	mov	r17, r24
	FLASH_UntilReady();
   3e1f0:	0f 94 ac f0 	call	0x3e158	; 0x3e158 <FLASH_UntilReady>
	FLASH_WriteEnable();
   3e1f4:	0f 94 c8 f0 	call	0x3e190	; 0x3e190 <FLASH_WriteEnable>
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e1f8:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x20);
   3e1fa:	80 e2       	ldi	r24, 0x20	; 32
   3e1fc:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e200:	81 2f       	mov	r24, r17
   3e202:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e206:	8d 2f       	mov	r24, r29
   3e208:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e20c:	8c 2f       	mov	r24, r28
   3e20e:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e212:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e214:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
	FLASH_UntilReady();
}
   3e218:	df 91       	pop	r29
   3e21a:	cf 91       	pop	r28
   3e21c:	1f 91       	pop	r17
	SPI_Transfer((faddr >> 16) & 0xff);
	SPI_Transfer((faddr >> 8) & 0xff);
	SPI_Transfer(faddr & 0xff);
	SPI_PORT  |=   (1<<SPI_CS);
	tiny_delay();
	FLASH_UntilReady();
   3e21e:	0d 94 ac f0 	jmp	0x3e158	; 0x3e158 <FLASH_UntilReady>

0003e222 <FLASH_WriteByte>:
}

void FLASH_WriteByte(uint32_t faddr, uint8_t wdata)
{
   3e222:	0f 93       	push	r16
   3e224:	1f 93       	push	r17
   3e226:	cf 93       	push	r28
   3e228:	df 93       	push	r29
   3e22a:	d6 2f       	mov	r29, r22
   3e22c:	17 2f       	mov	r17, r23
   3e22e:	08 2f       	mov	r16, r24
   3e230:	c4 2f       	mov	r28, r20
	FLASH_UntilReady();
   3e232:	0f 94 ac f0 	call	0x3e158	; 0x3e158 <FLASH_UntilReady>
	FLASH_WriteEnable();
   3e236:	0f 94 c8 f0 	call	0x3e190	; 0x3e190 <FLASH_WriteEnable>
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e23a:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x02);
   3e23c:	82 e0       	ldi	r24, 0x02	; 2
   3e23e:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer((faddr >> 16) & 0xff);
   3e242:	80 2f       	mov	r24, r16
   3e244:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer((faddr >> 8) & 0xff);
   3e248:	81 2f       	mov	r24, r17
   3e24a:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer(faddr & 0xff);
   3e24e:	8d 2f       	mov	r24, r29
   3e250:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_Transfer(wdata & 0xff);
   3e254:	8c 2f       	mov	r24, r28
   3e256:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_PORT  |=   (1<<SPI_CS);
   3e25a:	28 9a       	sbi	0x05, 0	; 5
	tiny_delay();
   3e25c:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
	FLASH_UntilReady();
}
   3e260:	df 91       	pop	r29
   3e262:	cf 91       	pop	r28
   3e264:	1f 91       	pop	r17
   3e266:	0f 91       	pop	r16
	SPI_Transfer((faddr >> 8) & 0xff);
	SPI_Transfer(faddr & 0xff);
	SPI_Transfer(wdata & 0xff);
	SPI_PORT  |=   (1<<SPI_CS);
	tiny_delay();
	FLASH_UntilReady();
   3e268:	0d 94 ac f0 	jmp	0x3e158	; 0x3e158 <FLASH_UntilReady>

0003e26c <main>:
//*	for watch dog timer startup
void (*app_start)(void) = 0x0000;


int main(void)
{
   3e26c:	cf 93       	push	r28
   3e26e:	df 93       	push	r29
   3e270:	cd b7       	in	r28, 0x3d	; 61
   3e272:	de b7       	in	r29, 0x3e	; 62
   3e274:	c6 50       	subi	r28, 0x06	; 6
   3e276:	d1 40       	sbci	r29, 0x01	; 1
   3e278:	0f b6       	in	r0, 0x3f	; 63
   3e27a:	f8 94       	cli
   3e27c:	de bf       	out	0x3e, r29	; 62
   3e27e:	0f be       	out	0x3f, r0	; 63
   3e280:	cd bf       	out	0x3d, r28	; 61

//************************************************************************
	
	//*	some chips dont set the stack properly
	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
   3e282:	01 e2       	ldi	r16, 0x21	; 33
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
   3e284:	0e bf       	out	0x3e, r16	; 62
	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
   3e286:	0f ef       	ldi	r16, 0xFF	; 255
	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
   3e288:	0d bf       	out	0x3d, r16	; 61
	
//************************************************************************

//*	handle the watch dog timer
	uint8_t	mcuStatusReg;
	mcuStatusReg	=	MCUSR;
   3e28a:	94 b7       	in	r25, 0x34	; 52

	__asm__ __volatile__ ("cli");
   3e28c:	f8 94       	cli
	__asm__ __volatile__ ("wdr");
   3e28e:	a8 95       	wdr
	//MCUSR	=	0;
	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
   3e290:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
   3e294:	88 61       	ori	r24, 0x18	; 24
   3e296:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	WDTCSR	=	0;
   3e29a:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	__asm__ __volatile__ ("sei");
   3e29e:	78 94       	sei
	// check if WDT generated the reset, if so, go straight to app
	if (mcuStatusReg & _BV(WDRF))
   3e2a0:	93 ff       	sbrs	r25, 3
   3e2a2:	05 c0       	rjmp	.+10     	; 0x3e2ae <main+0x42>
	{
		app_start();
   3e2a4:	e0 91 00 02 	lds	r30, 0x0200	; 0x800200 <_edata>
   3e2a8:	f0 91 01 02 	lds	r31, 0x0201	; 0x800201 <_edata+0x1>
   3e2ac:	19 95       	eicall
	}
	
//************************************************************************

//* Init SPI
	SPI_DDR = (	(0<<SPI_MISO)|
   3e2ae:	87 e0       	ldi	r24, 0x07	; 7
   3e2b0:	84 b9       	out	0x04, r24	; 4
				(1<<SPI_MOSI)|
				(1<<SPI_SCK) |
				(1<<SPI_CS)
			  );

	SPCR = (	(1<<SPE) |              // SPI Enable
   3e2b2:	81 e5       	ldi	r24, 0x51	; 81
   3e2b4:	8c bd       	out	0x2c, r24	; 44
				(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
				(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
				(0<<CPHA)               // Clock Phase (0:leading / 1:trailing edge sampling)
			);
			
	SPI_PORT |=  (1<<SPI_CS); 			// pull high
   3e2b6:	28 9a       	sbi	0x05, 0	; 5
	
	asm volatile ("nop");				// wait until port has changed
   3e2b8:	00 00       	nop
	fCsumAddr  = 4352;
	fPageAddr  = 0;
	
//************************************************************************	
//* Init ExFlash
	FLASH_UntilReady();
   3e2ba:	0f 94 ac f0 	call	0x3e158	; 0x3e158 <FLASH_UntilReady>
	FLASH_ResetEnable();
   3e2be:	0f 94 ba f0 	call	0x3e174	; 0x3e174 <FLASH_ResetEnable>
	FLASH_Reset();
   3e2c2:	0f 94 c1 f0 	call	0x3e182	; 0x3e182 <FLASH_Reset>
	
	SPI_PORT  &=  ~(1<<SPI_CS);
   3e2c6:	28 98       	cbi	0x05, 0	; 5
	SPI_Transfer(0x9F);
   3e2c8:	8f e9       	ldi	r24, 0x9F	; 159
   3e2ca:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	fMemStatus = (uint32_t)SPI_Transfer(0) << 16;
   3e2ce:	80 e0       	ldi	r24, 0x00	; 0
   3e2d0:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e2d4:	c8 2e       	mov	r12, r24
   3e2d6:	d1 2c       	mov	r13, r1
   3e2d8:	e1 2c       	mov	r14, r1
   3e2da:	f1 2c       	mov	r15, r1
   3e2dc:	76 01       	movw	r14, r12
   3e2de:	dd 24       	eor	r13, r13
   3e2e0:	cc 24       	eor	r12, r12
	fMemStatus |= (uint32_t)SPI_Transfer(0) << 8;
   3e2e2:	80 e0       	ldi	r24, 0x00	; 0
   3e2e4:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e2e8:	d8 2a       	or	r13, r24
	fMemStatus |= (uint32_t)SPI_Transfer(0);
   3e2ea:	80 e0       	ldi	r24, 0x00	; 0
   3e2ec:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
	SPI_PORT |=  (1<<SPI_CS);
   3e2f0:	28 9a       	sbi	0x05, 0	; 5

	if(fMemStatus == EXMEM_JEDEC)
   3e2f2:	c8 2a       	or	r12, r24
   3e2f4:	27 e1       	ldi	r18, 0x17	; 23
   3e2f6:	c2 16       	cp	r12, r18
   3e2f8:	20 e4       	ldi	r18, 0x40	; 64
   3e2fa:	d2 06       	cpc	r13, r18
   3e2fc:	2f ee       	ldi	r18, 0xEF	; 239
   3e2fe:	e2 06       	cpc	r14, r18
   3e300:	f1 04       	cpc	r15, r1
   3e302:	09 f0       	breq	.+2      	; 0x3e306 <main+0x9a>
   3e304:	32 c1       	rjmp	.+612    	; 0x3e56a <main+0x2fe>
	{
		SPI_PORT  &=  ~(1<<SPI_CS);
   3e306:	28 98       	cbi	0x05, 0	; 5
		SPI_Transfer(0x03);
   3e308:	83 e0       	ldi	r24, 0x03	; 3
   3e30a:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
		SPI_Transfer((fBStatAddr >> 16) & 0xff);
   3e30e:	80 e0       	ldi	r24, 0x00	; 0
   3e310:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
		SPI_Transfer((fBStatAddr >> 8) & 0xff);
   3e314:	80 e1       	ldi	r24, 0x10	; 16
   3e316:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
		SPI_Transfer(fBStatAddr & 0xff);
   3e31a:	80 e0       	ldi	r24, 0x00	; 0
   3e31c:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
		fBootStat = (uint16_t)SPI_Transfer(0) << 8;
   3e320:	80 e0       	ldi	r24, 0x00	; 0
   3e322:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e326:	08 2f       	mov	r16, r24
   3e328:	10 e0       	ldi	r17, 0x00	; 0
   3e32a:	10 2f       	mov	r17, r16
   3e32c:	00 27       	eor	r16, r16
		fBootStat |= (uint16_t)SPI_Transfer(0);
   3e32e:	80 e0       	ldi	r24, 0x00	; 0
   3e330:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e334:	08 2b       	or	r16, r24
		SPI_PORT  |=   (1<<SPI_CS);
   3e336:	28 9a       	sbi	0x05, 0	; 5
		tiny_delay();
   3e338:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>


		if(fBootStat == 0x2323)
   3e33c:	03 32       	cpi	r16, 0x23	; 35
   3e33e:	13 42       	sbci	r17, 0x23	; 35
   3e340:	09 f0       	breq	.+2      	; 0x3e344 <main+0xd8>
   3e342:	13 c1       	rjmp	.+550    	; 0x3e56a <main+0x2fe>
		{
			
			SPI_PORT  &=  ~(1<<SPI_CS);
   3e344:	28 98       	cbi	0x05, 0	; 5
			SPI_Transfer(0x03);
   3e346:	83 e0       	ldi	r24, 0x03	; 3
   3e348:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
			SPI_Transfer((fDLenAddr >> 16) & 0xff);
   3e34c:	80 e0       	ldi	r24, 0x00	; 0
   3e34e:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
			SPI_Transfer((fDLenAddr >> 8) & 0xff);
   3e352:	80 e1       	ldi	r24, 0x10	; 16
   3e354:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
			SPI_Transfer(fDLenAddr & 0xff);
   3e358:	82 e0       	ldi	r24, 0x02	; 2
   3e35a:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
			fDataLen = (uint16_t)SPI_Transfer(0) << 8;
   3e35e:	80 e0       	ldi	r24, 0x00	; 0
   3e360:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e364:	18 2f       	mov	r17, r24
			fDataLen |= (uint16_t)SPI_Transfer(0);
   3e366:	80 e0       	ldi	r24, 0x00	; 0
   3e368:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e36c:	21 2f       	mov	r18, r17
   3e36e:	30 e0       	ldi	r19, 0x00	; 0
   3e370:	32 2f       	mov	r19, r18
   3e372:	22 27       	eor	r18, r18
   3e374:	a9 01       	movw	r20, r18
   3e376:	48 2b       	or	r20, r24
   3e378:	cd 5f       	subi	r28, 0xFD	; 253
   3e37a:	de 4f       	sbci	r29, 0xFE	; 254
   3e37c:	59 83       	std	Y+1, r21	; 0x01
   3e37e:	48 83       	st	Y, r20
   3e380:	c3 50       	subi	r28, 0x03	; 3
   3e382:	d1 40       	sbci	r29, 0x01	; 1
			SPI_PORT  |=   (1<<SPI_CS);
   3e384:	28 9a       	sbi	0x05, 0	; 5
			tiny_delay();
   3e386:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
//************************************************************************

	fBStatAddr = 4096;
	fDLenAddr  = 4098;
	fDataAddr  = 8192;
	fCsumAddr  = 4352;
   3e38a:	81 2c       	mov	r8, r1
   3e38c:	51 e1       	ldi	r21, 0x11	; 17
   3e38e:	95 2e       	mov	r9, r21
   3e390:	a1 2c       	mov	r10, r1
   3e392:	b1 2c       	mov	r11, r1
	
//************************************************************************

	fBStatAddr = 4096;
	fDLenAddr  = 4098;
	fDataAddr  = 8192;
   3e394:	c1 2c       	mov	r12, r1
   3e396:	60 e2       	ldi	r22, 0x20	; 32
   3e398:	d6 2e       	mov	r13, r22
   3e39a:	e1 2c       	mov	r14, r1
   3e39c:	f1 2c       	mov	r15, r1
   3e39e:	ce 01       	movw	r24, r28
   3e3a0:	8f 5f       	subi	r24, 0xFF	; 255
   3e3a2:	9e 4f       	sbci	r25, 0xFE	; 254
   3e3a4:	cf 5f       	subi	r28, 0xFF	; 255
   3e3a6:	de 4f       	sbci	r29, 0xFE	; 254
   3e3a8:	99 83       	std	Y+1, r25	; 0x01
   3e3aa:	88 83       	st	Y, r24
   3e3ac:	c1 50       	subi	r28, 0x01	; 1
   3e3ae:	d1 40       	sbci	r29, 0x01	; 1
   3e3b0:	26 01       	movw	r4, r12
   3e3b2:	37 01       	movw	r6, r14
   3e3b4:	90 e2       	ldi	r25, 0x20	; 32
   3e3b6:	59 1a       	sub	r5, r25
   3e3b8:	61 08       	sbc	r6, r1
   3e3ba:	71 08       	sbc	r7, r1
				
				fMemSize = EXMEM_PAGE_SIZE;
				fMemIndex = 0;
				//fRdTries  = 0;
				fChSumCal = 0;
				SPI_PORT  &=  ~(1<<SPI_CS);
   3e3bc:	28 98       	cbi	0x05, 0	; 5
				SPI_Transfer(0x03);
   3e3be:	83 e0       	ldi	r24, 0x03	; 3
   3e3c0:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
				SPI_Transfer((fDataAddr >> 16) & 0xff);
   3e3c4:	8e 2d       	mov	r24, r14
   3e3c6:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
				SPI_Transfer((fDataAddr >> 8) & 0xff);
   3e3ca:	8d 2d       	mov	r24, r13
   3e3cc:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
				SPI_Transfer(fDataAddr & 0xff);			
   3e3d0:	80 e0       	ldi	r24, 0x00	; 0
   3e3d2:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e3d6:	fe 01       	movw	r30, r28
   3e3d8:	31 96       	adiw	r30, 0x01	; 1
   3e3da:	1f 01       	movw	r2, r30
   3e3dc:	8f 01       	movw	r16, r30
			{
				
				fMemSize = EXMEM_PAGE_SIZE;
				fMemIndex = 0;
				//fRdTries  = 0;
				fChSumCal = 0;
   3e3de:	cb 5f       	subi	r28, 0xFB	; 251
   3e3e0:	de 4f       	sbci	r29, 0xFE	; 254
   3e3e2:	19 82       	std	Y+1, r1	; 0x01
   3e3e4:	18 82       	st	Y, r1
   3e3e6:	c5 50       	subi	r28, 0x05	; 5
   3e3e8:	d1 40       	sbci	r29, 0x01	; 1
				SPI_Transfer((fDataAddr >> 16) & 0xff);
				SPI_Transfer((fDataAddr >> 8) & 0xff);
				SPI_Transfer(fDataAddr & 0xff);			
				do 
				{
					fRdData = SPI_Transfer(0);
   3e3ea:	80 e0       	ldi	r24, 0x00	; 0
   3e3ec:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
					flashBuff[fMemIndex++] = fRdData;
   3e3f0:	f8 01       	movw	r30, r16
   3e3f2:	81 93       	st	Z+, r24
   3e3f4:	8f 01       	movw	r16, r30
					fChSumCal += fRdData;				
   3e3f6:	cb 5f       	subi	r28, 0xFB	; 251
   3e3f8:	de 4f       	sbci	r29, 0xFE	; 254
   3e3fa:	28 81       	ld	r18, Y
   3e3fc:	39 81       	ldd	r19, Y+1	; 0x01
   3e3fe:	c5 50       	subi	r28, 0x05	; 5
   3e400:	d1 40       	sbci	r29, 0x01	; 1
   3e402:	28 0f       	add	r18, r24
   3e404:	31 1d       	adc	r19, r1
   3e406:	cb 5f       	subi	r28, 0xFB	; 251
   3e408:	de 4f       	sbci	r29, 0xFE	; 254
   3e40a:	39 83       	std	Y+1, r19	; 0x01
   3e40c:	28 83       	st	Y, r18
   3e40e:	c5 50       	subi	r28, 0x05	; 5
   3e410:	d1 40       	sbci	r29, 0x01	; 1
					fMemSize--;
				} while (fMemSize);		
   3e412:	cf 5f       	subi	r28, 0xFF	; 255
   3e414:	de 4f       	sbci	r29, 0xFE	; 254
   3e416:	48 81       	ld	r20, Y
   3e418:	59 81       	ldd	r21, Y+1	; 0x01
   3e41a:	c1 50       	subi	r28, 0x01	; 1
   3e41c:	d1 40       	sbci	r29, 0x01	; 1
   3e41e:	e4 17       	cp	r30, r20
   3e420:	f5 07       	cpc	r31, r21
   3e422:	19 f7       	brne	.-58     	; 0x3e3ea <main+0x17e>
				SPI_PORT  |=   (1<<SPI_CS);
   3e424:	28 9a       	sbi	0x05, 0	; 5
				tiny_delay();
   3e426:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>

		
				SPI_PORT  &=  ~(1<<SPI_CS);
   3e42a:	28 98       	cbi	0x05, 0	; 5
				SPI_Transfer(0x03);
   3e42c:	83 e0       	ldi	r24, 0x03	; 3
   3e42e:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
				SPI_Transfer((fCsumAddr >> 16) & 0xff);
   3e432:	80 e0       	ldi	r24, 0x00	; 0
   3e434:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
				SPI_Transfer((fCsumAddr >> 8) & 0xff);
   3e438:	89 2d       	mov	r24, r9
   3e43a:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
				SPI_Transfer(fCsumAddr & 0xff);				
   3e43e:	88 2d       	mov	r24, r8
   3e440:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
				fChSumRev = (uint16_t)SPI_Transfer(0) << 8;
   3e444:	80 e0       	ldi	r24, 0x00	; 0
   3e446:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e44a:	08 2f       	mov	r16, r24
   3e44c:	10 e0       	ldi	r17, 0x00	; 0
   3e44e:	10 2f       	mov	r17, r16
   3e450:	00 27       	eor	r16, r16
				fChSumRev |= (uint16_t)SPI_Transfer(0);			
   3e452:	80 e0       	ldi	r24, 0x00	; 0
   3e454:	0f 94 90 f0 	call	0x3e120	; 0x3e120 <SPI_Transfer>
   3e458:	08 2b       	or	r16, r24
				SPI_PORT  |=   (1<<SPI_CS);
   3e45a:	28 9a       	sbi	0x05, 0	; 5
				tiny_delay();
   3e45c:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
		
				if(fChSumRev != fChSumCal)
   3e460:	cb 5f       	subi	r28, 0xFB	; 251
   3e462:	de 4f       	sbci	r29, 0xFE	; 254
   3e464:	88 81       	ld	r24, Y
   3e466:	99 81       	ldd	r25, Y+1	; 0x01
   3e468:	c5 50       	subi	r28, 0x05	; 5
   3e46a:	d1 40       	sbci	r29, 0x01	; 1
   3e46c:	80 17       	cp	r24, r16
   3e46e:	91 07       	cpc	r25, r17
   3e470:	09 f0       	breq	.+2      	; 0x3e474 <main+0x208>
   3e472:	73 c0       	rjmp	.+230    	; 0x3e55a <main+0x2ee>
				
 				ftempAddr  = fPageAddr;
 				fMemSize = SPM_PAGESIZE;
 				fMemIndex  = 0;
				 
				if (fPageAddr >= APP_END )
   3e474:	c1 14       	cp	r12, r1
   3e476:	90 ee       	ldi	r25, 0xE0	; 224
   3e478:	d9 06       	cpc	r13, r25
   3e47a:	93 e0       	ldi	r25, 0x03	; 3
   3e47c:	e9 06       	cpc	r14, r25
   3e47e:	f1 04       	cpc	r15, r1
   3e480:	09 f4       	brne	.+2      	; 0x3e484 <main+0x218>
   3e482:	6b c0       	rjmp	.+214    	; 0x3e55a <main+0x2ee>
				{
					//todo: flash write error msg
					break;
				}
					
				boot_page_erase_safe(fPageAddr);
   3e484:	07 b6       	in	r0, 0x37	; 55
   3e486:	00 fc       	sbrc	r0, 0
   3e488:	fd cf       	rjmp	.-6      	; 0x3e484 <main+0x218>
   3e48a:	f9 99       	sbic	0x1f, 1	; 31
   3e48c:	fe cf       	rjmp	.-4      	; 0x3e48a <main+0x21e>
   3e48e:	83 e0       	ldi	r24, 0x03	; 3
   3e490:	f2 01       	movw	r30, r4
   3e492:	60 92 5b 00 	sts	0x005B, r6	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
   3e496:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e49a:	e8 95       	spm
				boot_spm_busy_wait();			
   3e49c:	07 b6       	in	r0, 0x37	; 55
   3e49e:	00 fc       	sbrc	r0, 0
   3e4a0:	fd cf       	rjmp	.-6      	; 0x3e49c <main+0x230>
   3e4a2:	b3 01       	movw	r22, r6
   3e4a4:	a2 01       	movw	r20, r4
					
				do 
				{
					fLSByte = flashBuff[fMemIndex++];
					//fMemIndex++;
					asm volatile ("nop");
   3e4a6:	00 00       	nop
					fMSByte = flashBuff[fMemIndex++];
					//fMemIndex++;
					fDataWord = (fMSByte << 8) | fLSByte;
   3e4a8:	f1 01       	movw	r30, r2
   3e4aa:	81 81       	ldd	r24, Z+1	; 0x01
   3e4ac:	90 e0       	ldi	r25, 0x00	; 0
   3e4ae:	98 2f       	mov	r25, r24
   3e4b0:	88 27       	eor	r24, r24
   3e4b2:	20 81       	ld	r18, Z
   3e4b4:	82 2b       	or	r24, r18
						
					boot_page_fill_safe(ftempAddr,fDataWord);					
   3e4b6:	07 b6       	in	r0, 0x37	; 55
   3e4b8:	00 fc       	sbrc	r0, 0
   3e4ba:	fd cf       	rjmp	.-6      	; 0x3e4b6 <main+0x24a>
   3e4bc:	f9 99       	sbic	0x1f, 1	; 31
   3e4be:	fe cf       	rjmp	.-4      	; 0x3e4bc <main+0x250>
   3e4c0:	21 e0       	ldi	r18, 0x01	; 1
   3e4c2:	0c 01       	movw	r0, r24
   3e4c4:	fa 01       	movw	r30, r20
   3e4c6:	60 93 5b 00 	sts	0x005B, r22	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
   3e4ca:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e4ce:	e8 95       	spm
   3e4d0:	11 24       	eor	r1, r1
						
					ftempAddr  = ftempAddr + 2;
   3e4d2:	4e 5f       	subi	r20, 0xFE	; 254
   3e4d4:	5f 4f       	sbci	r21, 0xFF	; 255
   3e4d6:	6f 4f       	sbci	r22, 0xFF	; 255
   3e4d8:	7f 4f       	sbci	r23, 0xFF	; 255
					asm volatile ("nop");	
   3e4da:	00 00       	nop
   3e4dc:	32 e0       	ldi	r19, 0x02	; 2
   3e4de:	23 0e       	add	r2, r19
   3e4e0:	31 1c       	adc	r3, r1
					fMemSize = fMemSize - 2;
				} while (fMemSize);
   3e4e2:	cf 5f       	subi	r28, 0xFF	; 255
   3e4e4:	de 4f       	sbci	r29, 0xFE	; 254
   3e4e6:	88 81       	ld	r24, Y
   3e4e8:	99 81       	ldd	r25, Y+1	; 0x01
   3e4ea:	c1 50       	subi	r28, 0x01	; 1
   3e4ec:	d1 40       	sbci	r29, 0x01	; 1
   3e4ee:	82 15       	cp	r24, r2
   3e4f0:	93 05       	cpc	r25, r3
   3e4f2:	c9 f6       	brne	.-78     	; 0x3e4a6 <main+0x23a>
					
				boot_page_write_safe(fPageAddr);
   3e4f4:	07 b6       	in	r0, 0x37	; 55
   3e4f6:	00 fc       	sbrc	r0, 0
   3e4f8:	fd cf       	rjmp	.-6      	; 0x3e4f4 <main+0x288>
   3e4fa:	f9 99       	sbic	0x1f, 1	; 31
   3e4fc:	fe cf       	rjmp	.-4      	; 0x3e4fa <main+0x28e>
   3e4fe:	95 e0       	ldi	r25, 0x05	; 5
   3e500:	f2 01       	movw	r30, r4
   3e502:	60 92 5b 00 	sts	0x005B, r6	; 0x80005b <__TEXT_REGION_LENGTH__+0x70005b>
   3e506:	90 93 57 00 	sts	0x0057, r25	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e50a:	e8 95       	spm
				boot_spm_busy_wait();
   3e50c:	07 b6       	in	r0, 0x37	; 55
   3e50e:	00 fc       	sbrc	r0, 0
   3e510:	fd cf       	rjmp	.-6      	; 0x3e50c <main+0x2a0>
				boot_rww_enable_safe();
   3e512:	07 b6       	in	r0, 0x37	; 55
   3e514:	00 fc       	sbrc	r0, 0
   3e516:	fd cf       	rjmp	.-6      	; 0x3e512 <main+0x2a6>
   3e518:	f9 99       	sbic	0x1f, 1	; 31
   3e51a:	fe cf       	rjmp	.-4      	; 0x3e518 <main+0x2ac>
   3e51c:	e1 e1       	ldi	r30, 0x11	; 17
   3e51e:	e0 93 57 00 	sts	0x0057, r30	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e522:	e8 95       	spm
					
				fPageAddr += SPM_PAGESIZE;
				fDataAddr += EXMEM_PAGE_SIZE;
   3e524:	ff ef       	ldi	r31, 0xFF	; 255
   3e526:	df 1a       	sub	r13, r31
   3e528:	ef 0a       	sbc	r14, r31
   3e52a:	ff 0a       	sbc	r15, r31
				fCsumAddr += 2;
   3e52c:	22 e0       	ldi	r18, 0x02	; 2
   3e52e:	82 0e       	add	r8, r18
   3e530:	91 1c       	adc	r9, r1
   3e532:	a1 1c       	adc	r10, r1
   3e534:	b1 1c       	adc	r11, r1
				asm volatile ("nop");
   3e536:	00 00       	nop
				
				fDLenTemp--;
   3e538:	cd 5f       	subi	r28, 0xFD	; 253
   3e53a:	de 4f       	sbci	r29, 0xFE	; 254
   3e53c:	48 81       	ld	r20, Y
   3e53e:	59 81       	ldd	r21, Y+1	; 0x01
   3e540:	c3 50       	subi	r28, 0x03	; 3
   3e542:	d1 40       	sbci	r29, 0x01	; 1
   3e544:	41 50       	subi	r20, 0x01	; 1
   3e546:	51 09       	sbc	r21, r1
   3e548:	cd 5f       	subi	r28, 0xFD	; 253
   3e54a:	de 4f       	sbci	r29, 0xFE	; 254
   3e54c:	59 83       	std	Y+1, r21	; 0x01
   3e54e:	48 83       	st	Y, r20
   3e550:	c3 50       	subi	r28, 0x03	; 3
   3e552:	d1 40       	sbci	r29, 0x01	; 1
			} while (fDLenTemp);
   3e554:	45 2b       	or	r20, r21
   3e556:	09 f0       	breq	.+2      	; 0x3e55a <main+0x2ee>
   3e558:	2b cf       	rjmp	.-426    	; 0x3e3b0 <main+0x144>
				}
				
				fDLenTemp--;
			} while (fDLenTemp);
*/			
			tiny_delay();
   3e55a:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
			FLASH_EraseSector(fBStatAddr);						
   3e55e:	60 e0       	ldi	r22, 0x00	; 0
   3e560:	70 e1       	ldi	r23, 0x10	; 16
   3e562:	80 e0       	ldi	r24, 0x00	; 0
   3e564:	90 e0       	ldi	r25, 0x00	; 0
   3e566:	0f 94 f3 f0 	call	0x3e1e6	; 0x3e1e6 <FLASH_EraseSector>
		}
	}
	
	tiny_delay();
   3e56a:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
	
	boot_rww_enable_safe();				// enable application section
   3e56e:	07 b6       	in	r0, 0x37	; 55
   3e570:	00 fc       	sbrc	r0, 0
   3e572:	fd cf       	rjmp	.-6      	; 0x3e56e <main+0x302>
   3e574:	f9 99       	sbic	0x1f, 1	; 31
   3e576:	fe cf       	rjmp	.-4      	; 0x3e574 <main+0x308>
   3e578:	81 e1       	ldi	r24, 0x11	; 17
   3e57a:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x700057>
   3e57e:	e8 95       	spm

	// leaving bootloader  # bye bye # sayonara #
	asm volatile(
   3e580:	ee 27       	eor	r30, r30
   3e582:	ff 27       	eor	r31, r31
   3e584:	09 94       	ijmp
					"ijmp			\n\t"
				);
	
    for(;;)
    {		
		tiny_delay();
   3e586:	0f 94 a6 f0 	call	0x3e14c	; 0x3e14c <tiny_delay>
   3e58a:	fd cf       	rjmp	.-6      	; 0x3e586 <main+0x31a>

0003e58c <_exit>:
   3e58c:	f8 94       	cli

0003e58e <__stop_program>:
   3e58e:	ff cf       	rjmp	.-2      	; 0x3e58e <__stop_program>
