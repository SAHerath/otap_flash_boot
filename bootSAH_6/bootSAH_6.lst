   1               		.file	"bootSAH_6.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	SPI_Transfer:
  13               	.LFB11:
  14               		.file 1 "bootSAH_6.c"
   1:bootSAH_6.c   **** /*
   2:bootSAH_6.c   ****  * bootSAH_6.c
   3:bootSAH_6.c   ****  *
   4:bootSAH_6.c   ****  * Created: 19/09/13 12:52:32 PM
   5:bootSAH_6.c   ****  * Author : supun
   6:bootSAH_6.c   ****  */ 
   7:bootSAH_6.c   **** 
   8:bootSAH_6.c   **** #include	<inttypes.h>
   9:bootSAH_6.c   **** #include	<avr/io.h>
  10:bootSAH_6.c   **** #include	<avr/interrupt.h>
  11:bootSAH_6.c   **** #include	<avr/boot.h>
  12:bootSAH_6.c   **** #include	<avr/pgmspace.h>
  13:bootSAH_6.c   **** #include	<util/delay.h>
  14:bootSAH_6.c   **** #include	<avr/eeprom.h>
  15:bootSAH_6.c   **** #include	<avr/common.h>
  16:bootSAH_6.c   **** #include	<stdlib.h>
  17:bootSAH_6.c   **** 
  18:bootSAH_6.c   **** 
  19:bootSAH_6.c   **** #ifdef __AVR_ATmega2560__
  20:bootSAH_6.c   **** 	#define SPI_PORT	PORTB
  21:bootSAH_6.c   **** 	#define	SPI_DDR		DDRB
  22:bootSAH_6.c   **** 	#define	SPI_MISO	PB3
  23:bootSAH_6.c   **** 	#define	SPI_MOSI	PB2
  24:bootSAH_6.c   **** 	#define	SPI_SCK		PB1
  25:bootSAH_6.c   **** 	#define SPI_CS		PB0
  26:bootSAH_6.c   **** #endif
  27:bootSAH_6.c   **** 
  28:bootSAH_6.c   **** #define EXMEM_JEDEC		0xEF4017
  29:bootSAH_6.c   **** #define EXMEM_SECT_SIZE	4096		// bytes
  30:bootSAH_6.c   **** #define EXMEM_PAGE_SIZE 256			// bytes
  31:bootSAH_6.c   **** 
  32:bootSAH_6.c   **** #define BOOT_EROR_ADDR  256
  33:bootSAH_6.c   **** #define BOOT_STAT_ADDR  4096    // byte addr
  34:bootSAH_6.c   **** #define BOOT_CSUM_ADDR  4352    // byte addr
  35:bootSAH_6.c   **** #define BOOT_DATA_ADDR  8192    // byte addr
  36:bootSAH_6.c   **** 
  37:bootSAH_6.c   **** 
  38:bootSAH_6.c   **** 
  39:bootSAH_6.c   **** 
  40:bootSAH_6.c   **** /*
  41:bootSAH_6.c   ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
  42:bootSAH_6.c   ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
  43:bootSAH_6.c   ****  */
  44:bootSAH_6.c   **** //#define BOOTSIZE 1024
  45:bootSAH_6.c   **** #if FLASHEND > 0x0F000
  46:bootSAH_6.c   **** 	#define BOOTSIZE 8192
  47:bootSAH_6.c   **** #else
  48:bootSAH_6.c   **** 	#define BOOTSIZE 2048
  49:bootSAH_6.c   **** #endif
  50:bootSAH_6.c   **** 
  51:bootSAH_6.c   **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
  52:bootSAH_6.c   **** 
  53:bootSAH_6.c   **** 
  54:bootSAH_6.c   **** 
  55:bootSAH_6.c   **** /*
  56:bootSAH_6.c   ****  * function prototypes
  57:bootSAH_6.c   ****  */
  58:bootSAH_6.c   **** void delay_ms(unsigned int timedelay);
  59:bootSAH_6.c   **** void tiny_delay(void);		
  60:bootSAH_6.c   **** static uint8_t SPI_Transfer(uint8_t spidata);
  61:bootSAH_6.c   **** void FLASH_UntilReady(void);
  62:bootSAH_6.c   **** void FLASH_ResetEnable(void);
  63:bootSAH_6.c   **** void FLASH_Reset(void);
  64:bootSAH_6.c   **** void FLASH_WriteEnable(void);
  65:bootSAH_6.c   **** uint16_t FLASH_ReadWord(uint32_t faddr);
  66:bootSAH_6.c   **** void FLASH_EraseSector(uint32_t faddr);
  67:bootSAH_6.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata);
  68:bootSAH_6.c   **** 
  69:bootSAH_6.c   **** /*
  70:bootSAH_6.c   ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
  71:bootSAH_6.c   ****  * to reduce the code size, we need to provide our own initialization
  72:bootSAH_6.c   ****  */
  73:bootSAH_6.c   **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
  74:bootSAH_6.c   **** #include <avr/sfr_defs.h>
  75:bootSAH_6.c   **** 
  76:bootSAH_6.c   **** 
  77:bootSAH_6.c   **** static uint8_t SPI_Transfer(uint8_t spidata)
  78:bootSAH_6.c   **** {
  15               		.loc 1 78 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  79:bootSAH_6.c   **** 	SPDR = spidata;
  22               		.loc 1 79 0
  23 0000 8EBD      		out 0x2e,r24
  80:bootSAH_6.c   **** 	asm volatile("nop");			// small delay
  24               		.loc 1 80 0
  25               	/* #APP */
  26               	 ;  80 "bootSAH_6.c" 1
  27 0002 0000      		nop
  28               	 ;  0 "" 2
  29               	/* #NOAPP */
  30               	.L2:
  81:bootSAH_6.c   **** 	while(!(SPSR & (1<<SPIF)));		// Wait for transmission complete
  31               		.loc 1 81 0 discriminator 1
  32 0004 0DB4      		in __tmp_reg__,0x2d
  33 0006 07FE      		sbrs __tmp_reg__,7
  34 0008 00C0      		rjmp .L2
  82:bootSAH_6.c   **** 
  83:bootSAH_6.c   **** 	return SPDR;
  35               		.loc 1 83 0
  36 000a 8EB5      		in r24,0x2e
  37               	.LVL1:
  84:bootSAH_6.c   **** }
  38               		.loc 1 84 0
  39 000c 0895      		ret
  40               		.cfi_endproc
  41               	.LFE11:
  43               		.section	.init9,"ax",@progbits
  44               	.global	__jumpMain
  46               	__jumpMain:
  47               	.LFB12:
  85:bootSAH_6.c   **** 
  86:bootSAH_6.c   **** //*****************************************************************************
  87:bootSAH_6.c   **** void __jumpMain(void)
  88:bootSAH_6.c   **** {
  48               		.loc 1 88 0
  49               		.cfi_startproc
  50               	/* prologue: naked */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
  89:bootSAH_6.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  90:bootSAH_6.c   **** //*	the first line did not do the job on the ATmega128
  91:bootSAH_6.c   **** 
  92:bootSAH_6.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
  54               		.loc 1 92 0
  55               	/* #APP */
  56               	 ;  92 "bootSAH_6.c" 1
  57               		.set __stack, 8703
  58               	 ;  0 "" 2
  93:bootSAH_6.c   **** 
  94:bootSAH_6.c   **** //*	set stack pointer to top of RAM
  95:bootSAH_6.c   **** 
  96:bootSAH_6.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
  59               		.loc 1 96 0
  60               	 ;  96 "bootSAH_6.c" 1
  61 0000 01E2      		ldi	16, 33
  62               	 ;  0 "" 2
  97:bootSAH_6.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  63               		.loc 1 97 0
  64               	 ;  97 "bootSAH_6.c" 1
  65 0002 0EBF      		out 62,16
  66               	 ;  0 "" 2
  98:bootSAH_6.c   **** 
  99:bootSAH_6.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
  67               		.loc 1 99 0
  68               	 ;  99 "bootSAH_6.c" 1
  69 0004 0FEF      		ldi	16, 255
  70               	 ;  0 "" 2
 100:bootSAH_6.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  71               		.loc 1 100 0
  72               	 ;  100 "bootSAH_6.c" 1
  73 0006 0DBF      		out 61,16
  74               	 ;  0 "" 2
 101:bootSAH_6.c   **** 
 102:bootSAH_6.c   **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
  75               		.loc 1 102 0
  76               	 ;  102 "bootSAH_6.c" 1
  77 0008 1124      		clr __zero_reg__
  78               	 ;  0 "" 2
 103:bootSAH_6.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  79               		.loc 1 103 0
  80               	 ;  103 "bootSAH_6.c" 1
  81 000a 1FBE      		out 63, __zero_reg__
  82               	 ;  0 "" 2
 104:bootSAH_6.c   **** 	asm volatile ( "jmp main");												// jump to main()
  83               		.loc 1 104 0
  84               	 ;  104 "bootSAH_6.c" 1
  85 000c 0C94 0000 		jmp main
  86               	 ;  0 "" 2
  87               	/* epilogue start */
 105:bootSAH_6.c   **** }
  88               		.loc 1 105 0
  89               	/* #NOAPP */
  90               		.cfi_endproc
  91               	.LFE12:
  93               		.text
  94               	.global	delay_ms
  96               	delay_ms:
  97               	.LFB14:
 106:bootSAH_6.c   **** 
 107:bootSAH_6.c   **** //*	for watch dog timer startup
 108:bootSAH_6.c   **** void (*app_start)(void) = 0x0000;
 109:bootSAH_6.c   **** 
 110:bootSAH_6.c   **** 
 111:bootSAH_6.c   **** int main(void)
 112:bootSAH_6.c   **** {
 113:bootSAH_6.c   **** 	uint32_t fMemStatus = 0;
 114:bootSAH_6.c   **** 	
 115:bootSAH_6.c   **** 	uint32_t fBStatAddr = 0;
 116:bootSAH_6.c   **** 	uint16_t fBootStat  = 0;
 117:bootSAH_6.c   **** 	
 118:bootSAH_6.c   **** 	uint32_t fDLenAddr  = 0;
 119:bootSAH_6.c   **** 	uint16_t fDataLen   = 0;
 120:bootSAH_6.c   **** 	uint16_t fDLenTemp	= 0;
 121:bootSAH_6.c   **** 	
 122:bootSAH_6.c   **** 	uint32_t fDataAddr  = 0;
 123:bootSAH_6.c   **** 	uint8_t  fRdData    = 0;
 124:bootSAH_6.c   **** 	
 125:bootSAH_6.c   **** 	uint32_t fCsumAddr  = 0;
 126:bootSAH_6.c   **** 	uint16_t fChSumCal  = 0;
 127:bootSAH_6.c   **** 	uint16_t fChSumRev  = 0;
 128:bootSAH_6.c   **** 	
 129:bootSAH_6.c   **** 	uint32_t ftempAddr	= 0;
 130:bootSAH_6.c   **** 	uint32_t fPageAddr  = 0;
 131:bootSAH_6.c   **** 	
 132:bootSAH_6.c   **** 	uint8_t flashBuff[256];
 133:bootSAH_6.c   **** 	
 134:bootSAH_6.c   **** 	uint8_t  fLSByte, fMSByte;
 135:bootSAH_6.c   **** 	uint16_t fDataWord;
 136:bootSAH_6.c   **** 	uint16_t fMemSize;
 137:bootSAH_6.c   **** 	uint16_t fMemIndex;
 138:bootSAH_6.c   **** 		
 139:bootSAH_6.c   **** 		
 140:bootSAH_6.c   **** 
 141:bootSAH_6.c   **** //************************************************************************
 142:bootSAH_6.c   **** 	
 143:bootSAH_6.c   **** 	//*	some chips dont set the stack properly
 144:bootSAH_6.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 145:bootSAH_6.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 146:bootSAH_6.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 147:bootSAH_6.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 148:bootSAH_6.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 149:bootSAH_6.c   **** 	
 150:bootSAH_6.c   **** //************************************************************************
 151:bootSAH_6.c   **** 
 152:bootSAH_6.c   **** //*	handle the watch dog timer
 153:bootSAH_6.c   **** 	uint8_t	mcuStatusReg;
 154:bootSAH_6.c   **** 	mcuStatusReg	=	MCUSR;
 155:bootSAH_6.c   **** 
 156:bootSAH_6.c   **** 	__asm__ __volatile__ ("cli");
 157:bootSAH_6.c   **** 	__asm__ __volatile__ ("wdr");
 158:bootSAH_6.c   **** 	//MCUSR	=	0;
 159:bootSAH_6.c   **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 160:bootSAH_6.c   **** 	WDTCSR	=	0;
 161:bootSAH_6.c   **** 	__asm__ __volatile__ ("sei");
 162:bootSAH_6.c   **** 	// check if WDT generated the reset, if so, go straight to app
 163:bootSAH_6.c   **** 	if (mcuStatusReg & _BV(WDRF))
 164:bootSAH_6.c   **** 	{
 165:bootSAH_6.c   **** 		app_start();
 166:bootSAH_6.c   **** 	}
 167:bootSAH_6.c   **** 	
 168:bootSAH_6.c   **** //************************************************************************
 169:bootSAH_6.c   **** 
 170:bootSAH_6.c   **** //* Init SPI
 171:bootSAH_6.c   **** 	SPI_DDR = (	(0<<SPI_MISO)|
 172:bootSAH_6.c   **** 				(1<<SPI_MOSI)|
 173:bootSAH_6.c   **** 				(1<<SPI_SCK) |
 174:bootSAH_6.c   **** 				(1<<SPI_CS)
 175:bootSAH_6.c   **** 			  );
 176:bootSAH_6.c   **** 
 177:bootSAH_6.c   **** 	SPCR = (	(1<<SPE) |              // SPI Enable
 178:bootSAH_6.c   **** 				(0<<SPIE)|              // SPI Interupt Enable
 179:bootSAH_6.c   **** 				(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
 180:bootSAH_6.c   **** 				(1<<MSTR)|              // Master/Slave select
 181:bootSAH_6.c   **** 				(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
 182:bootSAH_6.c   **** 				(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
 183:bootSAH_6.c   **** 				(0<<CPHA)               // Clock Phase (0:leading / 1:trailing edge sampling)
 184:bootSAH_6.c   **** 			);
 185:bootSAH_6.c   **** 			
 186:bootSAH_6.c   **** 	SPI_PORT |=  (1<<SPI_CS); 			// pull high
 187:bootSAH_6.c   **** 	
 188:bootSAH_6.c   **** 	asm volatile ("nop");				// wait until port has changed
 189:bootSAH_6.c   **** 	
 190:bootSAH_6.c   **** //************************************************************************
 191:bootSAH_6.c   **** 
 192:bootSAH_6.c   **** 	fBStatAddr = 4096;
 193:bootSAH_6.c   **** 	fDLenAddr  = 4098;
 194:bootSAH_6.c   **** 	fDataAddr  = 8192;
 195:bootSAH_6.c   **** 	fCsumAddr  = 4352;
 196:bootSAH_6.c   **** 	fPageAddr  = 0;
 197:bootSAH_6.c   **** 	
 198:bootSAH_6.c   **** //************************************************************************	
 199:bootSAH_6.c   **** //* Init ExFlash
 200:bootSAH_6.c   **** 	FLASH_UntilReady();
 201:bootSAH_6.c   **** 	FLASH_ResetEnable();
 202:bootSAH_6.c   **** 	FLASH_Reset();
 203:bootSAH_6.c   **** 	
 204:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 205:bootSAH_6.c   **** 	SPI_Transfer(0x9F);
 206:bootSAH_6.c   **** 	fMemStatus = (uint32_t)SPI_Transfer(0) << 16;
 207:bootSAH_6.c   **** 	fMemStatus |= (uint32_t)SPI_Transfer(0) << 8;
 208:bootSAH_6.c   **** 	fMemStatus |= (uint32_t)SPI_Transfer(0);
 209:bootSAH_6.c   **** 	SPI_PORT |=  (1<<SPI_CS);
 210:bootSAH_6.c   **** 
 211:bootSAH_6.c   **** 	if(fMemStatus == EXMEM_JEDEC)
 212:bootSAH_6.c   **** 	{
 213:bootSAH_6.c   **** 		SPI_PORT  &=  ~(1<<SPI_CS);
 214:bootSAH_6.c   **** 		SPI_Transfer(0x03);
 215:bootSAH_6.c   **** 		SPI_Transfer((fBStatAddr >> 16) & 0xff);
 216:bootSAH_6.c   **** 		SPI_Transfer((fBStatAddr >> 8) & 0xff);
 217:bootSAH_6.c   **** 		SPI_Transfer(fBStatAddr & 0xff);
 218:bootSAH_6.c   **** 		fBootStat = (uint16_t)SPI_Transfer(0) << 8;
 219:bootSAH_6.c   **** 		fBootStat |= (uint16_t)SPI_Transfer(0);
 220:bootSAH_6.c   **** 		SPI_PORT  |=   (1<<SPI_CS);
 221:bootSAH_6.c   **** 		tiny_delay();
 222:bootSAH_6.c   **** 
 223:bootSAH_6.c   **** 
 224:bootSAH_6.c   **** 		if(fBootStat == 0x2323)
 225:bootSAH_6.c   **** 		{
 226:bootSAH_6.c   **** 			
 227:bootSAH_6.c   **** 			SPI_PORT  &=  ~(1<<SPI_CS);
 228:bootSAH_6.c   **** 			SPI_Transfer(0x03);
 229:bootSAH_6.c   **** 			SPI_Transfer((fDLenAddr >> 16) & 0xff);
 230:bootSAH_6.c   **** 			SPI_Transfer((fDLenAddr >> 8) & 0xff);
 231:bootSAH_6.c   **** 			SPI_Transfer(fDLenAddr & 0xff);
 232:bootSAH_6.c   **** 			fDataLen = (uint16_t)SPI_Transfer(0) << 8;
 233:bootSAH_6.c   **** 			fDataLen |= (uint16_t)SPI_Transfer(0);
 234:bootSAH_6.c   **** 			SPI_PORT  |=   (1<<SPI_CS);
 235:bootSAH_6.c   **** 			tiny_delay();
 236:bootSAH_6.c   **** 			
 237:bootSAH_6.c   **** 			fDLenTemp = fDataLen;
 238:bootSAH_6.c   **** 
 239:bootSAH_6.c   **** 			do 
 240:bootSAH_6.c   **** 			{
 241:bootSAH_6.c   **** 				
 242:bootSAH_6.c   **** 				fMemSize = EXMEM_PAGE_SIZE;
 243:bootSAH_6.c   **** 				fMemIndex = 0;
 244:bootSAH_6.c   **** 				//fRdTries  = 0;
 245:bootSAH_6.c   **** 				fChSumCal = 0;
 246:bootSAH_6.c   **** 				SPI_PORT  &=  ~(1<<SPI_CS);
 247:bootSAH_6.c   **** 				SPI_Transfer(0x03);
 248:bootSAH_6.c   **** 				SPI_Transfer((fDataAddr >> 16) & 0xff);
 249:bootSAH_6.c   **** 				SPI_Transfer((fDataAddr >> 8) & 0xff);
 250:bootSAH_6.c   **** 				SPI_Transfer(fDataAddr & 0xff);			
 251:bootSAH_6.c   **** 				do 
 252:bootSAH_6.c   **** 				{
 253:bootSAH_6.c   **** 					fRdData = SPI_Transfer(0);
 254:bootSAH_6.c   **** 					flashBuff[fMemIndex++] = fRdData;
 255:bootSAH_6.c   **** 					fChSumCal += fRdData;				
 256:bootSAH_6.c   **** 					fMemSize--;
 257:bootSAH_6.c   **** 				} while (fMemSize);		
 258:bootSAH_6.c   **** 				SPI_PORT  |=   (1<<SPI_CS);
 259:bootSAH_6.c   **** 				tiny_delay();
 260:bootSAH_6.c   **** 
 261:bootSAH_6.c   **** 		
 262:bootSAH_6.c   **** 				SPI_PORT  &=  ~(1<<SPI_CS);
 263:bootSAH_6.c   **** 				SPI_Transfer(0x03);
 264:bootSAH_6.c   **** 				SPI_Transfer((fCsumAddr >> 16) & 0xff);
 265:bootSAH_6.c   **** 				SPI_Transfer((fCsumAddr >> 8) & 0xff);
 266:bootSAH_6.c   **** 				SPI_Transfer(fCsumAddr & 0xff);				
 267:bootSAH_6.c   **** 				fChSumRev = (uint16_t)SPI_Transfer(0) << 8;
 268:bootSAH_6.c   **** 				fChSumRev |= (uint16_t)SPI_Transfer(0);			
 269:bootSAH_6.c   **** 				SPI_PORT  |=   (1<<SPI_CS);
 270:bootSAH_6.c   **** 				tiny_delay();
 271:bootSAH_6.c   **** 		
 272:bootSAH_6.c   **** 				if(fChSumRev != fChSumCal)
 273:bootSAH_6.c   **** 				{
 274:bootSAH_6.c   **** 					//todo: flash write error msg
 275:bootSAH_6.c   **** 					break;
 276:bootSAH_6.c   **** 				}
 277:bootSAH_6.c   **** 				
 278:bootSAH_6.c   ****  				ftempAddr  = fPageAddr;
 279:bootSAH_6.c   ****  				fMemSize = SPM_PAGESIZE;
 280:bootSAH_6.c   ****  				fMemIndex  = 0;
 281:bootSAH_6.c   **** 				 
 282:bootSAH_6.c   **** 				if (fPageAddr >= APP_END )
 283:bootSAH_6.c   **** 				{
 284:bootSAH_6.c   **** 					//todo: flash write error msg
 285:bootSAH_6.c   **** 					break;
 286:bootSAH_6.c   **** 				}
 287:bootSAH_6.c   **** 					
 288:bootSAH_6.c   **** 				boot_page_erase_safe(fPageAddr);
 289:bootSAH_6.c   **** 				boot_spm_busy_wait();			
 290:bootSAH_6.c   **** 					
 291:bootSAH_6.c   **** 				do 
 292:bootSAH_6.c   **** 				{
 293:bootSAH_6.c   **** 					fLSByte = flashBuff[fMemIndex++];
 294:bootSAH_6.c   **** 					//fMemIndex++;
 295:bootSAH_6.c   **** 					asm volatile ("nop");
 296:bootSAH_6.c   **** 					fMSByte = flashBuff[fMemIndex++];
 297:bootSAH_6.c   **** 					//fMemIndex++;
 298:bootSAH_6.c   **** 					fDataWord = (fMSByte << 8) | fLSByte;
 299:bootSAH_6.c   **** 						
 300:bootSAH_6.c   **** 					boot_page_fill_safe(ftempAddr,fDataWord);					
 301:bootSAH_6.c   **** 						
 302:bootSAH_6.c   **** 					ftempAddr  = ftempAddr + 2;
 303:bootSAH_6.c   **** 					asm volatile ("nop");	
 304:bootSAH_6.c   **** 					fMemSize = fMemSize - 2;
 305:bootSAH_6.c   **** 				} while (fMemSize);
 306:bootSAH_6.c   **** 					
 307:bootSAH_6.c   **** 				boot_page_write_safe(fPageAddr);
 308:bootSAH_6.c   **** 				boot_spm_busy_wait();
 309:bootSAH_6.c   **** 				boot_rww_enable_safe();
 310:bootSAH_6.c   **** 					
 311:bootSAH_6.c   **** 				fPageAddr += SPM_PAGESIZE;
 312:bootSAH_6.c   **** 				fDataAddr += EXMEM_PAGE_SIZE;
 313:bootSAH_6.c   **** 				fCsumAddr += 2;
 314:bootSAH_6.c   **** 				asm volatile ("nop");
 315:bootSAH_6.c   **** 				
 316:bootSAH_6.c   **** 				fDLenTemp--;
 317:bootSAH_6.c   **** 			} while (fDLenTemp);
 318:bootSAH_6.c   **** 			
 319:bootSAH_6.c   **** /*			
 320:bootSAH_6.c   **** 			//todo: read and verify
 321:bootSAH_6.c   **** 			fDLenTemp = fDataLen;
 322:bootSAH_6.c   **** 			fPageAddr = 0;
 323:bootSAH_6.c   **** 			
 324:bootSAH_6.c   **** 			do 
 325:bootSAH_6.c   **** 			{
 326:bootSAH_6.c   **** 				fInMemSize = SPM_PAGESIZE;
 327:bootSAH_6.c   **** 				fChSumCal = 0;
 328:bootSAH_6.c   **** 				do
 329:bootSAH_6.c   **** 				{
 330:bootSAH_6.c   **** 					fDataWord	=	pgm_read_word_far(fPageAddr);
 331:bootSAH_6.c   **** 					fLSByte = (uint8_t)(fDataWord & 0xff);
 332:bootSAH_6.c   **** 					fMSByte = (uint8_t)(fDataWord >> 8);
 333:bootSAH_6.c   **** 
 334:bootSAH_6.c   **** 					fChSumCal += fLSByte;
 335:bootSAH_6.c   **** 					asm volatile ("nop");
 336:bootSAH_6.c   **** 					fChSumCal += fMSByte;
 337:bootSAH_6.c   **** 					
 338:bootSAH_6.c   **** 					fInMemSize = fInMemSize - 2;
 339:bootSAH_6.c   **** 				} while (fInMemSize);
 340:bootSAH_6.c   **** 				
 341:bootSAH_6.c   **** 				
 342:bootSAH_6.c   **** 				//todo: receive checksum again
 343:bootSAH_6.c   **** 				
 344:bootSAH_6.c   **** 				if(fChSumRev != fChSumCal)
 345:bootSAH_6.c   **** 				{
 346:bootSAH_6.c   **** 					//todo: flash write error msg
 347:bootSAH_6.c   **** 					break;
 348:bootSAH_6.c   **** 				}
 349:bootSAH_6.c   **** 				
 350:bootSAH_6.c   **** 				fDLenTemp--;
 351:bootSAH_6.c   **** 			} while (fDLenTemp);
 352:bootSAH_6.c   **** */			
 353:bootSAH_6.c   **** 			tiny_delay();
 354:bootSAH_6.c   **** 			FLASH_EraseSector(fBStatAddr);						
 355:bootSAH_6.c   **** 		}
 356:bootSAH_6.c   **** 	}
 357:bootSAH_6.c   **** 	
 358:bootSAH_6.c   **** 	tiny_delay();
 359:bootSAH_6.c   **** 	
 360:bootSAH_6.c   **** 	boot_rww_enable_safe();				// enable application section
 361:bootSAH_6.c   **** 
 362:bootSAH_6.c   **** 	// leaving bootloader  # bye bye # sayonara #
 363:bootSAH_6.c   **** 	asm volatile(
 364:bootSAH_6.c   **** 					"clr	r30		\n\t"
 365:bootSAH_6.c   **** 					"clr	r31		\n\t"
 366:bootSAH_6.c   **** 					"ijmp			\n\t"
 367:bootSAH_6.c   **** 				);
 368:bootSAH_6.c   **** 	
 369:bootSAH_6.c   ****     for(;;)
 370:bootSAH_6.c   ****     {		
 371:bootSAH_6.c   **** 		tiny_delay();
 372:bootSAH_6.c   ****     }
 373:bootSAH_6.c   **** }
 374:bootSAH_6.c   **** 
 375:bootSAH_6.c   **** 
 376:bootSAH_6.c   **** 
 377:bootSAH_6.c   **** 
 378:bootSAH_6.c   **** //*****************************************************************************
 379:bootSAH_6.c   **** void delay_ms(unsigned int timedelay)
 380:bootSAH_6.c   **** {
  98               		.loc 1 380 0
  99               		.cfi_startproc
 100               	.LVL2:
 101               	/* prologue: function */
 102               	/* frame size = 0 */
 103               	/* stack size = 0 */
 104               	.L__stack_usage = 0
 381:bootSAH_6.c   **** 	unsigned int i;
 382:bootSAH_6.c   **** 	for (i=0;i<timedelay;i++)
 105               		.loc 1 382 0
 106 000e 20E0      		ldi r18,0
 107 0010 30E0      		ldi r19,0
 108               	.LVL3:
 109               	.L7:
 110               		.loc 1 382 0 is_stmt 0 discriminator 1
 111 0012 2817      		cp r18,r24
 112 0014 3907      		cpc r19,r25
 113 0016 01F0      		breq .L9
 114               	.LVL4:
 115               	.LBB4:
 116               	.LBB5:
 117               		.file 2 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ut
   1:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 118               		.loc 2 187 0 is_stmt 1
 119 0018 EFEC      		ldi r30,lo8(1999)
 120 001a F7E0      		ldi r31,hi8(1999)
 121 001c 3197      	1:	sbiw r30,1
 122 001e 01F4      		brne 1b
 123 0020 00C0      		rjmp .
 124 0022 0000      		nop
 125               	.LVL5:
 126               	.LBE5:
 127               	.LBE4:
 128               		.loc 1 382 0
 129 0024 2F5F      		subi r18,-1
 130 0026 3F4F      		sbci r19,-1
 131               	.LVL6:
 132 0028 00C0      		rjmp .L7
 133               	.L9:
 134               	/* epilogue start */
 383:bootSAH_6.c   **** 	{
 384:bootSAH_6.c   **** 		_delay_ms(0.5);
 385:bootSAH_6.c   **** 	}
 386:bootSAH_6.c   **** }
 135               		.loc 1 386 0
 136 002a 0895      		ret
 137               		.cfi_endproc
 138               	.LFE14:
 140               	.global	tiny_delay
 142               	tiny_delay:
 143               	.LFB15:
 387:bootSAH_6.c   **** //** small delay
 388:bootSAH_6.c   **** void tiny_delay()		
 389:bootSAH_6.c   **** {
 144               		.loc 1 389 0
 145               		.cfi_startproc
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148               	/* stack size = 0 */
 149               	.L__stack_usage = 0
 390:bootSAH_6.c   **** 	asm volatile(
 150               		.loc 1 390 0
 151               	/* #APP */
 152               	 ;  390 "bootSAH_6.c" 1
 153 002c 0000      		nop	
 154 002e 0000      		nop	
 155 0030 0000      		nop	
 156 0032 0000      		nop	
 157 0034 0000      		nop	
 158               		
 159               	 ;  0 "" 2
 160               	/* #NOAPP */
 161 0036 0895      		ret
 162               		.cfi_endproc
 163               	.LFE15:
 165               	.global	FLASH_UntilReady
 167               	FLASH_UntilReady:
 168               	.LFB16:
 391:bootSAH_6.c   **** 					"nop	\n\t"
 392:bootSAH_6.c   **** 					"nop	\n\t"
 393:bootSAH_6.c   **** 					"nop	\n\t"
 394:bootSAH_6.c   **** 					"nop	\n\t"
 395:bootSAH_6.c   **** 					"nop	\n\t"
 396:bootSAH_6.c   **** 				); 
 397:bootSAH_6.c   **** }
 398:bootSAH_6.c   ****    
 399:bootSAH_6.c   **** 
 400:bootSAH_6.c   **** //*****************************************************************************
 401:bootSAH_6.c   **** 
 402:bootSAH_6.c   **** 
 403:bootSAH_6.c   **** 
 404:bootSAH_6.c   **** //************************************************************************
 405:bootSAH_6.c   **** 
 406:bootSAH_6.c   **** 
 407:bootSAH_6.c   **** void FLASH_UntilReady()
 408:bootSAH_6.c   **** {
 169               		.loc 1 408 0
 170               		.cfi_startproc
 171               	/* prologue: function */
 172               	/* frame size = 0 */
 173               	/* stack size = 0 */
 174               	.L__stack_usage = 0
 175               	.LVL7:
 409:bootSAH_6.c   **** 	uint8_t stat=0xff;
 410:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 176               		.loc 1 410 0
 177 0038 2898      		cbi 0x5,0
 411:bootSAH_6.c   **** 	SPI_Transfer(0x05);
 178               		.loc 1 411 0
 179 003a 85E0      		ldi r24,lo8(5)
 180 003c 0E94 0000 		call SPI_Transfer
 181               	.LVL8:
 409:bootSAH_6.c   **** 	uint8_t stat=0xff;
 182               		.loc 1 409 0
 183 0040 8FEF      		ldi r24,lo8(-1)
 184               	.LVL9:
 185               	.L12:
 412:bootSAH_6.c   **** 	while((stat & 0x01) == 0x01)
 186               		.loc 1 412 0
 187 0042 80FF      		sbrs r24,0
 188 0044 00C0      		rjmp .L14
 413:bootSAH_6.c   **** 	{
 414:bootSAH_6.c   **** 		stat = SPI_Transfer(0);
 189               		.loc 1 414 0
 190 0046 80E0      		ldi r24,0
 191 0048 0E94 0000 		call SPI_Transfer
 192               	.LVL10:
 193 004c 00C0      		rjmp .L12
 194               	.LVL11:
 195               	.L14:
 415:bootSAH_6.c   **** 	}
 416:bootSAH_6.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 196               		.loc 1 416 0
 197 004e 289A      		sbi 0x5,0
 417:bootSAH_6.c   **** 	tiny_delay();
 198               		.loc 1 417 0
 199 0050 0C94 0000 		jmp tiny_delay
 200               	.LVL12:
 201               		.cfi_endproc
 202               	.LFE16:
 204               	.global	FLASH_ResetEnable
 206               	FLASH_ResetEnable:
 207               	.LFB17:
 418:bootSAH_6.c   **** }
 419:bootSAH_6.c   **** 
 420:bootSAH_6.c   **** void FLASH_ResetEnable()
 421:bootSAH_6.c   **** {
 208               		.loc 1 421 0
 209               		.cfi_startproc
 210               	/* prologue: function */
 211               	/* frame size = 0 */
 212               	/* stack size = 0 */
 213               	.L__stack_usage = 0
 422:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 214               		.loc 1 422 0
 215 0054 2898      		cbi 0x5,0
 423:bootSAH_6.c   **** 	SPI_Transfer(0x66);
 216               		.loc 1 423 0
 217 0056 86E6      		ldi r24,lo8(102)
 218 0058 0E94 0000 		call SPI_Transfer
 219               	.LVL13:
 424:bootSAH_6.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 220               		.loc 1 424 0
 221 005c 289A      		sbi 0x5,0
 425:bootSAH_6.c   **** 	tiny_delay();
 222               		.loc 1 425 0
 223 005e 0C94 0000 		jmp tiny_delay
 224               	.LVL14:
 225               		.cfi_endproc
 226               	.LFE17:
 228               	.global	FLASH_Reset
 230               	FLASH_Reset:
 231               	.LFB18:
 426:bootSAH_6.c   **** }
 427:bootSAH_6.c   **** 
 428:bootSAH_6.c   **** void FLASH_Reset()
 429:bootSAH_6.c   **** {
 232               		.loc 1 429 0
 233               		.cfi_startproc
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
 430:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 238               		.loc 1 430 0
 239 0062 2898      		cbi 0x5,0
 431:bootSAH_6.c   **** 	SPI_Transfer(0x99);
 240               		.loc 1 431 0
 241 0064 89E9      		ldi r24,lo8(-103)
 242 0066 0E94 0000 		call SPI_Transfer
 243               	.LVL15:
 432:bootSAH_6.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 244               		.loc 1 432 0
 245 006a 289A      		sbi 0x5,0
 433:bootSAH_6.c   **** 	tiny_delay();
 246               		.loc 1 433 0
 247 006c 0C94 0000 		jmp tiny_delay
 248               	.LVL16:
 249               		.cfi_endproc
 250               	.LFE18:
 252               	.global	FLASH_WriteEnable
 254               	FLASH_WriteEnable:
 255               	.LFB19:
 434:bootSAH_6.c   **** }
 435:bootSAH_6.c   **** 
 436:bootSAH_6.c   **** void FLASH_WriteEnable()
 437:bootSAH_6.c   **** {
 256               		.loc 1 437 0
 257               		.cfi_startproc
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 0 */
 261               	.L__stack_usage = 0
 438:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 262               		.loc 1 438 0
 263 0070 2898      		cbi 0x5,0
 439:bootSAH_6.c   **** 	SPI_Transfer(0x06);
 264               		.loc 1 439 0
 265 0072 86E0      		ldi r24,lo8(6)
 266 0074 0E94 0000 		call SPI_Transfer
 267               	.LVL17:
 440:bootSAH_6.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 268               		.loc 1 440 0
 269 0078 289A      		sbi 0x5,0
 441:bootSAH_6.c   **** 	tiny_delay();
 270               		.loc 1 441 0
 271 007a 0C94 0000 		jmp tiny_delay
 272               	.LVL18:
 273               		.cfi_endproc
 274               	.LFE19:
 276               	.global	FLASH_ReadWord
 278               	FLASH_ReadWord:
 279               	.LFB20:
 442:bootSAH_6.c   **** }
 443:bootSAH_6.c   **** 
 444:bootSAH_6.c   **** uint16_t FLASH_ReadWord(uint32_t faddr)
 445:bootSAH_6.c   **** {
 280               		.loc 1 445 0
 281               		.cfi_startproc
 282               	.LVL19:
 283 007e 1F93      		push r17
 284               	.LCFI0:
 285               		.cfi_def_cfa_offset 4
 286               		.cfi_offset 17, -3
 287 0080 CF93      		push r28
 288               	.LCFI1:
 289               		.cfi_def_cfa_offset 5
 290               		.cfi_offset 28, -4
 291 0082 DF93      		push r29
 292               	.LCFI2:
 293               		.cfi_def_cfa_offset 6
 294               		.cfi_offset 29, -5
 295               	/* prologue: function */
 296               	/* frame size = 0 */
 297               	/* stack size = 3 */
 298               	.L__stack_usage = 3
 299 0084 EB01      		movw r28,r22
 300 0086 182F      		mov r17,r24
 301               	.LVL20:
 446:bootSAH_6.c   **** 	uint16_t temp1=0, temp2=0;
 447:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 302               		.loc 1 447 0
 303 0088 2898      		cbi 0x5,0
 448:bootSAH_6.c   **** 	SPI_Transfer(0x03);
 304               		.loc 1 448 0
 305 008a 83E0      		ldi r24,lo8(3)
 306 008c 0E94 0000 		call SPI_Transfer
 307               	.LVL21:
 449:bootSAH_6.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 308               		.loc 1 449 0
 309 0090 812F      		mov r24,r17
 310 0092 0E94 0000 		call SPI_Transfer
 311               	.LVL22:
 450:bootSAH_6.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 312               		.loc 1 450 0
 313 0096 8D2F      		mov r24,r29
 314 0098 0E94 0000 		call SPI_Transfer
 315               	.LVL23:
 451:bootSAH_6.c   **** 	SPI_Transfer(faddr & 0xff);
 316               		.loc 1 451 0
 317 009c 8C2F      		mov r24,r28
 318 009e 0E94 0000 		call SPI_Transfer
 319               	.LVL24:
 452:bootSAH_6.c   **** 	temp1 = SPI_Transfer(0);
 320               		.loc 1 452 0
 321 00a2 80E0      		ldi r24,0
 322 00a4 0E94 0000 		call SPI_Transfer
 323               	.LVL25:
 324 00a8 D82F      		mov r29,r24
 325               	.LVL26:
 453:bootSAH_6.c   **** 	temp2 = SPI_Transfer(0);
 326               		.loc 1 453 0
 327 00aa 80E0      		ldi r24,0
 328               	.LVL27:
 329 00ac 0E94 0000 		call SPI_Transfer
 330               	.LVL28:
 331 00b0 C82F      		mov r28,r24
 332               	.LVL29:
 454:bootSAH_6.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 333               		.loc 1 454 0
 334 00b2 289A      		sbi 0x5,0
 455:bootSAH_6.c   **** 	tiny_delay();
 335               		.loc 1 455 0
 336 00b4 0E94 0000 		call tiny_delay
 337               	.LVL30:
 456:bootSAH_6.c   **** 				
 457:bootSAH_6.c   **** 	return ((temp1 << 8) | (temp2 & 0x00ff));
 338               		.loc 1 457 0
 339 00b8 8C2F      		mov r24,r28
 340 00ba 90E0      		ldi r25,0
 458:bootSAH_6.c   **** }
 341               		.loc 1 458 0
 342 00bc 9D2B      		or r25,r29
 343               	/* epilogue start */
 344 00be DF91      		pop r29
 345               	.LVL31:
 346 00c0 CF91      		pop r28
 347               	.LVL32:
 348 00c2 1F91      		pop r17
 349 00c4 0895      		ret
 350               		.cfi_endproc
 351               	.LFE20:
 353               	.global	FLASH_EraseSector
 355               	FLASH_EraseSector:
 356               	.LFB21:
 459:bootSAH_6.c   **** 
 460:bootSAH_6.c   **** void FLASH_EraseSector(uint32_t faddr)
 461:bootSAH_6.c   **** {
 357               		.loc 1 461 0
 358               		.cfi_startproc
 359               	.LVL33:
 360 00c6 1F93      		push r17
 361               	.LCFI3:
 362               		.cfi_def_cfa_offset 4
 363               		.cfi_offset 17, -3
 364 00c8 CF93      		push r28
 365               	.LCFI4:
 366               		.cfi_def_cfa_offset 5
 367               		.cfi_offset 28, -4
 368 00ca DF93      		push r29
 369               	.LCFI5:
 370               		.cfi_def_cfa_offset 6
 371               		.cfi_offset 29, -5
 372               	/* prologue: function */
 373               	/* frame size = 0 */
 374               	/* stack size = 3 */
 375               	.L__stack_usage = 3
 376 00cc EB01      		movw r28,r22
 377 00ce 182F      		mov r17,r24
 462:bootSAH_6.c   **** 	FLASH_UntilReady();
 378               		.loc 1 462 0
 379 00d0 0E94 0000 		call FLASH_UntilReady
 380               	.LVL34:
 463:bootSAH_6.c   **** 	FLASH_WriteEnable();
 381               		.loc 1 463 0
 382 00d4 0E94 0000 		call FLASH_WriteEnable
 383               	.LVL35:
 464:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 384               		.loc 1 464 0
 385 00d8 2898      		cbi 0x5,0
 465:bootSAH_6.c   **** 	SPI_Transfer(0x20);
 386               		.loc 1 465 0
 387 00da 80E2      		ldi r24,lo8(32)
 388 00dc 0E94 0000 		call SPI_Transfer
 389               	.LVL36:
 466:bootSAH_6.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 390               		.loc 1 466 0
 391 00e0 812F      		mov r24,r17
 392 00e2 0E94 0000 		call SPI_Transfer
 393               	.LVL37:
 467:bootSAH_6.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 394               		.loc 1 467 0
 395 00e6 8D2F      		mov r24,r29
 396 00e8 0E94 0000 		call SPI_Transfer
 397               	.LVL38:
 468:bootSAH_6.c   **** 	SPI_Transfer(faddr & 0xff);
 398               		.loc 1 468 0
 399 00ec 8C2F      		mov r24,r28
 400 00ee 0E94 0000 		call SPI_Transfer
 401               	.LVL39:
 469:bootSAH_6.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 402               		.loc 1 469 0
 403 00f2 289A      		sbi 0x5,0
 470:bootSAH_6.c   **** 	tiny_delay();
 404               		.loc 1 470 0
 405 00f4 0E94 0000 		call tiny_delay
 406               	.LVL40:
 407               	/* epilogue start */
 471:bootSAH_6.c   **** 	FLASH_UntilReady();
 472:bootSAH_6.c   **** }
 408               		.loc 1 472 0
 409 00f8 DF91      		pop r29
 410 00fa CF91      		pop r28
 411 00fc 1F91      		pop r17
 471:bootSAH_6.c   **** 	FLASH_UntilReady();
 412               		.loc 1 471 0
 413 00fe 0C94 0000 		jmp FLASH_UntilReady
 414               	.LVL41:
 415               		.cfi_endproc
 416               	.LFE21:
 418               		.section	.text.startup,"ax",@progbits
 419               	.global	main
 421               	main:
 422               	.LFB13:
 112:bootSAH_6.c   **** 	uint32_t fMemStatus = 0;
 423               		.loc 1 112 0
 424               		.cfi_startproc
 425 0000 CF93      		push r28
 426               	.LCFI6:
 427               		.cfi_def_cfa_offset 4
 428               		.cfi_offset 28, -3
 429 0002 DF93      		push r29
 430               	.LCFI7:
 431               		.cfi_def_cfa_offset 5
 432               		.cfi_offset 29, -4
 433 0004 CDB7      		in r28,__SP_L__
 434 0006 DEB7      		in r29,__SP_H__
 435               	.LCFI8:
 436               		.cfi_def_cfa_register 28
 437 0008 C650      		subi r28,6
 438 000a D140      		sbci r29,1
 439               	.LCFI9:
 440               		.cfi_def_cfa_offset 267
 441 000c 0FB6      		in __tmp_reg__,__SREG__
 442 000e F894      		cli
 443 0010 DEBF      		out __SP_H__,r29
 444 0012 0FBE      		out __SREG__,__tmp_reg__
 445 0014 CDBF      		out __SP_L__,r28
 446               	/* prologue: function */
 447               	/* frame size = 262 */
 448               	/* stack size = 264 */
 449               	.L__stack_usage = 264
 450               	.LVL42:
 144:bootSAH_6.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 451               		.loc 1 144 0
 452               	/* #APP */
 453               	 ;  144 "bootSAH_6.c" 1
 454               		.set __stack, 8703
 455               	 ;  0 "" 2
 145:bootSAH_6.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 456               		.loc 1 145 0
 457               	 ;  145 "bootSAH_6.c" 1
 458 0016 01E2      		ldi	16, 33
 459               	 ;  0 "" 2
 146:bootSAH_6.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 460               		.loc 1 146 0
 461               	 ;  146 "bootSAH_6.c" 1
 462 0018 0EBF      		out 62,16
 463               	 ;  0 "" 2
 147:bootSAH_6.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 464               		.loc 1 147 0
 465               	 ;  147 "bootSAH_6.c" 1
 466 001a 0FEF      		ldi	16, 255
 467               	 ;  0 "" 2
 148:bootSAH_6.c   **** 	
 468               		.loc 1 148 0
 469               	 ;  148 "bootSAH_6.c" 1
 470 001c 0DBF      		out 61,16
 471               	 ;  0 "" 2
 154:bootSAH_6.c   **** 
 472               		.loc 1 154 0
 473               	/* #NOAPP */
 474 001e 94B7      		in r25,0x34
 475               	.LVL43:
 156:bootSAH_6.c   **** 	__asm__ __volatile__ ("wdr");
 476               		.loc 1 156 0
 477               	/* #APP */
 478               	 ;  156 "bootSAH_6.c" 1
 479 0020 F894      		cli
 480               	 ;  0 "" 2
 157:bootSAH_6.c   **** 	//MCUSR	=	0;
 481               		.loc 1 157 0
 482               	 ;  157 "bootSAH_6.c" 1
 483 0022 A895      		wdr
 484               	 ;  0 "" 2
 159:bootSAH_6.c   **** 	WDTCSR	=	0;
 485               		.loc 1 159 0
 486               	/* #NOAPP */
 487 0024 8091 6000 		lds r24,96
 488 0028 8861      		ori r24,lo8(24)
 489 002a 8093 6000 		sts 96,r24
 160:bootSAH_6.c   **** 	__asm__ __volatile__ ("sei");
 490               		.loc 1 160 0
 491 002e 1092 6000 		sts 96,__zero_reg__
 161:bootSAH_6.c   **** 	// check if WDT generated the reset, if so, go straight to app
 492               		.loc 1 161 0
 493               	/* #APP */
 494               	 ;  161 "bootSAH_6.c" 1
 495 0032 7894      		sei
 496               	 ;  0 "" 2
 163:bootSAH_6.c   **** 	{
 497               		.loc 1 163 0
 498               	/* #NOAPP */
 499 0034 93FF      		sbrs r25,3
 500 0036 00C0      		rjmp .L21
 165:bootSAH_6.c   **** 	}
 501               		.loc 1 165 0
 502 0038 E091 0000 		lds r30,app_start
 503 003c F091 0000 		lds r31,app_start+1
 504 0040 1995      		eicall
 505               	.LVL44:
 506               	.L21:
 171:bootSAH_6.c   **** 				(1<<SPI_MOSI)|
 507               		.loc 1 171 0
 508 0042 87E0      		ldi r24,lo8(7)
 509 0044 84B9      		out 0x4,r24
 177:bootSAH_6.c   **** 				(0<<SPIE)|              // SPI Interupt Enable
 510               		.loc 1 177 0
 511 0046 81E5      		ldi r24,lo8(81)
 512 0048 8CBD      		out 0x2c,r24
 186:bootSAH_6.c   **** 	
 513               		.loc 1 186 0
 514 004a 289A      		sbi 0x5,0
 188:bootSAH_6.c   **** 	
 515               		.loc 1 188 0
 516               	/* #APP */
 517               	 ;  188 "bootSAH_6.c" 1
 518 004c 0000      		nop
 519               	 ;  0 "" 2
 520               	.LVL45:
 200:bootSAH_6.c   **** 	FLASH_ResetEnable();
 521               		.loc 1 200 0
 522               	/* #NOAPP */
 523 004e 0E94 0000 		call FLASH_UntilReady
 524               	.LVL46:
 201:bootSAH_6.c   **** 	FLASH_Reset();
 525               		.loc 1 201 0
 526 0052 0E94 0000 		call FLASH_ResetEnable
 527               	.LVL47:
 202:bootSAH_6.c   **** 	
 528               		.loc 1 202 0
 529 0056 0E94 0000 		call FLASH_Reset
 530               	.LVL48:
 204:bootSAH_6.c   **** 	SPI_Transfer(0x9F);
 531               		.loc 1 204 0
 532 005a 2898      		cbi 0x5,0
 205:bootSAH_6.c   **** 	fMemStatus = (uint32_t)SPI_Transfer(0) << 16;
 533               		.loc 1 205 0
 534 005c 8FE9      		ldi r24,lo8(-97)
 535 005e 0E94 0000 		call SPI_Transfer
 536               	.LVL49:
 206:bootSAH_6.c   **** 	fMemStatus |= (uint32_t)SPI_Transfer(0) << 8;
 537               		.loc 1 206 0
 538 0062 80E0      		ldi r24,0
 539 0064 0E94 0000 		call SPI_Transfer
 540               	.LVL50:
 541 0068 C82E      		mov r12,r24
 542 006a D12C      		mov r13,__zero_reg__
 543 006c E12C      		mov r14,__zero_reg__
 544 006e F12C      		mov r15,__zero_reg__
 545 0070 7601      		movw r14,r12
 546 0072 DD24      		clr r13
 547 0074 CC24      		clr r12
 548               	.LVL51:
 207:bootSAH_6.c   **** 	fMemStatus |= (uint32_t)SPI_Transfer(0);
 549               		.loc 1 207 0
 550 0076 80E0      		ldi r24,0
 551 0078 0E94 0000 		call SPI_Transfer
 552               	.LVL52:
 553 007c D82A      		or r13,r24
 208:bootSAH_6.c   **** 	SPI_PORT |=  (1<<SPI_CS);
 554               		.loc 1 208 0
 555 007e 80E0      		ldi r24,0
 556 0080 0E94 0000 		call SPI_Transfer
 557               	.LVL53:
 209:bootSAH_6.c   **** 
 558               		.loc 1 209 0
 559 0084 289A      		sbi 0x5,0
 211:bootSAH_6.c   **** 	{
 560               		.loc 1 211 0
 561 0086 C82A      		or r12,r24
 562               	.LVL54:
 563 0088 27E1      		ldi r18,23
 564 008a C216      		cp r12,r18
 565 008c 20E4      		ldi r18,64
 566 008e D206      		cpc r13,r18
 567 0090 2FEE      		ldi r18,-17
 568 0092 E206      		cpc r14,r18
 569 0094 F104      		cpc r15,__zero_reg__
 570 0096 01F0      		breq .+2
 571 0098 00C0      		rjmp .L23
 213:bootSAH_6.c   **** 		SPI_Transfer(0x03);
 572               		.loc 1 213 0
 573 009a 2898      		cbi 0x5,0
 214:bootSAH_6.c   **** 		SPI_Transfer((fBStatAddr >> 16) & 0xff);
 574               		.loc 1 214 0
 575 009c 83E0      		ldi r24,lo8(3)
 576 009e 0E94 0000 		call SPI_Transfer
 577               	.LVL55:
 215:bootSAH_6.c   **** 		SPI_Transfer((fBStatAddr >> 8) & 0xff);
 578               		.loc 1 215 0
 579 00a2 80E0      		ldi r24,0
 580 00a4 0E94 0000 		call SPI_Transfer
 581               	.LVL56:
 216:bootSAH_6.c   **** 		SPI_Transfer(fBStatAddr & 0xff);
 582               		.loc 1 216 0
 583 00a8 80E1      		ldi r24,lo8(16)
 584 00aa 0E94 0000 		call SPI_Transfer
 585               	.LVL57:
 217:bootSAH_6.c   **** 		fBootStat = (uint16_t)SPI_Transfer(0) << 8;
 586               		.loc 1 217 0
 587 00ae 80E0      		ldi r24,0
 588 00b0 0E94 0000 		call SPI_Transfer
 589               	.LVL58:
 218:bootSAH_6.c   **** 		fBootStat |= (uint16_t)SPI_Transfer(0);
 590               		.loc 1 218 0
 591 00b4 80E0      		ldi r24,0
 592 00b6 0E94 0000 		call SPI_Transfer
 593               	.LVL59:
 594 00ba 082F      		mov r16,r24
 595 00bc 10E0      		ldi r17,0
 596 00be 102F      		mov r17,r16
 597 00c0 0027      		clr r16
 598               	.LVL60:
 219:bootSAH_6.c   **** 		SPI_PORT  |=   (1<<SPI_CS);
 599               		.loc 1 219 0
 600 00c2 80E0      		ldi r24,0
 601 00c4 0E94 0000 		call SPI_Transfer
 602               	.LVL61:
 603 00c8 082B      		or r16,r24
 604               	.LVL62:
 220:bootSAH_6.c   **** 		tiny_delay();
 605               		.loc 1 220 0
 606 00ca 289A      		sbi 0x5,0
 221:bootSAH_6.c   **** 
 607               		.loc 1 221 0
 608 00cc 0E94 0000 		call tiny_delay
 609               	.LVL63:
 224:bootSAH_6.c   **** 		{
 610               		.loc 1 224 0
 611 00d0 0332      		cpi r16,35
 612 00d2 1342      		sbci r17,35
 613 00d4 01F0      		breq .+2
 614 00d6 00C0      		rjmp .L23
 227:bootSAH_6.c   **** 			SPI_Transfer(0x03);
 615               		.loc 1 227 0
 616 00d8 2898      		cbi 0x5,0
 228:bootSAH_6.c   **** 			SPI_Transfer((fDLenAddr >> 16) & 0xff);
 617               		.loc 1 228 0
 618 00da 83E0      		ldi r24,lo8(3)
 619 00dc 0E94 0000 		call SPI_Transfer
 620               	.LVL64:
 229:bootSAH_6.c   **** 			SPI_Transfer((fDLenAddr >> 8) & 0xff);
 621               		.loc 1 229 0
 622 00e0 80E0      		ldi r24,0
 623 00e2 0E94 0000 		call SPI_Transfer
 624               	.LVL65:
 230:bootSAH_6.c   **** 			SPI_Transfer(fDLenAddr & 0xff);
 625               		.loc 1 230 0
 626 00e6 80E1      		ldi r24,lo8(16)
 627 00e8 0E94 0000 		call SPI_Transfer
 628               	.LVL66:
 231:bootSAH_6.c   **** 			fDataLen = (uint16_t)SPI_Transfer(0) << 8;
 629               		.loc 1 231 0
 630 00ec 82E0      		ldi r24,lo8(2)
 631 00ee 0E94 0000 		call SPI_Transfer
 632               	.LVL67:
 232:bootSAH_6.c   **** 			fDataLen |= (uint16_t)SPI_Transfer(0);
 633               		.loc 1 232 0
 634 00f2 80E0      		ldi r24,0
 635 00f4 0E94 0000 		call SPI_Transfer
 636               	.LVL68:
 637 00f8 182F      		mov r17,r24
 638               	.LVL69:
 233:bootSAH_6.c   **** 			SPI_PORT  |=   (1<<SPI_CS);
 639               		.loc 1 233 0
 640 00fa 80E0      		ldi r24,0
 641 00fc 0E94 0000 		call SPI_Transfer
 642               	.LVL70:
 643 0100 212F      		mov r18,r17
 644 0102 30E0      		ldi r19,0
 645 0104 322F      		mov r19,r18
 646 0106 2227      		clr r18
 647 0108 A901      		movw r20,r18
 648 010a 482B      		or r20,r24
 649 010c CD5F      		subi r28,lo8(-259)
 650 010e DE4F      		sbci r29,hi8(-259)
 651 0110 5983      		std Y+1,r21
 652 0112 4883      		st Y,r20
 653 0114 C350      		subi r28,lo8(259)
 654 0116 D140      		sbci r29,hi8(259)
 655               	.LVL71:
 234:bootSAH_6.c   **** 			tiny_delay();
 656               		.loc 1 234 0
 657 0118 289A      		sbi 0x5,0
 235:bootSAH_6.c   **** 			
 658               		.loc 1 235 0
 659 011a 0E94 0000 		call tiny_delay
 660               	.LVL72:
 195:bootSAH_6.c   **** 	fPageAddr  = 0;
 661               		.loc 1 195 0
 662 011e 812C      		mov r8,__zero_reg__
 663 0120 51E1      		ldi r21,lo8(17)
 664 0122 952E      		mov r9,r21
 665 0124 A12C      		mov r10,__zero_reg__
 666 0126 B12C      		mov r11,__zero_reg__
 194:bootSAH_6.c   **** 	fCsumAddr  = 4352;
 667               		.loc 1 194 0
 668 0128 C12C      		mov r12,__zero_reg__
 669 012a 60E2      		ldi r22,lo8(32)
 670 012c D62E      		mov r13,r22
 671 012e E12C      		mov r14,__zero_reg__
 672 0130 F12C      		mov r15,__zero_reg__
 673 0132 CE01      		movw r24,r28
 674 0134 8F5F      		subi r24,-1
 675 0136 9E4F      		sbci r25,-2
 676 0138 CF5F      		subi r28,lo8(-257)
 677 013a DE4F      		sbci r29,hi8(-257)
 678 013c 9983      		std Y+1,r25
 679 013e 8883      		st Y,r24
 680 0140 C150      		subi r28,lo8(257)
 681 0142 D140      		sbci r29,hi8(257)
 682               	.LVL73:
 683               	.L38:
 684 0144 2601      		movw r4,r12
 685 0146 3701      		movw r6,r14
 686 0148 90E2      		ldi r25,32
 687 014a 591A      		sub r5,r25
 688 014c 6108      		sbc r6,__zero_reg__
 689 014e 7108      		sbc r7,__zero_reg__
 690               	.LVL74:
 246:bootSAH_6.c   **** 				SPI_Transfer(0x03);
 691               		.loc 1 246 0
 692 0150 2898      		cbi 0x5,0
 247:bootSAH_6.c   **** 				SPI_Transfer((fDataAddr >> 16) & 0xff);
 693               		.loc 1 247 0
 694 0152 83E0      		ldi r24,lo8(3)
 695 0154 0E94 0000 		call SPI_Transfer
 696               	.LVL75:
 248:bootSAH_6.c   **** 				SPI_Transfer((fDataAddr >> 8) & 0xff);
 697               		.loc 1 248 0
 698 0158 8E2D      		mov r24,r14
 699 015a 0E94 0000 		call SPI_Transfer
 700               	.LVL76:
 249:bootSAH_6.c   **** 				SPI_Transfer(fDataAddr & 0xff);			
 701               		.loc 1 249 0
 702 015e 8D2D      		mov r24,r13
 703 0160 0E94 0000 		call SPI_Transfer
 704               	.LVL77:
 250:bootSAH_6.c   **** 				do 
 705               		.loc 1 250 0
 706 0164 80E0      		ldi r24,0
 707 0166 0E94 0000 		call SPI_Transfer
 708               	.LVL78:
 709 016a FE01      		movw r30,r28
 710 016c 3196      		adiw r30,1
 711 016e 1F01      		movw r2,r30
 712 0170 8F01      		movw r16,r30
 245:bootSAH_6.c   **** 				SPI_PORT  &=  ~(1<<SPI_CS);
 713               		.loc 1 245 0
 714 0172 CB5F      		subi r28,lo8(-261)
 715 0174 DE4F      		sbci r29,hi8(-261)
 716 0176 1982      		std Y+1,__zero_reg__
 717 0178 1882      		st Y,__zero_reg__
 718 017a C550      		subi r28,lo8(261)
 719 017c D140      		sbci r29,hi8(261)
 720               	.LVL79:
 721               	.L25:
 253:bootSAH_6.c   **** 					flashBuff[fMemIndex++] = fRdData;
 722               		.loc 1 253 0 discriminator 1
 723 017e 80E0      		ldi r24,0
 724 0180 0E94 0000 		call SPI_Transfer
 725               	.LVL80:
 254:bootSAH_6.c   **** 					fChSumCal += fRdData;				
 726               		.loc 1 254 0 discriminator 1
 727 0184 F801      		movw r30,r16
 728 0186 8193      		st Z+,r24
 729 0188 8F01      		movw r16,r30
 255:bootSAH_6.c   **** 					fMemSize--;
 730               		.loc 1 255 0 discriminator 1
 731 018a CB5F      		subi r28,lo8(-261)
 732 018c DE4F      		sbci r29,hi8(-261)
 733 018e 2881      		ld r18,Y
 734 0190 3981      		ldd r19,Y+1
 735 0192 C550      		subi r28,lo8(261)
 736 0194 D140      		sbci r29,hi8(261)
 737 0196 280F      		add r18,r24
 738 0198 311D      		adc r19,__zero_reg__
 739 019a CB5F      		subi r28,lo8(-261)
 740 019c DE4F      		sbci r29,hi8(-261)
 741 019e 3983      		std Y+1,r19
 742 01a0 2883      		st Y,r18
 743 01a2 C550      		subi r28,lo8(261)
 744 01a4 D140      		sbci r29,hi8(261)
 745               	.LVL81:
 257:bootSAH_6.c   **** 				SPI_PORT  |=   (1<<SPI_CS);
 746               		.loc 1 257 0 discriminator 1
 747 01a6 CF5F      		subi r28,lo8(-257)
 748 01a8 DE4F      		sbci r29,hi8(-257)
 749 01aa 4881      		ld r20,Y
 750 01ac 5981      		ldd r21,Y+1
 751 01ae C150      		subi r28,lo8(257)
 752 01b0 D140      		sbci r29,hi8(257)
 753 01b2 E417      		cp r30,r20
 754 01b4 F507      		cpc r31,r21
 755 01b6 01F4      		brne .L25
 258:bootSAH_6.c   **** 				tiny_delay();
 756               		.loc 1 258 0
 757 01b8 289A      		sbi 0x5,0
 259:bootSAH_6.c   **** 
 758               		.loc 1 259 0
 759 01ba 0E94 0000 		call tiny_delay
 760               	.LVL82:
 262:bootSAH_6.c   **** 				SPI_Transfer(0x03);
 761               		.loc 1 262 0
 762 01be 2898      		cbi 0x5,0
 263:bootSAH_6.c   **** 				SPI_Transfer((fCsumAddr >> 16) & 0xff);
 763               		.loc 1 263 0
 764 01c0 83E0      		ldi r24,lo8(3)
 765 01c2 0E94 0000 		call SPI_Transfer
 766               	.LVL83:
 264:bootSAH_6.c   **** 				SPI_Transfer((fCsumAddr >> 8) & 0xff);
 767               		.loc 1 264 0
 768 01c6 80E0      		ldi r24,0
 769 01c8 0E94 0000 		call SPI_Transfer
 770               	.LVL84:
 265:bootSAH_6.c   **** 				SPI_Transfer(fCsumAddr & 0xff);				
 771               		.loc 1 265 0
 772 01cc 892D      		mov r24,r9
 773 01ce 0E94 0000 		call SPI_Transfer
 774               	.LVL85:
 266:bootSAH_6.c   **** 				fChSumRev = (uint16_t)SPI_Transfer(0) << 8;
 775               		.loc 1 266 0
 776 01d2 882D      		mov r24,r8
 777 01d4 0E94 0000 		call SPI_Transfer
 778               	.LVL86:
 267:bootSAH_6.c   **** 				fChSumRev |= (uint16_t)SPI_Transfer(0);			
 779               		.loc 1 267 0
 780 01d8 80E0      		ldi r24,0
 781 01da 0E94 0000 		call SPI_Transfer
 782               	.LVL87:
 783 01de 082F      		mov r16,r24
 784 01e0 10E0      		ldi r17,0
 785 01e2 102F      		mov r17,r16
 786 01e4 0027      		clr r16
 787               	.LVL88:
 268:bootSAH_6.c   **** 				SPI_PORT  |=   (1<<SPI_CS);
 788               		.loc 1 268 0
 789 01e6 80E0      		ldi r24,0
 790 01e8 0E94 0000 		call SPI_Transfer
 791               	.LVL89:
 792 01ec 082B      		or r16,r24
 793               	.LVL90:
 269:bootSAH_6.c   **** 				tiny_delay();
 794               		.loc 1 269 0
 795 01ee 289A      		sbi 0x5,0
 270:bootSAH_6.c   **** 		
 796               		.loc 1 270 0
 797 01f0 0E94 0000 		call tiny_delay
 798               	.LVL91:
 272:bootSAH_6.c   **** 				{
 799               		.loc 1 272 0
 800 01f4 CB5F      		subi r28,lo8(-261)
 801 01f6 DE4F      		sbci r29,hi8(-261)
 802 01f8 8881      		ld r24,Y
 803 01fa 9981      		ldd r25,Y+1
 804 01fc C550      		subi r28,lo8(261)
 805 01fe D140      		sbci r29,hi8(261)
 806 0200 8017      		cp r24,r16
 807 0202 9107      		cpc r25,r17
 808 0204 01F0      		breq .+2
 809 0206 00C0      		rjmp .L26
 810               	.LVL92:
 282:bootSAH_6.c   **** 				{
 811               		.loc 1 282 0
 812 0208 C114      		cp r12,__zero_reg__
 813 020a 90EE      		ldi r25,-32
 814 020c D906      		cpc r13,r25
 815 020e 93E0      		ldi r25,3
 816 0210 E906      		cpc r14,r25
 817 0212 F104      		cpc r15,__zero_reg__
 818 0214 01F4      		brne .+2
 819 0216 00C0      		rjmp .L26
 820               	.L47:
 288:bootSAH_6.c   **** 				boot_spm_busy_wait();			
 821               		.loc 1 288 0 discriminator 1
 822 0218 07B6      		in __tmp_reg__,0x37
 823 021a 00FC      		sbrc __tmp_reg__,0
 824 021c 00C0      		rjmp .L47
 825               	.L28:
 288:bootSAH_6.c   **** 				boot_spm_busy_wait();			
 826               		.loc 1 288 0 is_stmt 0 discriminator 3
 827 021e F999      		sbic 0x1f,1
 828 0220 00C0      		rjmp .L28
 288:bootSAH_6.c   **** 				boot_spm_busy_wait();			
 829               		.loc 1 288 0 discriminator 4
 830 0222 83E0      		ldi r24,lo8(3)
 831               	/* #APP */
 832               	 ;  288 "bootSAH_6.c" 1
 833 0224 F201      		movw r30, r4
 834 0226 6092 5B00 		sts  91, r6
 835 022a 8093 5700 		sts 87, r24
 836 022e E895      		spm
 837               		
 838               	 ;  0 "" 2
 839               	/* #NOAPP */
 840               	.L29:
 289:bootSAH_6.c   **** 					
 841               		.loc 1 289 0 is_stmt 1 discriminator 1
 842 0230 07B6      		in __tmp_reg__,0x37
 843 0232 00FC      		sbrc __tmp_reg__,0
 844 0234 00C0      		rjmp .L29
 845 0236 B301      		movw r22,r6
 846 0238 A201      		movw r20,r4
 847               	.LVL93:
 848               	.L32:
 295:bootSAH_6.c   **** 					fMSByte = flashBuff[fMemIndex++];
 849               		.loc 1 295 0
 850               	/* #APP */
 851               	 ;  295 "bootSAH_6.c" 1
 852 023a 0000      		nop
 853               	 ;  0 "" 2
 854               	.LVL94:
 298:bootSAH_6.c   **** 						
 855               		.loc 1 298 0
 856               	/* #NOAPP */
 857 023c F101      		movw r30,r2
 858 023e 8181      		ldd r24,Z+1
 859 0240 90E0      		ldi r25,0
 860 0242 982F      		mov r25,r24
 861 0244 8827      		clr r24
 862 0246 2081      		ld r18,Z
 863 0248 822B      		or r24,r18
 864               	.LVL95:
 865               	.L30:
 300:bootSAH_6.c   **** 						
 866               		.loc 1 300 0 discriminator 1
 867 024a 07B6      		in __tmp_reg__,0x37
 868 024c 00FC      		sbrc __tmp_reg__,0
 869 024e 00C0      		rjmp .L30
 870               	.L31:
 300:bootSAH_6.c   **** 						
 871               		.loc 1 300 0 is_stmt 0 discriminator 3
 872 0250 F999      		sbic 0x1f,1
 873 0252 00C0      		rjmp .L31
 300:bootSAH_6.c   **** 						
 874               		.loc 1 300 0 discriminator 4
 875 0254 21E0      		ldi r18,lo8(1)
 876               	/* #APP */
 877               	 ;  300 "bootSAH_6.c" 1
 878 0256 0C01      		movw  r0, r24
 879 0258 FA01      		movw r30, r20
 880 025a 6093 5B00 		sts 91, r22
 881 025e 2093 5700 		sts 87, r18
 882 0262 E895      		spm
 883 0264 1124      		clr  r1
 884               		
 885               	 ;  0 "" 2
 302:bootSAH_6.c   **** 					asm volatile ("nop");	
 886               		.loc 1 302 0 is_stmt 1 discriminator 4
 887               	/* #NOAPP */
 888 0266 4E5F      		subi r20,-2
 889 0268 5F4F      		sbci r21,-1
 890 026a 6F4F      		sbci r22,-1
 891 026c 7F4F      		sbci r23,-1
 892               	.LVL96:
 303:bootSAH_6.c   **** 					fMemSize = fMemSize - 2;
 893               		.loc 1 303 0 discriminator 4
 894               	/* #APP */
 895               	 ;  303 "bootSAH_6.c" 1
 896 026e 0000      		nop
 897               	 ;  0 "" 2
 898               	/* #NOAPP */
 899 0270 32E0      		ldi r19,2
 900 0272 230E      		add r2,r19
 901 0274 311C      		adc r3,__zero_reg__
 902               	.LVL97:
 305:bootSAH_6.c   **** 					
 903               		.loc 1 305 0 discriminator 4
 904 0276 CF5F      		subi r28,lo8(-257)
 905 0278 DE4F      		sbci r29,hi8(-257)
 906 027a 8881      		ld r24,Y
 907 027c 9981      		ldd r25,Y+1
 908 027e C150      		subi r28,lo8(257)
 909 0280 D140      		sbci r29,hi8(257)
 910               	.LVL98:
 911 0282 8215      		cp r24,r2
 912 0284 9305      		cpc r25,r3
 913 0286 01F4      		brne .L32
 914               	.L46:
 307:bootSAH_6.c   **** 				boot_spm_busy_wait();
 915               		.loc 1 307 0 discriminator 1
 916 0288 07B6      		in __tmp_reg__,0x37
 917 028a 00FC      		sbrc __tmp_reg__,0
 918 028c 00C0      		rjmp .L46
 919               	.L34:
 307:bootSAH_6.c   **** 				boot_spm_busy_wait();
 920               		.loc 1 307 0 is_stmt 0 discriminator 3
 921 028e F999      		sbic 0x1f,1
 922 0290 00C0      		rjmp .L34
 307:bootSAH_6.c   **** 				boot_spm_busy_wait();
 923               		.loc 1 307 0 discriminator 4
 924 0292 95E0      		ldi r25,lo8(5)
 925               	/* #APP */
 926               	 ;  307 "bootSAH_6.c" 1
 927 0294 F201      		movw r30, r4
 928 0296 6092 5B00 		sts 91, r6
 929 029a 9093 5700 		sts 87, r25
 930 029e E895      		spm
 931               		
 932               	 ;  0 "" 2
 933               	/* #NOAPP */
 934               	.L35:
 308:bootSAH_6.c   **** 				boot_rww_enable_safe();
 935               		.loc 1 308 0 is_stmt 1 discriminator 1
 936 02a0 07B6      		in __tmp_reg__,0x37
 937 02a2 00FC      		sbrc __tmp_reg__,0
 938 02a4 00C0      		rjmp .L35
 939               	.L36:
 309:bootSAH_6.c   **** 					
 940               		.loc 1 309 0 discriminator 1
 941 02a6 07B6      		in __tmp_reg__,0x37
 942 02a8 00FC      		sbrc __tmp_reg__,0
 943 02aa 00C0      		rjmp .L36
 944               	.L37:
 309:bootSAH_6.c   **** 					
 945               		.loc 1 309 0 is_stmt 0 discriminator 3
 946 02ac F999      		sbic 0x1f,1
 947 02ae 00C0      		rjmp .L37
 309:bootSAH_6.c   **** 					
 948               		.loc 1 309 0 discriminator 4
 949 02b0 E1E1      		ldi r30,lo8(17)
 950               	/* #APP */
 951               	 ;  309 "bootSAH_6.c" 1
 952 02b2 E093 5700 		sts 87, r30
 953 02b6 E895      		spm
 954               		
 955               	 ;  0 "" 2
 956               	.LVL99:
 312:bootSAH_6.c   **** 				fCsumAddr += 2;
 957               		.loc 1 312 0 is_stmt 1 discriminator 4
 958               	/* #NOAPP */
 959 02b8 FFEF      		ldi r31,-1
 960 02ba DF1A      		sub r13,r31
 961 02bc EF0A      		sbc r14,r31
 962 02be FF0A      		sbc r15,r31
 963               	.LVL100:
 313:bootSAH_6.c   **** 				asm volatile ("nop");
 964               		.loc 1 313 0 discriminator 4
 965 02c0 22E0      		ldi r18,2
 966 02c2 820E      		add r8,r18
 967 02c4 911C      		adc r9,__zero_reg__
 968 02c6 A11C      		adc r10,__zero_reg__
 969 02c8 B11C      		adc r11,__zero_reg__
 970               	.LVL101:
 314:bootSAH_6.c   **** 				
 971               		.loc 1 314 0 discriminator 4
 972               	/* #APP */
 973               	 ;  314 "bootSAH_6.c" 1
 974 02ca 0000      		nop
 975               	 ;  0 "" 2
 316:bootSAH_6.c   **** 			} while (fDLenTemp);
 976               		.loc 1 316 0 discriminator 4
 977               	/* #NOAPP */
 978 02cc CD5F      		subi r28,lo8(-259)
 979 02ce DE4F      		sbci r29,hi8(-259)
 980 02d0 4881      		ld r20,Y
 981 02d2 5981      		ldd r21,Y+1
 982 02d4 C350      		subi r28,lo8(259)
 983 02d6 D140      		sbci r29,hi8(259)
 984               	.LVL102:
 985 02d8 4150      		subi r20,1
 986 02da 5109      		sbc r21,__zero_reg__
 987 02dc CD5F      		subi r28,lo8(-259)
 988 02de DE4F      		sbci r29,hi8(-259)
 989 02e0 5983      		std Y+1,r21
 990 02e2 4883      		st Y,r20
 991 02e4 C350      		subi r28,lo8(259)
 992 02e6 D140      		sbci r29,hi8(259)
 993               	.LVL103:
 317:bootSAH_6.c   **** 			
 994               		.loc 1 317 0 discriminator 4
 995 02e8 452B      		or r20,r21
 996 02ea 01F0      		breq .+2
 997 02ec 00C0      		rjmp .L38
 998               	.LVL104:
 999               	.L26:
 353:bootSAH_6.c   **** 			FLASH_EraseSector(fBStatAddr);						
 1000               		.loc 1 353 0
 1001 02ee 0E94 0000 		call tiny_delay
 1002               	.LVL105:
 354:bootSAH_6.c   **** 		}
 1003               		.loc 1 354 0
 1004 02f2 60E0      		ldi r22,0
 1005 02f4 70E1      		ldi r23,lo8(16)
 1006 02f6 80E0      		ldi r24,0
 1007 02f8 90E0      		ldi r25,0
 1008 02fa 0E94 0000 		call FLASH_EraseSector
 1009               	.LVL106:
 1010               	.L23:
 358:bootSAH_6.c   **** 	
 1011               		.loc 1 358 0
 1012 02fe 0E94 0000 		call tiny_delay
 1013               	.LVL107:
 1014               	.L39:
 360:bootSAH_6.c   **** 
 1015               		.loc 1 360 0 discriminator 1
 1016 0302 07B6      		in __tmp_reg__,0x37
 1017 0304 00FC      		sbrc __tmp_reg__,0
 1018 0306 00C0      		rjmp .L39
 1019               	.L40:
 360:bootSAH_6.c   **** 
 1020               		.loc 1 360 0 is_stmt 0 discriminator 3
 1021 0308 F999      		sbic 0x1f,1
 1022 030a 00C0      		rjmp .L40
 360:bootSAH_6.c   **** 
 1023               		.loc 1 360 0 discriminator 4
 1024 030c 81E1      		ldi r24,lo8(17)
 1025               	/* #APP */
 1026               	 ;  360 "bootSAH_6.c" 1
 1027 030e 8093 5700 		sts 87, r24
 1028 0312 E895      		spm
 1029               		
 1030               	 ;  0 "" 2
 363:bootSAH_6.c   **** 					"clr	r30		\n\t"
 1031               		.loc 1 363 0 is_stmt 1 discriminator 4
 1032               	 ;  363 "bootSAH_6.c" 1
 1033 0314 EE27      		clr	r30		
 1034 0316 FF27      		clr	r31		
 1035 0318 0994      		ijmp			
 1036               		
 1037               	 ;  0 "" 2
 1038               	/* #NOAPP */
 1039               	.L41:
 371:bootSAH_6.c   ****     }
 1040               		.loc 1 371 0 discriminator 1
 1041 031a 0E94 0000 		call tiny_delay
 1042               	.LVL108:
 1043 031e 00C0      		rjmp .L41
 1044               		.cfi_endproc
 1045               	.LFE13:
 1047               		.text
 1048               	.global	FLASH_WriteByte
 1050               	FLASH_WriteByte:
 1051               	.LFB22:
 473:bootSAH_6.c   **** 
 474:bootSAH_6.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata)
 475:bootSAH_6.c   **** {
 1052               		.loc 1 475 0
 1053               		.cfi_startproc
 1054               	.LVL109:
 1055 0102 0F93      		push r16
 1056               	.LCFI10:
 1057               		.cfi_def_cfa_offset 4
 1058               		.cfi_offset 16, -3
 1059 0104 1F93      		push r17
 1060               	.LCFI11:
 1061               		.cfi_def_cfa_offset 5
 1062               		.cfi_offset 17, -4
 1063 0106 CF93      		push r28
 1064               	.LCFI12:
 1065               		.cfi_def_cfa_offset 6
 1066               		.cfi_offset 28, -5
 1067 0108 DF93      		push r29
 1068               	.LCFI13:
 1069               		.cfi_def_cfa_offset 7
 1070               		.cfi_offset 29, -6
 1071               	/* prologue: function */
 1072               	/* frame size = 0 */
 1073               	/* stack size = 4 */
 1074               	.L__stack_usage = 4
 1075 010a D62F      		mov r29,r22
 1076 010c 172F      		mov r17,r23
 1077 010e 082F      		mov r16,r24
 1078 0110 C42F      		mov r28,r20
 476:bootSAH_6.c   **** 	FLASH_UntilReady();
 1079               		.loc 1 476 0
 1080 0112 0E94 0000 		call FLASH_UntilReady
 1081               	.LVL110:
 477:bootSAH_6.c   **** 	FLASH_WriteEnable();
 1082               		.loc 1 477 0
 1083 0116 0E94 0000 		call FLASH_WriteEnable
 1084               	.LVL111:
 478:bootSAH_6.c   **** 	SPI_PORT  &=  ~(1<<SPI_CS);
 1085               		.loc 1 478 0
 1086 011a 2898      		cbi 0x5,0
 479:bootSAH_6.c   **** 	SPI_Transfer(0x02);
 1087               		.loc 1 479 0
 1088 011c 82E0      		ldi r24,lo8(2)
 1089 011e 0E94 0000 		call SPI_Transfer
 1090               	.LVL112:
 480:bootSAH_6.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 1091               		.loc 1 480 0
 1092 0122 802F      		mov r24,r16
 1093 0124 0E94 0000 		call SPI_Transfer
 1094               	.LVL113:
 481:bootSAH_6.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 1095               		.loc 1 481 0
 1096 0128 812F      		mov r24,r17
 1097 012a 0E94 0000 		call SPI_Transfer
 1098               	.LVL114:
 482:bootSAH_6.c   **** 	SPI_Transfer(faddr & 0xff);
 1099               		.loc 1 482 0
 1100 012e 8D2F      		mov r24,r29
 1101 0130 0E94 0000 		call SPI_Transfer
 1102               	.LVL115:
 483:bootSAH_6.c   **** 	SPI_Transfer(wdata & 0xff);
 1103               		.loc 1 483 0
 1104 0134 8C2F      		mov r24,r28
 1105 0136 0E94 0000 		call SPI_Transfer
 1106               	.LVL116:
 484:bootSAH_6.c   **** 	SPI_PORT  |=   (1<<SPI_CS);
 1107               		.loc 1 484 0
 1108 013a 289A      		sbi 0x5,0
 485:bootSAH_6.c   **** 	tiny_delay();
 1109               		.loc 1 485 0
 1110 013c 0E94 0000 		call tiny_delay
 1111               	.LVL117:
 1112               	/* epilogue start */
 486:bootSAH_6.c   **** 	FLASH_UntilReady();
 487:bootSAH_6.c   **** }
 1113               		.loc 1 487 0
 1114 0140 DF91      		pop r29
 1115 0142 CF91      		pop r28
 1116               	.LVL118:
 1117 0144 1F91      		pop r17
 1118 0146 0F91      		pop r16
 486:bootSAH_6.c   **** 	FLASH_UntilReady();
 1119               		.loc 1 486 0
 1120 0148 0C94 0000 		jmp FLASH_UntilReady
 1121               	.LVL119:
 1122               		.cfi_endproc
 1123               	.LFE22:
 1125               	.global	app_start
 1126               		.section .bss
 1129               	app_start:
 1130 0000 0000      		.zero	2
 1131               		.text
 1132               	.Letext0:
 1133               		.file 3 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\st
DEFINED SYMBOLS
                            *ABS*:00000000 bootSAH_6.c
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:2      *ABS*:0000003e __SP_H__
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:3      *ABS*:0000003d __SP_L__
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:4      *ABS*:0000003f __SREG__
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:7      *ABS*:00000001 __zero_reg__
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:12     .text:00000000 SPI_Transfer
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:46     .init9:00000000 __jumpMain
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:57     *ABS*:000021ff __stack
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:421    .text.startup:00000000 main
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:96     .text:0000000e delay_ms
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:142    .text:0000002c tiny_delay
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:167    .text:00000038 FLASH_UntilReady
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:206    .text:00000054 FLASH_ResetEnable
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:230    .text:00000062 FLASH_Reset
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:254    .text:00000070 FLASH_WriteEnable
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:278    .text:0000007e FLASH_ReadWord
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:355    .text:000000c6 FLASH_EraseSector
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:1129   .bss:00000000 app_start
C:\Users\supun\AppData\Local\Temp\cckIwrFP.s:1050   .text:00000102 FLASH_WriteByte

UNDEFINED SYMBOLS
__do_clear_bss
