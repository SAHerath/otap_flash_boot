   1               		.file	"bootSAH_7.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	SPI_Transfer:
  13               	.LFB13:
  14               		.file 1 "bootSAH_7.c"
   1:bootSAH_7.c   **** /*
   2:bootSAH_7.c   ****  * bootSAH_7.c
   3:bootSAH_7.c   ****  *
   4:bootSAH_7.c   ****  * Created: 19/09/16 9:29:06 AM
   5:bootSAH_7.c   ****  * Author : supun
   6:bootSAH_7.c   ****  */ 
   7:bootSAH_7.c   **** 
   8:bootSAH_7.c   **** #include	<inttypes.h>
   9:bootSAH_7.c   **** #include	<avr/io.h>
  10:bootSAH_7.c   **** #include	<avr/interrupt.h>
  11:bootSAH_7.c   **** #include	<avr/boot.h>
  12:bootSAH_7.c   **** #include	<avr/pgmspace.h>
  13:bootSAH_7.c   **** #include	<util/delay.h>
  14:bootSAH_7.c   **** #include	<avr/eeprom.h>
  15:bootSAH_7.c   **** #include	<avr/common.h>
  16:bootSAH_7.c   **** #include	<stdlib.h>
  17:bootSAH_7.c   **** 
  18:bootSAH_7.c   **** 
  19:bootSAH_7.c   **** #ifdef __AVR_ATmega2560__
  20:bootSAH_7.c   **** 	#define PROG_PORT		PORTB
  21:bootSAH_7.c   **** 	#define	PROG_DDR		DDRB
  22:bootSAH_7.c   **** 	#define	PROG_SPI_MISO	PB3
  23:bootSAH_7.c   **** 	#define	PROG_SPI_MOSI	PB2
  24:bootSAH_7.c   **** 	#define	PROG_SPI_SCK	PB1
  25:bootSAH_7.c   **** 	#define PROG_SPI_CS		PB0
  26:bootSAH_7.c   **** 	#define PROG_LED_PIN	PB6
  27:bootSAH_7.c   **** #endif
  28:bootSAH_7.c   **** 
  29:bootSAH_7.c   **** #define EXMEM_JEDEC		0xEF4017
  30:bootSAH_7.c   **** #define EXMEM_SECT_SIZE	4096		// bytes
  31:bootSAH_7.c   **** #define EXMEM_PAGE_SIZE 256			// bytes
  32:bootSAH_7.c   **** 
  33:bootSAH_7.c   **** #define BOOT_EROR_ADDR  256
  34:bootSAH_7.c   **** #define BOOT_STAT_ADDR  4096    // byte addr
  35:bootSAH_7.c   **** #define BOOT_CSUM_ADDR  4352    // byte addr
  36:bootSAH_7.c   **** #define BOOT_DATA_ADDR  8192    // byte addr
  37:bootSAH_7.c   **** 
  38:bootSAH_7.c   **** #ifndef EEWE
  39:bootSAH_7.c   **** 	#define EEWE    1
  40:bootSAH_7.c   **** #endif
  41:bootSAH_7.c   **** #ifndef EEMWE
  42:bootSAH_7.c   **** 	#define EEMWE   2
  43:bootSAH_7.c   **** #endif
  44:bootSAH_7.c   **** 
  45:bootSAH_7.c   **** #define	_DEBUG_SERIAL_
  46:bootSAH_7.c   **** 
  47:bootSAH_7.c   **** #ifndef BAUDRATE
  48:bootSAH_7.c   **** 	#define BAUDRATE 115200
  49:bootSAH_7.c   **** #endif
  50:bootSAH_7.c   **** 
  51:bootSAH_7.c   **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
  52:bootSAH_7.c   **** 	#if defined (__AVR_ATmega32__)
  53:bootSAH_7.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
  54:bootSAH_7.c   **** 	#else
  55:bootSAH_7.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
  56:bootSAH_7.c   **** 	#endif
  57:bootSAH_7.c   **** #endif
  58:bootSAH_7.c   **** 
  59:bootSAH_7.c   **** /* 
  60:bootSAH_7.c   ****  * ATMega with two USART, use UART0 
  61:bootSAH_7.c   ****  * configured for atmega2560 
  62:bootSAH_7.c   ****  */
  63:bootSAH_7.c   **** #define	UART_BAUD_RATE_LOW			UBRR0L
  64:bootSAH_7.c   **** #define	UART_STATUS_REG				UCSR0A
  65:bootSAH_7.c   **** #define	UART_CONTROL_REG			UCSR0B
  66:bootSAH_7.c   **** #define	UART_ENABLE_TRANSMITTER		TXEN0
  67:bootSAH_7.c   **** #define	UART_ENABLE_RECEIVER		RXEN0
  68:bootSAH_7.c   **** #define	UART_TRANSMIT_COMPLETE		TXC0
  69:bootSAH_7.c   **** #define	UART_RECEIVE_COMPLETE		RXC0
  70:bootSAH_7.c   **** #define	UART_DATA_REG				UDR0
  71:bootSAH_7.c   **** #define	UART_DOUBLE_SPEED			U2X0
  72:bootSAH_7.c   **** 
  73:bootSAH_7.c   **** 
  74:bootSAH_7.c   **** /*
  75:bootSAH_7.c   ****  * Macro to calculate UBBR from XTAL and baudrate
  76:bootSAH_7.c   ****  */
  77:bootSAH_7.c   **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
  78:bootSAH_7.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
  79:bootSAH_7.c   **** #elif defined(__AVR_ATmega32__)
  80:bootSAH_7.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
  81:bootSAH_7.c   **** #elif UART_BAUDRATE_DOUBLE_SPEED
  82:bootSAH_7.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
  83:bootSAH_7.c   **** #else
  84:bootSAH_7.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
  85:bootSAH_7.c   **** #endif
  86:bootSAH_7.c   **** 
  87:bootSAH_7.c   **** /*
  88:bootSAH_7.c   ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
  89:bootSAH_7.c   ****  */
  90:bootSAH_7.c   **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
  91:bootSAH_7.c   **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
  92:bootSAH_7.c   **** #define CONFIG_PARAM_HW_VER				0x0F
  93:bootSAH_7.c   **** #define CONFIG_PARAM_SW_MAJOR			2
  94:bootSAH_7.c   **** #define CONFIG_PARAM_SW_MINOR			0x0A
  95:bootSAH_7.c   **** 
  96:bootSAH_7.c   **** /*
  97:bootSAH_7.c   ****  * Signature bytes are not available in avr-gcc io_xxx.h
  98:bootSAH_7.c   ****  * configured for atmega2560
  99:bootSAH_7.c   ****  */
 100:bootSAH_7.c   **** #ifndef SIGNATURE_BYTES
 101:bootSAH_7.c   **** 	#define SIGNATURE_BYTES 0x1E9801
 102:bootSAH_7.c   **** #endif
 103:bootSAH_7.c   **** 
 104:bootSAH_7.c   **** /*
 105:bootSAH_7.c   ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 106:bootSAH_7.c   ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 107:bootSAH_7.c   ****  */
 108:bootSAH_7.c   **** //#define BOOTSIZE 1024
 109:bootSAH_7.c   **** #if FLASHEND > 0x0F000
 110:bootSAH_7.c   **** 	#define BOOTSIZE 8192
 111:bootSAH_7.c   **** #else
 112:bootSAH_7.c   **** 	#define BOOTSIZE 2048
 113:bootSAH_7.c   **** #endif
 114:bootSAH_7.c   **** 
 115:bootSAH_7.c   **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 116:bootSAH_7.c   **** 
 117:bootSAH_7.c   **** /*
 118:bootSAH_7.c   ****  * use 16bit address variable for ATmegas with <= 64K flash
 119:bootSAH_7.c   ****  */
 120:bootSAH_7.c   **** #if defined(RAMPZ)
 121:bootSAH_7.c   **** 	typedef uint32_t address_t;
 122:bootSAH_7.c   **** #else
 123:bootSAH_7.c   **** 	typedef uint16_t address_t;
 124:bootSAH_7.c   **** #endif
 125:bootSAH_7.c   **** 
 126:bootSAH_7.c   **** /*
 127:bootSAH_7.c   ****  * States used in the receive state machine
 128:bootSAH_7.c   ****  */
 129:bootSAH_7.c   **** #define	ST_START		0
 130:bootSAH_7.c   **** #define	ST_GET_SEQ_NUM	1
 131:bootSAH_7.c   **** #define ST_MSG_SIZE_1	2
 132:bootSAH_7.c   **** #define ST_MSG_SIZE_2	3
 133:bootSAH_7.c   **** #define ST_GET_TOKEN	4
 134:bootSAH_7.c   **** #define ST_GET_DATA		5
 135:bootSAH_7.c   **** #define	ST_GET_CHECK	6
 136:bootSAH_7.c   **** #define	ST_PROCESS		7
 137:bootSAH_7.c   **** 
 138:bootSAH_7.c   **** //char hexArr[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
 139:bootSAH_7.c   **** 
 140:bootSAH_7.c   **** /*
 141:bootSAH_7.c   ****  * function prototypes
 142:bootSAH_7.c   ****  */
 143:bootSAH_7.c   **** /*
 144:bootSAH_7.c   **** void delay_ms(unsigned int timedelay);
 145:bootSAH_7.c   **** void tiny_delay(void);		
 146:bootSAH_7.c   **** static uint8_t SPI_Transfer(uint8_t spidata);
 147:bootSAH_7.c   **** void FLASH_UntilReady(void);
 148:bootSAH_7.c   **** void FLASH_ResetEnable(void);
 149:bootSAH_7.c   **** void FLASH_Reset(void);
 150:bootSAH_7.c   **** void FLASH_WriteEnable(void);
 151:bootSAH_7.c   **** uint16_t FLASH_ReadWord(uint32_t faddr);
 152:bootSAH_7.c   **** void FLASH_EraseSector(uint32_t faddr);
 153:bootSAH_7.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata);
 154:bootSAH_7.c   **** */
 155:bootSAH_7.c   **** 
 156:bootSAH_7.c   **** //*******************************************************************
 157:bootSAH_7.c   **** void delay_ms(unsigned int timedelay)
 158:bootSAH_7.c   **** {
 159:bootSAH_7.c   **** 	unsigned int i;
 160:bootSAH_7.c   **** 	for (i=0;i<timedelay;i++)
 161:bootSAH_7.c   **** 	{
 162:bootSAH_7.c   **** 		_delay_ms(0.5);
 163:bootSAH_7.c   **** 	}
 164:bootSAH_7.c   **** }
 165:bootSAH_7.c   **** //** small delay
 166:bootSAH_7.c   **** void tiny_delay(void)		
 167:bootSAH_7.c   **** {
 168:bootSAH_7.c   **** 	asm volatile(
 169:bootSAH_7.c   **** 					"nop	\n\t"
 170:bootSAH_7.c   **** 					"nop	\n\t"
 171:bootSAH_7.c   **** 					"nop	\n\t"
 172:bootSAH_7.c   **** 					"nop	\n\t"
 173:bootSAH_7.c   **** 					"nop	\n\t"
 174:bootSAH_7.c   **** 				); 
 175:bootSAH_7.c   **** }
 176:bootSAH_7.c   **** //*******************************************************************
 177:bootSAH_7.c   **** static uint8_t SPI_Transfer(uint8_t spidata)
 178:bootSAH_7.c   **** {
  15               		.loc 1 178 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 179:bootSAH_7.c   **** 	SPDR = spidata;
  22               		.loc 1 179 0
  23 0000 8EBD      		out 0x2e,r24
 180:bootSAH_7.c   **** 	asm volatile("nop");			// small delay
  24               		.loc 1 180 0
  25               	/* #APP */
  26               	 ;  180 "bootSAH_7.c" 1
  27 0002 0000      		nop
  28               	 ;  0 "" 2
  29               	/* #NOAPP */
  30               	.L2:
 181:bootSAH_7.c   **** 	while(!(SPSR & (1<<SPIF)));		// Wait for transmission complete
  31               		.loc 1 181 0 discriminator 1
  32 0004 0DB4      		in __tmp_reg__,0x2d
  33 0006 07FE      		sbrs __tmp_reg__,7
  34 0008 00C0      		rjmp .L2
 182:bootSAH_7.c   **** 
 183:bootSAH_7.c   **** 	return SPDR;
  35               		.loc 1 183 0
  36 000a 8EB5      		in r24,0x2e
  37               	.LVL1:
 184:bootSAH_7.c   **** }
  38               		.loc 1 184 0
  39 000c 0895      		ret
  40               		.cfi_endproc
  41               	.LFE13:
  44               	sendchar:
  45               	.LFB20:
 185:bootSAH_7.c   **** 
 186:bootSAH_7.c   **** void FLASH_UntilReady(void)
 187:bootSAH_7.c   **** {
 188:bootSAH_7.c   **** 	uint8_t stat=0xff;
 189:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 190:bootSAH_7.c   **** 	SPI_Transfer(0x05);
 191:bootSAH_7.c   **** 	while((stat & 0x01) == 0x01)
 192:bootSAH_7.c   **** 	{
 193:bootSAH_7.c   **** 		stat = SPI_Transfer(0);
 194:bootSAH_7.c   **** 	}
 195:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 196:bootSAH_7.c   **** 	tiny_delay();
 197:bootSAH_7.c   **** }
 198:bootSAH_7.c   **** 
 199:bootSAH_7.c   **** void FLASH_ResetEnable(void)
 200:bootSAH_7.c   **** {
 201:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 202:bootSAH_7.c   **** 	SPI_Transfer(0x66);
 203:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 204:bootSAH_7.c   **** 	tiny_delay();
 205:bootSAH_7.c   **** }
 206:bootSAH_7.c   **** 
 207:bootSAH_7.c   **** void FLASH_Reset(void)
 208:bootSAH_7.c   **** {
 209:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 210:bootSAH_7.c   **** 	SPI_Transfer(0x99);
 211:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 212:bootSAH_7.c   **** 	tiny_delay();
 213:bootSAH_7.c   **** }
 214:bootSAH_7.c   **** 
 215:bootSAH_7.c   **** void FLASH_WriteEnable(void)
 216:bootSAH_7.c   **** {
 217:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 218:bootSAH_7.c   **** 	SPI_Transfer(0x06);
 219:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 220:bootSAH_7.c   **** 	tiny_delay();
 221:bootSAH_7.c   **** }
 222:bootSAH_7.c   **** 
 223:bootSAH_7.c   **** /*
 224:bootSAH_7.c   **** static uint16_t FLASH_ReadWord(uint32_t faddr)
 225:bootSAH_7.c   **** {
 226:bootSAH_7.c   **** 	uint16_t fRdTemp=0;
 227:bootSAH_7.c   **** 	FLASH_UntilReady();
 228:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 229:bootSAH_7.c   **** 	SPI_Transfer(0x03);
 230:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 231:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 232:bootSAH_7.c   **** 	SPI_Transfer(faddr & 0xff);
 233:bootSAH_7.c   **** 	fRdTemp = (uint16_t)SPI_Transfer(0) << 8;
 234:bootSAH_7.c   **** 	fRdTemp |= (uint16_t)SPI_Transfer(0);
 235:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 236:bootSAH_7.c   **** 	tiny_delay();
 237:bootSAH_7.c   **** 	return fRdTemp;
 238:bootSAH_7.c   **** }
 239:bootSAH_7.c   **** */
 240:bootSAH_7.c   **** 
 241:bootSAH_7.c   **** void FLASH_EraseSector(uint32_t faddr)
 242:bootSAH_7.c   **** {
 243:bootSAH_7.c   **** 	FLASH_UntilReady();
 244:bootSAH_7.c   **** 	FLASH_WriteEnable();
 245:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 246:bootSAH_7.c   **** 	SPI_Transfer(0x20);
 247:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 248:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 249:bootSAH_7.c   **** 	SPI_Transfer(faddr & 0xff);
 250:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 251:bootSAH_7.c   **** 	tiny_delay();
 252:bootSAH_7.c   **** 	FLASH_UntilReady();
 253:bootSAH_7.c   **** }
 254:bootSAH_7.c   **** 
 255:bootSAH_7.c   **** void FLASH_WriteByte(uint32_t faddr, uint8_t wdata)
 256:bootSAH_7.c   **** {
 257:bootSAH_7.c   **** 	FLASH_UntilReady();
 258:bootSAH_7.c   **** 	FLASH_WriteEnable();
 259:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 260:bootSAH_7.c   **** 	SPI_Transfer(0x02);
 261:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 262:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 263:bootSAH_7.c   **** 	SPI_Transfer(faddr & 0xff);
 264:bootSAH_7.c   **** 	SPI_Transfer(wdata & 0xff);
 265:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 266:bootSAH_7.c   **** 	tiny_delay();
 267:bootSAH_7.c   **** 	FLASH_UntilReady();
 268:bootSAH_7.c   **** }
 269:bootSAH_7.c   **** 
 270:bootSAH_7.c   **** //******************************************************************
 271:bootSAH_7.c   **** static void sendchar(char c)
 272:bootSAH_7.c   **** {
  46               		.loc 1 272 0
  47               		.cfi_startproc
  48               	.LVL2:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 273:bootSAH_7.c   **** 	UART_DATA_REG	=	c;										// prepare transmission
  53               		.loc 1 273 0
  54 000e 8093 C600 		sts 198,r24
  55               	.LVL3:
  56               	.L6:
 274:bootSAH_7.c   **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  57               		.loc 1 274 0 discriminator 1
  58 0012 8091 C000 		lds r24,192
  59 0016 86FF      		sbrs r24,6
  60 0018 00C0      		rjmp .L6
 275:bootSAH_7.c   **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  61               		.loc 1 275 0
  62 001a 8091 C000 		lds r24,192
  63 001e 8064      		ori r24,lo8(64)
  64 0020 8093 C000 		sts 192,r24
  65               	.LVL4:
  66 0024 0895      		ret
  67               		.cfi_endproc
  68               	.LFE20:
  70               	.global	delay_ms
  72               	delay_ms:
  73               	.LFB11:
 158:bootSAH_7.c   **** 	unsigned int i;
  74               		.loc 1 158 0
  75               		.cfi_startproc
  76               	.LVL5:
  77               	/* prologue: function */
  78               	/* frame size = 0 */
  79               	/* stack size = 0 */
  80               	.L__stack_usage = 0
 160:bootSAH_7.c   **** 	{
  81               		.loc 1 160 0
  82 0026 20E0      		ldi r18,0
  83 0028 30E0      		ldi r19,0
  84               	.LVL6:
  85               	.L10:
 160:bootSAH_7.c   **** 	{
  86               		.loc 1 160 0 is_stmt 0 discriminator 1
  87 002a 2817      		cp r18,r24
  88 002c 3907      		cpc r19,r25
  89 002e 01F0      		breq .L12
  90               	.LVL7:
  91               	.LBB4:
  92               	.LBB5:
  93               		.file 2 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ut
   1:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  94               		.loc 2 187 0 is_stmt 1
  95 0030 EFEC      		ldi r30,lo8(1999)
  96 0032 F7E0      		ldi r31,hi8(1999)
  97 0034 3197      	1:	sbiw r30,1
  98 0036 01F4      		brne 1b
  99 0038 00C0      		rjmp .
 100 003a 0000      		nop
 101               	.LVL8:
 102               	.LBE5:
 103               	.LBE4:
 160:bootSAH_7.c   **** 	{
 104               		.loc 1 160 0
 105 003c 2F5F      		subi r18,-1
 106 003e 3F4F      		sbci r19,-1
 107               	.LVL9:
 108 0040 00C0      		rjmp .L10
 109               	.L12:
 110               	/* epilogue start */
 164:bootSAH_7.c   **** //** small delay
 111               		.loc 1 164 0
 112 0042 0895      		ret
 113               		.cfi_endproc
 114               	.LFE11:
 116               	.global	tiny_delay
 118               	tiny_delay:
 119               	.LFB12:
 167:bootSAH_7.c   **** 	asm volatile(
 120               		.loc 1 167 0
 121               		.cfi_startproc
 122               	/* prologue: function */
 123               	/* frame size = 0 */
 124               	/* stack size = 0 */
 125               	.L__stack_usage = 0
 168:bootSAH_7.c   **** 					"nop	\n\t"
 126               		.loc 1 168 0
 127               	/* #APP */
 128               	 ;  168 "bootSAH_7.c" 1
 129 0044 0000      		nop	
 130 0046 0000      		nop	
 131 0048 0000      		nop	
 132 004a 0000      		nop	
 133 004c 0000      		nop	
 134               		
 135               	 ;  0 "" 2
 136               	/* #NOAPP */
 137 004e 0895      		ret
 138               		.cfi_endproc
 139               	.LFE12:
 141               	.global	FLASH_UntilReady
 143               	FLASH_UntilReady:
 144               	.LFB14:
 187:bootSAH_7.c   **** 	uint8_t stat=0xff;
 145               		.loc 1 187 0
 146               		.cfi_startproc
 147               	/* prologue: function */
 148               	/* frame size = 0 */
 149               	/* stack size = 0 */
 150               	.L__stack_usage = 0
 151               	.LVL10:
 189:bootSAH_7.c   **** 	SPI_Transfer(0x05);
 152               		.loc 1 189 0
 153 0050 2898      		cbi 0x5,0
 190:bootSAH_7.c   **** 	while((stat & 0x01) == 0x01)
 154               		.loc 1 190 0
 155 0052 85E0      		ldi r24,lo8(5)
 156 0054 0E94 0000 		call SPI_Transfer
 157               	.LVL11:
 188:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 158               		.loc 1 188 0
 159 0058 8FEF      		ldi r24,lo8(-1)
 160               	.LVL12:
 161               	.L15:
 191:bootSAH_7.c   **** 	{
 162               		.loc 1 191 0
 163 005a 80FF      		sbrs r24,0
 164 005c 00C0      		rjmp .L17
 193:bootSAH_7.c   **** 	}
 165               		.loc 1 193 0
 166 005e 80E0      		ldi r24,0
 167 0060 0E94 0000 		call SPI_Transfer
 168               	.LVL13:
 169 0064 00C0      		rjmp .L15
 170               	.LVL14:
 171               	.L17:
 195:bootSAH_7.c   **** 	tiny_delay();
 172               		.loc 1 195 0
 173 0066 289A      		sbi 0x5,0
 196:bootSAH_7.c   **** }
 174               		.loc 1 196 0
 175 0068 0C94 0000 		jmp tiny_delay
 176               	.LVL15:
 177               		.cfi_endproc
 178               	.LFE14:
 180               	.global	FLASH_ResetEnable
 182               	FLASH_ResetEnable:
 183               	.LFB15:
 200:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 184               		.loc 1 200 0
 185               		.cfi_startproc
 186               	/* prologue: function */
 187               	/* frame size = 0 */
 188               	/* stack size = 0 */
 189               	.L__stack_usage = 0
 201:bootSAH_7.c   **** 	SPI_Transfer(0x66);
 190               		.loc 1 201 0
 191 006c 2898      		cbi 0x5,0
 202:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 192               		.loc 1 202 0
 193 006e 86E6      		ldi r24,lo8(102)
 194 0070 0E94 0000 		call SPI_Transfer
 195               	.LVL16:
 203:bootSAH_7.c   **** 	tiny_delay();
 196               		.loc 1 203 0
 197 0074 289A      		sbi 0x5,0
 204:bootSAH_7.c   **** }
 198               		.loc 1 204 0
 199 0076 0C94 0000 		jmp tiny_delay
 200               	.LVL17:
 201               		.cfi_endproc
 202               	.LFE15:
 204               	.global	FLASH_Reset
 206               	FLASH_Reset:
 207               	.LFB16:
 208:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 208               		.loc 1 208 0
 209               		.cfi_startproc
 210               	/* prologue: function */
 211               	/* frame size = 0 */
 212               	/* stack size = 0 */
 213               	.L__stack_usage = 0
 209:bootSAH_7.c   **** 	SPI_Transfer(0x99);
 214               		.loc 1 209 0
 215 007a 2898      		cbi 0x5,0
 210:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 216               		.loc 1 210 0
 217 007c 89E9      		ldi r24,lo8(-103)
 218 007e 0E94 0000 		call SPI_Transfer
 219               	.LVL18:
 211:bootSAH_7.c   **** 	tiny_delay();
 220               		.loc 1 211 0
 221 0082 289A      		sbi 0x5,0
 212:bootSAH_7.c   **** }
 222               		.loc 1 212 0
 223 0084 0C94 0000 		jmp tiny_delay
 224               	.LVL19:
 225               		.cfi_endproc
 226               	.LFE16:
 228               	.global	FLASH_WriteEnable
 230               	FLASH_WriteEnable:
 231               	.LFB17:
 216:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 232               		.loc 1 216 0
 233               		.cfi_startproc
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
 217:bootSAH_7.c   **** 	SPI_Transfer(0x06);
 238               		.loc 1 217 0
 239 0088 2898      		cbi 0x5,0
 218:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 240               		.loc 1 218 0
 241 008a 86E0      		ldi r24,lo8(6)
 242 008c 0E94 0000 		call SPI_Transfer
 243               	.LVL20:
 219:bootSAH_7.c   **** 	tiny_delay();
 244               		.loc 1 219 0
 245 0090 289A      		sbi 0x5,0
 220:bootSAH_7.c   **** }
 246               		.loc 1 220 0
 247 0092 0C94 0000 		jmp tiny_delay
 248               	.LVL21:
 249               		.cfi_endproc
 250               	.LFE17:
 252               	.global	FLASH_EraseSector
 254               	FLASH_EraseSector:
 255               	.LFB18:
 242:bootSAH_7.c   **** 	FLASH_UntilReady();
 256               		.loc 1 242 0
 257               		.cfi_startproc
 258               	.LVL22:
 259 0096 1F93      		push r17
 260               	.LCFI0:
 261               		.cfi_def_cfa_offset 4
 262               		.cfi_offset 17, -3
 263 0098 CF93      		push r28
 264               	.LCFI1:
 265               		.cfi_def_cfa_offset 5
 266               		.cfi_offset 28, -4
 267 009a DF93      		push r29
 268               	.LCFI2:
 269               		.cfi_def_cfa_offset 6
 270               		.cfi_offset 29, -5
 271               	/* prologue: function */
 272               	/* frame size = 0 */
 273               	/* stack size = 3 */
 274               	.L__stack_usage = 3
 275 009c EB01      		movw r28,r22
 276 009e 182F      		mov r17,r24
 243:bootSAH_7.c   **** 	FLASH_WriteEnable();
 277               		.loc 1 243 0
 278 00a0 0E94 0000 		call FLASH_UntilReady
 279               	.LVL23:
 244:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 280               		.loc 1 244 0
 281 00a4 0E94 0000 		call FLASH_WriteEnable
 282               	.LVL24:
 245:bootSAH_7.c   **** 	SPI_Transfer(0x20);
 283               		.loc 1 245 0
 284 00a8 2898      		cbi 0x5,0
 246:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 285               		.loc 1 246 0
 286 00aa 80E2      		ldi r24,lo8(32)
 287 00ac 0E94 0000 		call SPI_Transfer
 288               	.LVL25:
 247:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 289               		.loc 1 247 0
 290 00b0 812F      		mov r24,r17
 291 00b2 0E94 0000 		call SPI_Transfer
 292               	.LVL26:
 248:bootSAH_7.c   **** 	SPI_Transfer(faddr & 0xff);
 293               		.loc 1 248 0
 294 00b6 8D2F      		mov r24,r29
 295 00b8 0E94 0000 		call SPI_Transfer
 296               	.LVL27:
 249:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 297               		.loc 1 249 0
 298 00bc 8C2F      		mov r24,r28
 299 00be 0E94 0000 		call SPI_Transfer
 300               	.LVL28:
 250:bootSAH_7.c   **** 	tiny_delay();
 301               		.loc 1 250 0
 302 00c2 289A      		sbi 0x5,0
 251:bootSAH_7.c   **** 	FLASH_UntilReady();
 303               		.loc 1 251 0
 304 00c4 0E94 0000 		call tiny_delay
 305               	.LVL29:
 306               	/* epilogue start */
 253:bootSAH_7.c   **** 
 307               		.loc 1 253 0
 308 00c8 DF91      		pop r29
 309 00ca CF91      		pop r28
 310 00cc 1F91      		pop r17
 252:bootSAH_7.c   **** }
 311               		.loc 1 252 0
 312 00ce 0C94 0000 		jmp FLASH_UntilReady
 313               	.LVL30:
 314               		.cfi_endproc
 315               	.LFE18:
 317               	.global	FLASH_WriteByte
 319               	FLASH_WriteByte:
 320               	.LFB19:
 256:bootSAH_7.c   **** 	FLASH_UntilReady();
 321               		.loc 1 256 0
 322               		.cfi_startproc
 323               	.LVL31:
 324 00d2 0F93      		push r16
 325               	.LCFI3:
 326               		.cfi_def_cfa_offset 4
 327               		.cfi_offset 16, -3
 328 00d4 1F93      		push r17
 329               	.LCFI4:
 330               		.cfi_def_cfa_offset 5
 331               		.cfi_offset 17, -4
 332 00d6 CF93      		push r28
 333               	.LCFI5:
 334               		.cfi_def_cfa_offset 6
 335               		.cfi_offset 28, -5
 336 00d8 DF93      		push r29
 337               	.LCFI6:
 338               		.cfi_def_cfa_offset 7
 339               		.cfi_offset 29, -6
 340               	/* prologue: function */
 341               	/* frame size = 0 */
 342               	/* stack size = 4 */
 343               	.L__stack_usage = 4
 344 00da D62F      		mov r29,r22
 345 00dc 172F      		mov r17,r23
 346 00de 082F      		mov r16,r24
 347 00e0 C42F      		mov r28,r20
 257:bootSAH_7.c   **** 	FLASH_WriteEnable();
 348               		.loc 1 257 0
 349 00e2 0E94 0000 		call FLASH_UntilReady
 350               	.LVL32:
 258:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 351               		.loc 1 258 0
 352 00e6 0E94 0000 		call FLASH_WriteEnable
 353               	.LVL33:
 259:bootSAH_7.c   **** 	SPI_Transfer(0x02);
 354               		.loc 1 259 0
 355 00ea 2898      		cbi 0x5,0
 260:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 16) & 0xff);
 356               		.loc 1 260 0
 357 00ec 82E0      		ldi r24,lo8(2)
 358 00ee 0E94 0000 		call SPI_Transfer
 359               	.LVL34:
 261:bootSAH_7.c   **** 	SPI_Transfer((faddr >> 8) & 0xff);
 360               		.loc 1 261 0
 361 00f2 802F      		mov r24,r16
 362 00f4 0E94 0000 		call SPI_Transfer
 363               	.LVL35:
 262:bootSAH_7.c   **** 	SPI_Transfer(faddr & 0xff);
 364               		.loc 1 262 0
 365 00f8 812F      		mov r24,r17
 366 00fa 0E94 0000 		call SPI_Transfer
 367               	.LVL36:
 263:bootSAH_7.c   **** 	SPI_Transfer(wdata & 0xff);
 368               		.loc 1 263 0
 369 00fe 8D2F      		mov r24,r29
 370 0100 0E94 0000 		call SPI_Transfer
 371               	.LVL37:
 264:bootSAH_7.c   **** 	PROG_PORT  |=   (1<<PROG_SPI_CS);
 372               		.loc 1 264 0
 373 0104 8C2F      		mov r24,r28
 374 0106 0E94 0000 		call SPI_Transfer
 375               	.LVL38:
 265:bootSAH_7.c   **** 	tiny_delay();
 376               		.loc 1 265 0
 377 010a 289A      		sbi 0x5,0
 266:bootSAH_7.c   **** 	FLASH_UntilReady();
 378               		.loc 1 266 0
 379 010c 0E94 0000 		call tiny_delay
 380               	.LVL39:
 381               	/* epilogue start */
 268:bootSAH_7.c   **** 
 382               		.loc 1 268 0
 383 0110 DF91      		pop r29
 384 0112 CF91      		pop r28
 385               	.LVL40:
 386 0114 1F91      		pop r17
 387 0116 0F91      		pop r16
 267:bootSAH_7.c   **** }
 388               		.loc 1 267 0
 389 0118 0C94 0000 		jmp FLASH_UntilReady
 390               	.LVL41:
 391               		.cfi_endproc
 392               	.LFE19:
 394               		.section	.init9,"ax",@progbits
 395               	.global	__jumpMain
 397               	__jumpMain:
 398               	.LFB24:
 276:bootSAH_7.c   **** }
 277:bootSAH_7.c   **** 
 278:bootSAH_7.c   **** static int	Serial_Available(void)
 279:bootSAH_7.c   **** {
 280:bootSAH_7.c   **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 281:bootSAH_7.c   **** }
 282:bootSAH_7.c   **** 
 283:bootSAH_7.c   **** static unsigned char recchar(void)
 284:bootSAH_7.c   **** {
 285:bootSAH_7.c   **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 286:bootSAH_7.c   **** 	{
 287:bootSAH_7.c   **** 		// wait for data
 288:bootSAH_7.c   **** 	}
 289:bootSAH_7.c   **** 	return UART_DATA_REG;
 290:bootSAH_7.c   **** }
 291:bootSAH_7.c   **** 
 292:bootSAH_7.c   **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 293:bootSAH_7.c   **** //*****************************************************************************
 294:bootSAH_7.c   **** static unsigned char recchar_timeout(void)
 295:bootSAH_7.c   **** {
 296:bootSAH_7.c   **** uint32_t count = 0;
 297:bootSAH_7.c   **** 
 298:bootSAH_7.c   **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 299:bootSAH_7.c   **** 	{
 300:bootSAH_7.c   **** 		// wait for data
 301:bootSAH_7.c   **** 		count++;
 302:bootSAH_7.c   **** 		if (count > MAX_TIME_COUNT)
 303:bootSAH_7.c   **** 		{
 304:bootSAH_7.c   **** 		unsigned int	data;
 305:bootSAH_7.c   **** 		#if (FLASHEND > 0x10000)
 306:bootSAH_7.c   **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 307:bootSAH_7.c   **** 		#else
 308:bootSAH_7.c   **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 309:bootSAH_7.c   **** 		#endif
 310:bootSAH_7.c   **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 311:bootSAH_7.c   **** 			{
 312:bootSAH_7.c   **** 				asm volatile(
 313:bootSAH_7.c   **** 						"clr	r30		\n\t"
 314:bootSAH_7.c   **** 						"clr	r31		\n\t"
 315:bootSAH_7.c   **** 						"ijmp	\n\t"
 316:bootSAH_7.c   **** 						);
 317:bootSAH_7.c   **** 			}
 318:bootSAH_7.c   **** 			count	=	0;
 319:bootSAH_7.c   **** 		}
 320:bootSAH_7.c   **** 	}
 321:bootSAH_7.c   **** 	return UART_DATA_REG;
 322:bootSAH_7.c   **** }
 323:bootSAH_7.c   **** 
 324:bootSAH_7.c   **** /*
 325:bootSAH_7.c   **** static void printByte(uint8_t numData)
 326:bootSAH_7.c   **** {
 327:bootSAH_7.c   **** 	char chData1, chData2;
 328:bootSAH_7.c   **** 	
 329:bootSAH_7.c   **** 	chData1 = hexArr[(numData >> 4)];
 330:bootSAH_7.c   **** 	sendchar(chData1);
 331:bootSAH_7.c   **** 	chData2 = hexArr[(numData & 0xF)];
 332:bootSAH_7.c   **** 	sendchar(chData2);
 333:bootSAH_7.c   **** }
 334:bootSAH_7.c   **** */
 335:bootSAH_7.c   **** 
 336:bootSAH_7.c   **** /*
 337:bootSAH_7.c   ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 338:bootSAH_7.c   ****  * to reduce the code size, we need to provide our own initialization
 339:bootSAH_7.c   ****  */
 340:bootSAH_7.c   **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 341:bootSAH_7.c   **** #include <avr/sfr_defs.h>
 342:bootSAH_7.c   **** 
 343:bootSAH_7.c   **** //*****************************************************************************
 344:bootSAH_7.c   **** void __jumpMain(void)
 345:bootSAH_7.c   **** {
 399               		.loc 1 345 0
 400               		.cfi_startproc
 401               	/* prologue: naked */
 402               	/* frame size = 0 */
 403               	/* stack size = 0 */
 404               	.L__stack_usage = 0
 346:bootSAH_7.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 347:bootSAH_7.c   **** //*	the first line did not do the job on the ATmega128
 348:bootSAH_7.c   **** 
 349:bootSAH_7.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 405               		.loc 1 349 0
 406               	/* #APP */
 407               	 ;  349 "bootSAH_7.c" 1
 408               		.set __stack, 8703
 409               	 ;  0 "" 2
 350:bootSAH_7.c   **** 
 351:bootSAH_7.c   **** //*	set stack pointer to top of RAM
 352:bootSAH_7.c   **** 
 353:bootSAH_7.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 410               		.loc 1 353 0
 411               	 ;  353 "bootSAH_7.c" 1
 412 0000 01E2      		ldi	16, 33
 413               	 ;  0 "" 2
 354:bootSAH_7.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 414               		.loc 1 354 0
 415               	 ;  354 "bootSAH_7.c" 1
 416 0002 0EBF      		out 62,16
 417               	 ;  0 "" 2
 355:bootSAH_7.c   **** 
 356:bootSAH_7.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 418               		.loc 1 356 0
 419               	 ;  356 "bootSAH_7.c" 1
 420 0004 0FEF      		ldi	16, 255
 421               	 ;  0 "" 2
 357:bootSAH_7.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 422               		.loc 1 357 0
 423               	 ;  357 "bootSAH_7.c" 1
 424 0006 0DBF      		out 61,16
 425               	 ;  0 "" 2
 358:bootSAH_7.c   **** 
 359:bootSAH_7.c   **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 426               		.loc 1 359 0
 427               	 ;  359 "bootSAH_7.c" 1
 428 0008 1124      		clr __zero_reg__
 429               	 ;  0 "" 2
 360:bootSAH_7.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 430               		.loc 1 360 0
 431               	 ;  360 "bootSAH_7.c" 1
 432 000a 1FBE      		out 63, __zero_reg__
 433               	 ;  0 "" 2
 361:bootSAH_7.c   **** 	asm volatile ( "jmp main");												// jump to main()
 434               		.loc 1 361 0
 435               	 ;  361 "bootSAH_7.c" 1
 436 000c 0C94 0000 		jmp main
 437               	 ;  0 "" 2
 438               	/* epilogue start */
 362:bootSAH_7.c   **** }
 439               		.loc 1 362 0
 440               	/* #NOAPP */
 441               		.cfi_endproc
 442               	.LFE24:
 444               		.section	.text.startup,"ax",@progbits
 445               	.global	main
 447               	main:
 448               	.LFB25:
 363:bootSAH_7.c   **** 
 364:bootSAH_7.c   **** //*	for watch dog timer startup
 365:bootSAH_7.c   **** void (*app_start)(void) = 0x0000;
 366:bootSAH_7.c   **** 
 367:bootSAH_7.c   **** int main(void)
 368:bootSAH_7.c   **** {
 449               		.loc 1 368 0
 450               		.cfi_startproc
 451 0000 CF93      		push r28
 452               	.LCFI7:
 453               		.cfi_def_cfa_offset 4
 454               		.cfi_offset 28, -3
 455 0002 DF93      		push r29
 456               	.LCFI8:
 457               		.cfi_def_cfa_offset 5
 458               		.cfi_offset 29, -4
 459 0004 CDB7      		in r28,__SP_L__
 460 0006 DEB7      		in r29,__SP_H__
 461               	.LCFI9:
 462               		.cfi_def_cfa_register 28
 463 0008 C352      		subi r28,35
 464 000a D140      		sbci r29,1
 465               	.LCFI10:
 466               		.cfi_def_cfa_offset 296
 467 000c 0FB6      		in __tmp_reg__,__SREG__
 468 000e F894      		cli
 469 0010 DEBF      		out __SP_H__,r29
 470 0012 0FBE      		out __SREG__,__tmp_reg__
 471 0014 CDBF      		out __SP_L__,r28
 472               	/* prologue: function */
 473               	/* frame size = 291 */
 474               	/* stack size = 293 */
 475               	.L__stack_usage = 293
 476               	.LVL42:
 369:bootSAH_7.c   **** 	uint32_t exfMemStat = 0;
 370:bootSAH_7.c   **** 	
 371:bootSAH_7.c   **** 	uint32_t exfBStatAddr = 0;
 372:bootSAH_7.c   **** 	uint16_t exfBootStat  = 0;
 373:bootSAH_7.c   **** 	
 374:bootSAH_7.c   **** 	uint32_t exfDLenAddr  = 0;
 375:bootSAH_7.c   **** 	uint16_t exfDataLen   = 0;
 376:bootSAH_7.c   **** 	
 377:bootSAH_7.c   **** 	uint32_t exfDataAddr  = 0;
 378:bootSAH_7.c   **** 	uint8_t  RdData		  = 0;			// c
 379:bootSAH_7.c   **** 	//uint8_t  fRdTries   = 0;
 380:bootSAH_7.c   **** 	
 381:bootSAH_7.c   **** 	uint32_t exfCsumAddr  = 0;
 382:bootSAH_7.c   **** 	uint16_t exfChSumCal  = 0;
 383:bootSAH_7.c   **** 	uint16_t exfChSumRev  = 0;
 384:bootSAH_7.c   **** 	
 385:bootSAH_7.c   **** 	//address_t address	= 0;
 386:bootSAH_7.c   **** 	//address_t fPageAddr = 0;
 387:bootSAH_7.c   **** 	
 388:bootSAH_7.c   **** 	uint32_t fTmpPgAddr	= 0;	// address
 389:bootSAH_7.c   **** 	uint32_t fPageAddr  = 0;	// eraseAddress
 390:bootSAH_7.c   **** 	
 391:bootSAH_7.c   **** 	//unsigned char	msgBuffer[285];
 392:bootSAH_7.c   **** 	uint8_t fMsgBuff[285];		// msgBuffer[285];
 393:bootSAH_7.c   **** 	//uint8_t	*p;
 394:bootSAH_7.c   **** 	
 395:bootSAH_7.c   **** 	uint8_t  fLSByte, fMSByte;
 396:bootSAH_7.c   **** 	uint16_t fDataWord;
 397:bootSAH_7.c   **** 	//uint16_t fExMemSize, fInMemSize;
 398:bootSAH_7.c   **** 	//uint16_t fExMemInc, fInMemInc;
 399:bootSAH_7.c   **** 	uint16_t fMemSize;
 400:bootSAH_7.c   **** 	uint16_t fIndex;		// ii
 401:bootSAH_7.c   **** 		
 402:bootSAH_7.c   **** 	uint32_t boot_timeout;
 403:bootSAH_7.c   **** 	uint32_t boot_timer;
 404:bootSAH_7.c   **** 	uint8_t boot_state;	
 405:bootSAH_7.c   **** 
 406:bootSAH_7.c   **** //************************************************************************
 407:bootSAH_7.c   **** 	
 408:bootSAH_7.c   **** 	//*	some chips dont set the stack properly
 409:bootSAH_7.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 477               		.loc 1 409 0
 478               	/* #APP */
 479               	 ;  409 "bootSAH_7.c" 1
 480               		.set __stack, 8703
 481               	 ;  0 "" 2
 410:bootSAH_7.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 482               		.loc 1 410 0
 483               	 ;  410 "bootSAH_7.c" 1
 484 0016 01E2      		ldi	16, 33
 485               	 ;  0 "" 2
 411:bootSAH_7.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 486               		.loc 1 411 0
 487               	 ;  411 "bootSAH_7.c" 1
 488 0018 0EBF      		out 62,16
 489               	 ;  0 "" 2
 412:bootSAH_7.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 490               		.loc 1 412 0
 491               	 ;  412 "bootSAH_7.c" 1
 492 001a 0FEF      		ldi	16, 255
 493               	 ;  0 "" 2
 413:bootSAH_7.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 494               		.loc 1 413 0
 495               	 ;  413 "bootSAH_7.c" 1
 496 001c 0DBF      		out 61,16
 497               	 ;  0 "" 2
 414:bootSAH_7.c   **** 	
 415:bootSAH_7.c   **** //************************************************************************
 416:bootSAH_7.c   **** 
 417:bootSAH_7.c   **** //*	handle the watch dog timer
 418:bootSAH_7.c   **** 	uint8_t	mcuStatusReg;
 419:bootSAH_7.c   **** 	mcuStatusReg	=	MCUSR;
 498               		.loc 1 419 0
 499               	/* #NOAPP */
 500 001e 94B7      		in r25,0x34
 501               	.LVL43:
 420:bootSAH_7.c   **** 
 421:bootSAH_7.c   **** 	__asm__ __volatile__ ("cli");
 502               		.loc 1 421 0
 503               	/* #APP */
 504               	 ;  421 "bootSAH_7.c" 1
 505 0020 F894      		cli
 506               	 ;  0 "" 2
 422:bootSAH_7.c   **** 	__asm__ __volatile__ ("wdr");
 507               		.loc 1 422 0
 508               	 ;  422 "bootSAH_7.c" 1
 509 0022 A895      		wdr
 510               	 ;  0 "" 2
 423:bootSAH_7.c   **** 	
 424:bootSAH_7.c   **** 	//MCUSR	=	0;
 425:bootSAH_7.c   **** 	MCUSR &= ~(1<<WDRF);
 511               		.loc 1 425 0
 512               	/* #NOAPP */
 513 0024 84B7      		in r24,0x34
 514 0026 877F      		andi r24,lo8(-9)
 515 0028 84BF      		out 0x34,r24
 426:bootSAH_7.c   **** 	
 427:bootSAH_7.c   **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 516               		.loc 1 427 0
 517 002a 8091 6000 		lds r24,96
 518 002e 8861      		ori r24,lo8(24)
 519 0030 8093 6000 		sts 96,r24
 428:bootSAH_7.c   **** 	WDTCSR	=	0;
 520               		.loc 1 428 0
 521 0034 1092 6000 		sts 96,__zero_reg__
 429:bootSAH_7.c   **** 	__asm__ __volatile__ ("sei");
 522               		.loc 1 429 0
 523               	/* #APP */
 524               	 ;  429 "bootSAH_7.c" 1
 525 0038 7894      		sei
 526               	 ;  0 "" 2
 430:bootSAH_7.c   **** 	// check if WDT generated the reset, if so, go straight to app
 431:bootSAH_7.c   **** 	if (mcuStatusReg & _BV(WDRF))
 527               		.loc 1 431 0
 528               	/* #NOAPP */
 529 003a 93FF      		sbrs r25,3
 530 003c 00C0      		rjmp .L25
 432:bootSAH_7.c   **** 	{
 433:bootSAH_7.c   **** 		app_start();
 531               		.loc 1 433 0
 532 003e E091 0000 		lds r30,app_start
 533 0042 F091 0000 		lds r31,app_start+1
 534 0046 1995      		eicall
 535               	.LVL44:
 536               	.L25:
 434:bootSAH_7.c   **** 	}
 435:bootSAH_7.c   **** 	
 436:bootSAH_7.c   **** //************************************************************************
 437:bootSAH_7.c   **** 
 438:bootSAH_7.c   **** //* Initialize SPI
 439:bootSAH_7.c   **** 	PROG_DDR = ((0<<PROG_SPI_MISO)|
 537               		.loc 1 439 0
 538 0048 87E0      		ldi r24,lo8(7)
 539 004a 84B9      		out 0x4,r24
 440:bootSAH_7.c   **** 				(1<<PROG_SPI_MOSI)|
 441:bootSAH_7.c   **** 				(1<<PROG_SPI_SCK) |
 442:bootSAH_7.c   **** 				(1<<PROG_SPI_CS)
 443:bootSAH_7.c   **** 			   );
 444:bootSAH_7.c   **** 
 445:bootSAH_7.c   **** 	SPCR = (	(1<<SPE) |              // SPI Enable
 540               		.loc 1 445 0
 541 004c 81E5      		ldi r24,lo8(81)
 542 004e 8CBD      		out 0x2c,r24
 446:bootSAH_7.c   **** 				(0<<SPIE)|              // SPI Interrupt Enable
 447:bootSAH_7.c   **** 				(0<<DORD)|              // Data Order (0:MSB first / 1:LSB first)
 448:bootSAH_7.c   **** 				(1<<MSTR)|              // Master/Slave select
 449:bootSAH_7.c   **** 				(0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
 450:bootSAH_7.c   **** 				(0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
 451:bootSAH_7.c   **** 				(0<<CPHA)               // Clock Phase (0:leading / 1:trailing edge sampling)
 452:bootSAH_7.c   **** 			);
 453:bootSAH_7.c   **** 			
 454:bootSAH_7.c   **** 	PROG_PORT |=  (1<<PROG_SPI_CS); 			// pull high
 543               		.loc 1 454 0
 544 0050 289A      		sbi 0x5,0
 455:bootSAH_7.c   **** 	
 456:bootSAH_7.c   **** 	asm volatile ("nop");				// wait until port has changed
 545               		.loc 1 456 0
 546               	/* #APP */
 547               	 ;  456 "bootSAH_7.c" 1
 548 0052 0000      		nop
 549               	 ;  0 "" 2
 550               	.LVL45:
 457:bootSAH_7.c   **** 	
 458:bootSAH_7.c   **** //************************************************************************
 459:bootSAH_7.c   **** 
 460:bootSAH_7.c   **** 	exfBStatAddr = BOOT_STAT_ADDR;
 461:bootSAH_7.c   **** 	exfDLenAddr  = BOOT_STAT_ADDR + 2;
 462:bootSAH_7.c   **** 	exfDataAddr  = BOOT_DATA_ADDR;
 463:bootSAH_7.c   **** 	exfCsumAddr  = BOOT_CSUM_ADDR;
 464:bootSAH_7.c   **** 	fPageAddr	 = 0;
 465:bootSAH_7.c   **** 	
 466:bootSAH_7.c   **** //************************************************************************	
 467:bootSAH_7.c   **** //* Initialize ExFlash
 468:bootSAH_7.c   **** 	FLASH_UntilReady();
 551               		.loc 1 468 0
 552               	/* #NOAPP */
 553 0054 0E94 0000 		call FLASH_UntilReady
 554               	.LVL46:
 469:bootSAH_7.c   **** 	FLASH_ResetEnable();
 555               		.loc 1 469 0
 556 0058 0E94 0000 		call FLASH_ResetEnable
 557               	.LVL47:
 470:bootSAH_7.c   **** 	FLASH_Reset();
 558               		.loc 1 470 0
 559 005c 0E94 0000 		call FLASH_Reset
 560               	.LVL48:
 471:bootSAH_7.c   **** 	
 472:bootSAH_7.c   **** 	PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 561               		.loc 1 472 0
 562 0060 2898      		cbi 0x5,0
 473:bootSAH_7.c   **** 	SPI_Transfer(0x9F);
 563               		.loc 1 473 0
 564 0062 8FE9      		ldi r24,lo8(-97)
 565 0064 0E94 0000 		call SPI_Transfer
 566               	.LVL49:
 474:bootSAH_7.c   **** 	exfMemStat = (uint32_t)SPI_Transfer(0) << 16;
 567               		.loc 1 474 0
 568 0068 80E0      		ldi r24,0
 569 006a 0E94 0000 		call SPI_Transfer
 570               	.LVL50:
 571 006e C82E      		mov r12,r24
 572 0070 D12C      		mov r13,__zero_reg__
 573 0072 E12C      		mov r14,__zero_reg__
 574 0074 F12C      		mov r15,__zero_reg__
 575 0076 7601      		movw r14,r12
 576 0078 DD24      		clr r13
 577 007a CC24      		clr r12
 578               	.LVL51:
 475:bootSAH_7.c   **** 	exfMemStat |= (uint32_t)SPI_Transfer(0) << 8;
 579               		.loc 1 475 0
 580 007c 80E0      		ldi r24,0
 581 007e 0E94 0000 		call SPI_Transfer
 582               	.LVL52:
 583 0082 D82A      		or r13,r24
 476:bootSAH_7.c   **** 	exfMemStat |= (uint32_t)SPI_Transfer(0);
 584               		.loc 1 476 0
 585 0084 80E0      		ldi r24,0
 586 0086 0E94 0000 		call SPI_Transfer
 587               	.LVL53:
 477:bootSAH_7.c   **** 	PROG_PORT |=  (1<<PROG_SPI_CS);
 588               		.loc 1 477 0
 589 008a 289A      		sbi 0x5,0
 478:bootSAH_7.c   **** 
 479:bootSAH_7.c   **** 	if(exfMemStat == EXMEM_JEDEC)
 590               		.loc 1 479 0
 591 008c C82A      		or r12,r24
 592               	.LVL54:
 593 008e 27E1      		ldi r18,23
 594 0090 C216      		cp r12,r18
 595 0092 20E4      		ldi r18,64
 596 0094 D206      		cpc r13,r18
 597 0096 2FEE      		ldi r18,-17
 598 0098 E206      		cpc r14,r18
 599 009a F104      		cpc r15,__zero_reg__
 600 009c 01F0      		breq .+2
 601 009e 00C0      		rjmp .L27
 480:bootSAH_7.c   **** 	{
 481:bootSAH_7.c   **** 		PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 602               		.loc 1 481 0
 603 00a0 2898      		cbi 0x5,0
 482:bootSAH_7.c   **** 		SPI_Transfer(0x03);
 604               		.loc 1 482 0
 605 00a2 83E0      		ldi r24,lo8(3)
 606 00a4 0E94 0000 		call SPI_Transfer
 607               	.LVL55:
 483:bootSAH_7.c   **** 		SPI_Transfer((exfBStatAddr >> 16) & 0xff);
 608               		.loc 1 483 0
 609 00a8 80E0      		ldi r24,0
 610 00aa 0E94 0000 		call SPI_Transfer
 611               	.LVL56:
 484:bootSAH_7.c   **** 		SPI_Transfer((exfBStatAddr >> 8) & 0xff);
 612               		.loc 1 484 0
 613 00ae 80E1      		ldi r24,lo8(16)
 614 00b0 0E94 0000 		call SPI_Transfer
 615               	.LVL57:
 485:bootSAH_7.c   **** 		SPI_Transfer(exfBStatAddr & 0xff);
 616               		.loc 1 485 0
 617 00b4 80E0      		ldi r24,0
 618 00b6 0E94 0000 		call SPI_Transfer
 619               	.LVL58:
 486:bootSAH_7.c   **** 		exfBootStat = (uint16_t)SPI_Transfer(0) << 8;
 620               		.loc 1 486 0
 621 00ba 80E0      		ldi r24,0
 622 00bc 0E94 0000 		call SPI_Transfer
 623               	.LVL59:
 624 00c0 082F      		mov r16,r24
 625 00c2 10E0      		ldi r17,0
 626 00c4 102F      		mov r17,r16
 627 00c6 0027      		clr r16
 628               	.LVL60:
 487:bootSAH_7.c   **** 		exfBootStat |= (uint16_t)SPI_Transfer(0);
 629               		.loc 1 487 0
 630 00c8 80E0      		ldi r24,0
 631 00ca 0E94 0000 		call SPI_Transfer
 632               	.LVL61:
 633 00ce 082B      		or r16,r24
 634               	.LVL62:
 488:bootSAH_7.c   **** 		PROG_PORT  |=   (1<<PROG_SPI_CS);
 635               		.loc 1 488 0
 636 00d0 289A      		sbi 0x5,0
 489:bootSAH_7.c   **** 		tiny_delay();
 637               		.loc 1 489 0
 638 00d2 0E94 0000 		call tiny_delay
 639               	.LVL63:
 490:bootSAH_7.c   **** 		
 491:bootSAH_7.c   **** 		/*exfBootStat = FLASH_ReadWord(exfBStatAddr);*/
 492:bootSAH_7.c   **** 
 493:bootSAH_7.c   **** 		if(exfBootStat == 0x2323)
 640               		.loc 1 493 0
 641 00d6 0332      		cpi r16,35
 642 00d8 1342      		sbci r17,35
 643 00da 01F0      		breq .+2
 644 00dc 00C0      		rjmp .L27
 494:bootSAH_7.c   **** 		{			
 495:bootSAH_7.c   **** 			PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 645               		.loc 1 495 0
 646 00de 2898      		cbi 0x5,0
 496:bootSAH_7.c   **** 			SPI_Transfer(0x03);
 647               		.loc 1 496 0
 648 00e0 83E0      		ldi r24,lo8(3)
 649 00e2 0E94 0000 		call SPI_Transfer
 650               	.LVL64:
 497:bootSAH_7.c   **** 			SPI_Transfer((exfDLenAddr >> 16) & 0xff);
 651               		.loc 1 497 0
 652 00e6 80E0      		ldi r24,0
 653 00e8 0E94 0000 		call SPI_Transfer
 654               	.LVL65:
 498:bootSAH_7.c   **** 			SPI_Transfer((exfDLenAddr >> 8) & 0xff);
 655               		.loc 1 498 0
 656 00ec 80E1      		ldi r24,lo8(16)
 657 00ee 0E94 0000 		call SPI_Transfer
 658               	.LVL66:
 499:bootSAH_7.c   **** 			SPI_Transfer(exfDLenAddr & 0xff);
 659               		.loc 1 499 0
 660 00f2 82E0      		ldi r24,lo8(2)
 661 00f4 0E94 0000 		call SPI_Transfer
 662               	.LVL67:
 500:bootSAH_7.c   **** 			exfDataLen = (uint16_t)SPI_Transfer(0) << 8;
 663               		.loc 1 500 0
 664 00f8 80E0      		ldi r24,0
 665 00fa 0E94 0000 		call SPI_Transfer
 666               	.LVL68:
 667 00fe 082F      		mov r16,r24
 668               	.LVL69:
 669 0100 10E0      		ldi r17,0
 670 0102 102F      		mov r17,r16
 671 0104 0027      		clr r16
 672               	.LVL70:
 501:bootSAH_7.c   **** 			exfDataLen |= (uint16_t)SPI_Transfer(0);
 673               		.loc 1 501 0
 674 0106 80E0      		ldi r24,0
 675 0108 0E94 0000 		call SPI_Transfer
 676               	.LVL71:
 677 010c F801      		movw r30,r16
 678 010e E82B      		or r30,r24
 679 0110 C05E      		subi r28,lo8(-288)
 680 0112 DE4F      		sbci r29,hi8(-288)
 681 0114 F983      		std Y+1,r31
 682 0116 E883      		st Y,r30
 683 0118 C052      		subi r28,lo8(288)
 684 011a D140      		sbci r29,hi8(288)
 685               	.LVL72:
 502:bootSAH_7.c   **** 			PROG_PORT  |=   (1<<PROG_SPI_CS);
 686               		.loc 1 502 0
 687 011c 289A      		sbi 0x5,0
 503:bootSAH_7.c   **** 			tiny_delay();
 688               		.loc 1 503 0
 689 011e 0E94 0000 		call tiny_delay
 690               	.LVL73:
 463:bootSAH_7.c   **** 	fPageAddr	 = 0;
 691               		.loc 1 463 0
 692 0122 812C      		mov r8,__zero_reg__
 693 0124 51E1      		ldi r21,lo8(17)
 694 0126 952E      		mov r9,r21
 695 0128 A12C      		mov r10,__zero_reg__
 696 012a B12C      		mov r11,__zero_reg__
 462:bootSAH_7.c   **** 	exfCsumAddr  = BOOT_CSUM_ADDR;
 697               		.loc 1 462 0
 698 012c C12C      		mov r12,__zero_reg__
 699 012e 60E2      		ldi r22,lo8(32)
 700 0130 D62E      		mov r13,r22
 701 0132 E12C      		mov r14,__zero_reg__
 702 0134 F12C      		mov r15,__zero_reg__
 703 0136 9E01      		movw r18,r28
 704 0138 2F5F      		subi r18,-1
 705 013a 3E4F      		sbci r19,-2
 706 013c C25E      		subi r28,lo8(-286)
 707 013e DE4F      		sbci r29,hi8(-286)
 708 0140 3983      		std Y+1,r19
 709 0142 2883      		st Y,r18
 710 0144 CE51      		subi r28,lo8(286)
 711 0146 D140      		sbci r29,hi8(286)
 712               	.LVL74:
 713               	.L42:
 714 0148 2601      		movw r4,r12
 715 014a 3701      		movw r6,r14
 716 014c 30E2      		ldi r19,32
 717 014e 531A      		sub r5,r19
 718 0150 6108      		sbc r6,__zero_reg__
 719 0152 7108      		sbc r7,__zero_reg__
 720               	.LVL75:
 504:bootSAH_7.c   **** 			
 505:bootSAH_7.c   **** 			/*exfDataLen = FLASH_ReadWord(exfDLenAddr);*/
 506:bootSAH_7.c   **** 
 507:bootSAH_7.c   **** 			do 
 508:bootSAH_7.c   **** 			{				
 509:bootSAH_7.c   **** 				fMemSize = EXMEM_PAGE_SIZE;
 510:bootSAH_7.c   **** 				fIndex = 0;
 511:bootSAH_7.c   **** 				//fRdTries  = 0;
 512:bootSAH_7.c   **** 				exfChSumCal = 0;
 513:bootSAH_7.c   **** 				PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 721               		.loc 1 513 0
 722 0154 2898      		cbi 0x5,0
 514:bootSAH_7.c   **** 				SPI_Transfer(0x03);
 723               		.loc 1 514 0
 724 0156 83E0      		ldi r24,lo8(3)
 725 0158 0E94 0000 		call SPI_Transfer
 726               	.LVL76:
 515:bootSAH_7.c   **** 				SPI_Transfer((exfDataAddr >> 16) & 0xff);
 727               		.loc 1 515 0
 728 015c 8E2D      		mov r24,r14
 729 015e 0E94 0000 		call SPI_Transfer
 730               	.LVL77:
 516:bootSAH_7.c   **** 				SPI_Transfer((exfDataAddr >> 8) & 0xff);
 731               		.loc 1 516 0
 732 0162 8D2D      		mov r24,r13
 733 0164 0E94 0000 		call SPI_Transfer
 734               	.LVL78:
 517:bootSAH_7.c   **** 				SPI_Transfer(exfDataAddr & 0xff);			
 735               		.loc 1 517 0
 736 0168 80E0      		ldi r24,0
 737 016a 0E94 0000 		call SPI_Transfer
 738               	.LVL79:
 739 016e CE01      		movw r24,r28
 740 0170 0196      		adiw r24,1
 741 0172 1C01      		movw r2,r24
 742 0174 8C01      		movw r16,r24
 512:bootSAH_7.c   **** 				PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 743               		.loc 1 512 0
 744 0176 CE5D      		subi r28,lo8(-290)
 745 0178 DE4F      		sbci r29,hi8(-290)
 746 017a 1982      		std Y+1,__zero_reg__
 747 017c 1882      		st Y,__zero_reg__
 748 017e C252      		subi r28,lo8(290)
 749 0180 D140      		sbci r29,hi8(290)
 750               	.LVL80:
 751               	.L29:
 518:bootSAH_7.c   **** 				do 
 519:bootSAH_7.c   **** 				{
 520:bootSAH_7.c   **** 					RdData = SPI_Transfer(0);
 752               		.loc 1 520 0 discriminator 1
 753 0182 80E0      		ldi r24,0
 754 0184 0E94 0000 		call SPI_Transfer
 755               	.LVL81:
 521:bootSAH_7.c   **** 					fMsgBuff[fIndex++] = RdData;
 756               		.loc 1 521 0 discriminator 1
 757 0188 F801      		movw r30,r16
 758 018a 8193      		st Z+,r24
 759 018c 8F01      		movw r16,r30
 522:bootSAH_7.c   **** 					exfChSumCal += RdData;				
 760               		.loc 1 522 0 discriminator 1
 761 018e CE5D      		subi r28,lo8(-290)
 762 0190 DE4F      		sbci r29,hi8(-290)
 763 0192 2881      		ld r18,Y
 764 0194 3981      		ldd r19,Y+1
 765 0196 C252      		subi r28,lo8(290)
 766 0198 D140      		sbci r29,hi8(290)
 767 019a 280F      		add r18,r24
 768 019c 311D      		adc r19,__zero_reg__
 769 019e CE5D      		subi r28,lo8(-290)
 770 01a0 DE4F      		sbci r29,hi8(-290)
 771 01a2 3983      		std Y+1,r19
 772 01a4 2883      		st Y,r18
 773 01a6 C252      		subi r28,lo8(290)
 774 01a8 D140      		sbci r29,hi8(290)
 775               	.LVL82:
 523:bootSAH_7.c   **** 					fMemSize--;
 524:bootSAH_7.c   **** 				} while (fMemSize);		
 776               		.loc 1 524 0 discriminator 1
 777 01aa C25E      		subi r28,lo8(-286)
 778 01ac DE4F      		sbci r29,hi8(-286)
 779 01ae 8881      		ld r24,Y
 780 01b0 9981      		ldd r25,Y+1
 781 01b2 CE51      		subi r28,lo8(286)
 782 01b4 D140      		sbci r29,hi8(286)
 783               	.LVL83:
 784 01b6 E817      		cp r30,r24
 785 01b8 F907      		cpc r31,r25
 786 01ba 01F4      		brne .L29
 525:bootSAH_7.c   **** 				PROG_PORT  |=   (1<<PROG_SPI_CS);
 787               		.loc 1 525 0
 788 01bc 289A      		sbi 0x5,0
 526:bootSAH_7.c   **** 				tiny_delay();
 789               		.loc 1 526 0
 790 01be 0E94 0000 		call tiny_delay
 791               	.LVL84:
 527:bootSAH_7.c   **** 
 528:bootSAH_7.c   **** 		
 529:bootSAH_7.c   **** 				PROG_PORT  &=  ~(1<<PROG_SPI_CS);
 792               		.loc 1 529 0
 793 01c2 2898      		cbi 0x5,0
 530:bootSAH_7.c   **** 				SPI_Transfer(0x03);
 794               		.loc 1 530 0
 795 01c4 83E0      		ldi r24,lo8(3)
 796 01c6 0E94 0000 		call SPI_Transfer
 797               	.LVL85:
 531:bootSAH_7.c   **** 				SPI_Transfer((exfCsumAddr >> 16) & 0xff);
 798               		.loc 1 531 0
 799 01ca 80E0      		ldi r24,0
 800 01cc 0E94 0000 		call SPI_Transfer
 801               	.LVL86:
 532:bootSAH_7.c   **** 				SPI_Transfer((exfCsumAddr >> 8) & 0xff);
 802               		.loc 1 532 0
 803 01d0 892D      		mov r24,r9
 804 01d2 0E94 0000 		call SPI_Transfer
 805               	.LVL87:
 533:bootSAH_7.c   **** 				SPI_Transfer(exfCsumAddr & 0xff);				
 806               		.loc 1 533 0
 807 01d6 882D      		mov r24,r8
 808 01d8 0E94 0000 		call SPI_Transfer
 809               	.LVL88:
 534:bootSAH_7.c   **** 				exfChSumRev = (uint16_t)SPI_Transfer(0) << 8;
 810               		.loc 1 534 0
 811 01dc 80E0      		ldi r24,0
 812 01de 0E94 0000 		call SPI_Transfer
 813               	.LVL89:
 814 01e2 082F      		mov r16,r24
 815 01e4 10E0      		ldi r17,0
 816 01e6 102F      		mov r17,r16
 817 01e8 0027      		clr r16
 818               	.LVL90:
 535:bootSAH_7.c   **** 				exfChSumRev |= (uint16_t)SPI_Transfer(0);			
 819               		.loc 1 535 0
 820 01ea 80E0      		ldi r24,0
 821 01ec 0E94 0000 		call SPI_Transfer
 822               	.LVL91:
 823 01f0 082B      		or r16,r24
 824               	.LVL92:
 536:bootSAH_7.c   **** 				PROG_PORT  |=   (1<<PROG_SPI_CS);
 825               		.loc 1 536 0
 826 01f2 289A      		sbi 0x5,0
 537:bootSAH_7.c   **** 				tiny_delay();
 827               		.loc 1 537 0
 828 01f4 0E94 0000 		call tiny_delay
 829               	.LVL93:
 538:bootSAH_7.c   **** 				
 539:bootSAH_7.c   **** 		
 540:bootSAH_7.c   **** 				if(exfChSumRev != exfChSumCal)
 830               		.loc 1 540 0
 831 01f8 CE5D      		subi r28,lo8(-290)
 832 01fa DE4F      		sbci r29,hi8(-290)
 833 01fc E881      		ld r30,Y
 834 01fe F981      		ldd r31,Y+1
 835 0200 C252      		subi r28,lo8(290)
 836 0202 D140      		sbci r29,hi8(290)
 837 0204 E017      		cp r30,r16
 838 0206 F107      		cpc r31,r17
 839 0208 01F0      		breq .+2
 840 020a 00C0      		rjmp .L30
 841               	.LVL94:
 541:bootSAH_7.c   **** 				{
 542:bootSAH_7.c   **** 
 543:bootSAH_7.c   **** 					break;
 544:bootSAH_7.c   **** 				}
 545:bootSAH_7.c   **** 				
 546:bootSAH_7.c   ****  				fTmpPgAddr  = fPageAddr;
 547:bootSAH_7.c   ****  				fMemSize = SPM_PAGESIZE;
 548:bootSAH_7.c   ****  				fIndex  = 0;
 549:bootSAH_7.c   **** 				 
 550:bootSAH_7.c   **** 				if (fPageAddr >= APP_END )
 842               		.loc 1 550 0
 843 020c C114      		cp r12,__zero_reg__
 844 020e F0EE      		ldi r31,-32
 845 0210 DF06      		cpc r13,r31
 846 0212 F3E0      		ldi r31,3
 847 0214 EF06      		cpc r14,r31
 848 0216 F104      		cpc r15,__zero_reg__
 849 0218 01F4      		brne .+2
 850 021a 00C0      		rjmp .L30
 851               	.L51:
 551:bootSAH_7.c   **** 				{
 552:bootSAH_7.c   **** 					break;
 553:bootSAH_7.c   **** 				}
 554:bootSAH_7.c   **** 					
 555:bootSAH_7.c   **** 				boot_page_erase_safe(fPageAddr);
 852               		.loc 1 555 0 discriminator 1
 853 021c 07B6      		in __tmp_reg__,0x37
 854 021e 00FC      		sbrc __tmp_reg__,0
 855 0220 00C0      		rjmp .L51
 856               	.L32:
 857               		.loc 1 555 0 is_stmt 0 discriminator 3
 858 0222 F999      		sbic 0x1f,1
 859 0224 00C0      		rjmp .L32
 860               		.loc 1 555 0 discriminator 4
 861 0226 83E0      		ldi r24,lo8(3)
 862               	/* #APP */
 863               	 ;  555 "bootSAH_7.c" 1
 864 0228 F201      		movw r30, r4
 865 022a 6092 5B00 		sts  91, r6
 866 022e 8093 5700 		sts 87, r24
 867 0232 E895      		spm
 868               		
 869               	 ;  0 "" 2
 870               	/* #NOAPP */
 871               	.L33:
 556:bootSAH_7.c   **** 				boot_spm_busy_wait();			
 872               		.loc 1 556 0 is_stmt 1 discriminator 1
 873 0234 07B6      		in __tmp_reg__,0x37
 874 0236 00FC      		sbrc __tmp_reg__,0
 875 0238 00C0      		rjmp .L33
 876 023a B301      		movw r22,r6
 877 023c A201      		movw r20,r4
 878               	.LVL95:
 879               	.L36:
 557:bootSAH_7.c   **** 					
 558:bootSAH_7.c   **** 				do 
 559:bootSAH_7.c   **** 				{
 560:bootSAH_7.c   **** 					fLSByte = fMsgBuff[fIndex];
 561:bootSAH_7.c   **** 					fIndex++;
 562:bootSAH_7.c   **** 					fMSByte = fMsgBuff[fIndex];
 563:bootSAH_7.c   **** 					fIndex++;
 564:bootSAH_7.c   **** 
 565:bootSAH_7.c   **** 					fDataWord = (fMSByte << 8) | fLSByte;
 880               		.loc 1 565 0
 881 023e F101      		movw r30,r2
 882 0240 8181      		ldd r24,Z+1
 883 0242 90E0      		ldi r25,0
 884 0244 982F      		mov r25,r24
 885 0246 8827      		clr r24
 886 0248 2081      		ld r18,Z
 887 024a 822B      		or r24,r18
 888               	.LVL96:
 889               	.L34:
 566:bootSAH_7.c   **** 						
 567:bootSAH_7.c   **** 					boot_page_fill_safe(fTmpPgAddr,fDataWord);
 890               		.loc 1 567 0 discriminator 1
 891 024c 07B6      		in __tmp_reg__,0x37
 892 024e 00FC      		sbrc __tmp_reg__,0
 893 0250 00C0      		rjmp .L34
 894               	.L35:
 895               		.loc 1 567 0 is_stmt 0 discriminator 3
 896 0252 F999      		sbic 0x1f,1
 897 0254 00C0      		rjmp .L35
 898               		.loc 1 567 0 discriminator 4
 899 0256 21E0      		ldi r18,lo8(1)
 900               	/* #APP */
 901               	 ;  567 "bootSAH_7.c" 1
 902 0258 0C01      		movw  r0, r24
 903 025a FA01      		movw r30, r20
 904 025c 6093 5B00 		sts 91, r22
 905 0260 2093 5700 		sts 87, r18
 906 0264 E895      		spm
 907 0266 1124      		clr  r1
 908               		
 909               	 ;  0 "" 2
 568:bootSAH_7.c   **** 										
 569:bootSAH_7.c   **** 					fTmpPgAddr  = fTmpPgAddr + 2;
 910               		.loc 1 569 0 is_stmt 1 discriminator 4
 911               	/* #NOAPP */
 912 0268 4E5F      		subi r20,-2
 913 026a 5F4F      		sbci r21,-1
 914 026c 6F4F      		sbci r22,-1
 915 026e 7F4F      		sbci r23,-1
 916               	.LVL97:
 570:bootSAH_7.c   **** 					asm volatile ("nop");	
 917               		.loc 1 570 0 discriminator 4
 918               	/* #APP */
 919               	 ;  570 "bootSAH_7.c" 1
 920 0270 0000      		nop
 921               	 ;  0 "" 2
 922               	/* #NOAPP */
 923 0272 32E0      		ldi r19,2
 924 0274 230E      		add r2,r19
 925 0276 311C      		adc r3,__zero_reg__
 926               	.LVL98:
 571:bootSAH_7.c   **** 					fMemSize = fMemSize - 2;
 572:bootSAH_7.c   **** 				} while (fMemSize);
 927               		.loc 1 572 0 discriminator 4
 928 0278 C25E      		subi r28,lo8(-286)
 929 027a DE4F      		sbci r29,hi8(-286)
 930 027c 8881      		ld r24,Y
 931 027e 9981      		ldd r25,Y+1
 932 0280 CE51      		subi r28,lo8(286)
 933 0282 D140      		sbci r29,hi8(286)
 934               	.LVL99:
 935 0284 8215      		cp r24,r2
 936 0286 9305      		cpc r25,r3
 937 0288 01F4      		brne .L36
 938               	.L50:
 573:bootSAH_7.c   **** 					
 574:bootSAH_7.c   **** 				boot_page_write_safe(fPageAddr);
 939               		.loc 1 574 0 discriminator 1
 940 028a 07B6      		in __tmp_reg__,0x37
 941 028c 00FC      		sbrc __tmp_reg__,0
 942 028e 00C0      		rjmp .L50
 943               	.L38:
 944               		.loc 1 574 0 is_stmt 0 discriminator 3
 945 0290 F999      		sbic 0x1f,1
 946 0292 00C0      		rjmp .L38
 947               		.loc 1 574 0 discriminator 4
 948 0294 95E0      		ldi r25,lo8(5)
 949               	/* #APP */
 950               	 ;  574 "bootSAH_7.c" 1
 951 0296 F201      		movw r30, r4
 952 0298 6092 5B00 		sts 91, r6
 953 029c 9093 5700 		sts 87, r25
 954 02a0 E895      		spm
 955               		
 956               	 ;  0 "" 2
 957               	/* #NOAPP */
 958               	.L39:
 575:bootSAH_7.c   **** 				boot_spm_busy_wait();
 959               		.loc 1 575 0 is_stmt 1 discriminator 1
 960 02a2 07B6      		in __tmp_reg__,0x37
 961 02a4 00FC      		sbrc __tmp_reg__,0
 962 02a6 00C0      		rjmp .L39
 963               	.L40:
 576:bootSAH_7.c   **** 				boot_rww_enable_safe();
 964               		.loc 1 576 0 discriminator 1
 965 02a8 07B6      		in __tmp_reg__,0x37
 966 02aa 00FC      		sbrc __tmp_reg__,0
 967 02ac 00C0      		rjmp .L40
 968               	.L41:
 969               		.loc 1 576 0 is_stmt 0 discriminator 3
 970 02ae F999      		sbic 0x1f,1
 971 02b0 00C0      		rjmp .L41
 972               		.loc 1 576 0 discriminator 4
 973 02b2 E1E1      		ldi r30,lo8(17)
 974               	/* #APP */
 975               	 ;  576 "bootSAH_7.c" 1
 976 02b4 E093 5700 		sts 87, r30
 977 02b8 E895      		spm
 978               		
 979               	 ;  0 "" 2
 980               	.LVL100:
 577:bootSAH_7.c   **** 					
 578:bootSAH_7.c   **** 				fPageAddr += SPM_PAGESIZE;
 579:bootSAH_7.c   **** 				exfDataAddr += EXMEM_PAGE_SIZE;
 981               		.loc 1 579 0 is_stmt 1 discriminator 4
 982               	/* #NOAPP */
 983 02ba FFEF      		ldi r31,-1
 984 02bc DF1A      		sub r13,r31
 985 02be EF0A      		sbc r14,r31
 986 02c0 FF0A      		sbc r15,r31
 987               	.LVL101:
 580:bootSAH_7.c   **** 				exfCsumAddr += 2;
 988               		.loc 1 580 0 discriminator 4
 989 02c2 22E0      		ldi r18,2
 990 02c4 820E      		add r8,r18
 991 02c6 911C      		adc r9,__zero_reg__
 992 02c8 A11C      		adc r10,__zero_reg__
 993 02ca B11C      		adc r11,__zero_reg__
 994               	.LVL102:
 581:bootSAH_7.c   **** 				asm volatile ("nop");
 995               		.loc 1 581 0 discriminator 4
 996               	/* #APP */
 997               	 ;  581 "bootSAH_7.c" 1
 998 02cc 0000      		nop
 999               	 ;  0 "" 2
 582:bootSAH_7.c   **** 				
 583:bootSAH_7.c   **** 				exfDataLen--;
 1000               		.loc 1 583 0 discriminator 4
 1001               	/* #NOAPP */
 1002 02ce C05E      		subi r28,lo8(-288)
 1003 02d0 DE4F      		sbci r29,hi8(-288)
 1004 02d2 8881      		ld r24,Y
 1005 02d4 9981      		ldd r25,Y+1
 1006 02d6 C052      		subi r28,lo8(288)
 1007 02d8 D140      		sbci r29,hi8(288)
 1008 02da 0197      		sbiw r24,1
 1009 02dc C05E      		subi r28,lo8(-288)
 1010 02de DE4F      		sbci r29,hi8(-288)
 1011 02e0 9983      		std Y+1,r25
 1012 02e2 8883      		st Y,r24
 1013 02e4 C052      		subi r28,lo8(288)
 1014 02e6 D140      		sbci r29,hi8(288)
 1015               	.LVL103:
 584:bootSAH_7.c   **** 			} while (exfDataLen);
 1016               		.loc 1 584 0 discriminator 4
 1017 02e8 892B      		or r24,r25
 1018 02ea 01F0      		breq .+2
 1019 02ec 00C0      		rjmp .L42
 1020               	.LVL104:
 1021               	.L30:
 585:bootSAH_7.c   **** 			
 586:bootSAH_7.c   **** 			tiny_delay();
 1022               		.loc 1 586 0
 1023 02ee 0E94 0000 		call tiny_delay
 1024               	.LVL105:
 587:bootSAH_7.c   **** 			FLASH_EraseSector(exfBStatAddr);	
 1025               		.loc 1 587 0
 1026 02f2 60E0      		ldi r22,0
 1027 02f4 70E1      		ldi r23,lo8(16)
 1028 02f6 80E0      		ldi r24,0
 1029 02f8 90E0      		ldi r25,0
 1030 02fa 0E94 0000 		call FLASH_EraseSector
 1031               	.LVL106:
 588:bootSAH_7.c   **** 			asm volatile ("nop");
 1032               		.loc 1 588 0
 1033               	/* #APP */
 1034               	 ;  588 "bootSAH_7.c" 1
 1035 02fe 0000      		nop
 1036               	 ;  0 "" 2
 589:bootSAH_7.c   **** 			FLASH_WriteByte(512, 0x4F);
 1037               		.loc 1 589 0
 1038               	/* #NOAPP */
 1039 0300 4FE4      		ldi r20,lo8(79)
 1040 0302 60E0      		ldi r22,0
 1041 0304 72E0      		ldi r23,lo8(2)
 1042 0306 80E0      		ldi r24,0
 1043 0308 90E0      		ldi r25,0
 1044 030a 0E94 0000 		call FLASH_WriteByte
 1045               	.LVL107:
 590:bootSAH_7.c   **** 			FLASH_WriteByte(513, 0x4B);					
 1046               		.loc 1 590 0
 1047 030e 4BE4      		ldi r20,lo8(75)
 1048 0310 61E0      		ldi r22,lo8(1)
 1049 0312 72E0      		ldi r23,lo8(2)
 1050 0314 80E0      		ldi r24,0
 1051 0316 90E0      		ldi r25,0
 1052 0318 0E94 0000 		call FLASH_WriteByte
 1053               	.LVL108:
 1054               	.L27:
 591:bootSAH_7.c   **** 		}
 592:bootSAH_7.c   **** 	}
 593:bootSAH_7.c   **** 	
 594:bootSAH_7.c   **** //**************************************************************************	
 595:bootSAH_7.c   **** 	
 596:bootSAH_7.c   **** 	boot_timer	 =	0;
 597:bootSAH_7.c   **** 	boot_state	 =	0;
 598:bootSAH_7.c   **** 	boot_timeout =	3500000;
 599:bootSAH_7.c   **** 	
 600:bootSAH_7.c   **** /*
 601:bootSAH_7.c   **** * Initialize UART
 602:bootSAH_7.c   **** * set baudrate and enable USART receiver and transmitter without interrupts
 603:bootSAH_7.c   **** */
 604:bootSAH_7.c   **** #if UART_BAUDRATE_DOUBLE_SPEED
 605:bootSAH_7.c   **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 1055               		.loc 1 605 0
 1056 031c 8091 C000 		lds r24,192
 1057 0320 8260      		ori r24,lo8(2)
 1058 0322 8093 C000 		sts 192,r24
 606:bootSAH_7.c   **** #endif
 607:bootSAH_7.c   **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 1059               		.loc 1 607 0
 1060 0326 80E1      		ldi r24,lo8(16)
 1061 0328 8093 C400 		sts 196,r24
 608:bootSAH_7.c   **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 1062               		.loc 1 608 0
 1063 032c 88E1      		ldi r24,lo8(24)
 1064 032e 8093 C100 		sts 193,r24
 609:bootSAH_7.c   **** 
 610:bootSAH_7.c   **** 	asm volatile ("nop");			// wait until port has changed
 1065               		.loc 1 610 0
 1066               	/* #APP */
 1067               	 ;  610 "bootSAH_7.c" 1
 1068 0332 0000      		nop
 1069               	 ;  0 "" 2
 611:bootSAH_7.c   **** 	
 612:bootSAH_7.c   **** 
 613:bootSAH_7.c   **** 	sendchar('u');
 1070               		.loc 1 613 0
 1071               	/* #NOAPP */
 1072 0334 85E7      		ldi r24,lo8(117)
 1073 0336 0E94 0000 		call sendchar
 1074               	.LVL109:
 614:bootSAH_7.c   **** 	sendchar('t');
 1075               		.loc 1 614 0
 1076 033a 84E7      		ldi r24,lo8(116)
 1077 033c 0E94 0000 		call sendchar
 1078               	.LVL110:
 615:bootSAH_7.c   **** 	sendchar('e');
 1079               		.loc 1 615 0
 1080 0340 85E6      		ldi r24,lo8(101)
 1081 0342 0E94 0000 		call sendchar
 1082               	.LVL111:
 616:bootSAH_7.c   **** 	sendchar('c');
 1083               		.loc 1 616 0
 1084 0346 83E6      		ldi r24,lo8(99)
 1085 0348 0E94 0000 		call sendchar
 1086               	.LVL112:
 617:bootSAH_7.c   **** 	sendchar('h');
 1087               		.loc 1 617 0
 1088 034c 88E6      		ldi r24,lo8(104)
 1089 034e 0E94 0000 		call sendchar
 1090               	.LVL113:
 618:bootSAH_7.c   **** 	sendchar('_');
 1091               		.loc 1 618 0
 1092 0352 8FE5      		ldi r24,lo8(95)
 1093 0354 0E94 0000 		call sendchar
 1094               	.LVL114:
 619:bootSAH_7.c   **** 	sendchar('B');
 1095               		.loc 1 619 0
 1096 0358 82E4      		ldi r24,lo8(66)
 1097 035a 0E94 0000 		call sendchar
 1098               	.LVL115:
 620:bootSAH_7.c   **** 	sendchar('B');
 1099               		.loc 1 620 0
 1100 035e 82E4      		ldi r24,lo8(66)
 1101 0360 0E94 0000 		call sendchar
 1102               	.LVL116:
 621:bootSAH_7.c   **** 
 622:bootSAH_7.c   **** 	sendchar(0x0d);
 1103               		.loc 1 622 0
 1104 0364 8DE0      		ldi r24,lo8(13)
 1105 0366 0E94 0000 		call sendchar
 1106               	.LVL117:
 623:bootSAH_7.c   **** 	sendchar(0x0a);
 1107               		.loc 1 623 0
 1108 036a 8AE0      		ldi r24,lo8(10)
 1109 036c 0E94 0000 		call sendchar
 1110               	.LVL118:
 624:bootSAH_7.c   **** 	
 625:bootSAH_7.c   **** 	
 626:bootSAH_7.c   **** 	
 627:bootSAH_7.c   **** //*************************************************************************
 628:bootSAH_7.c   **** 	tiny_delay();
 1111               		.loc 1 628 0
 1112 0370 0E94 0000 		call tiny_delay
 1113               	.LVL119:
 629:bootSAH_7.c   **** 	UART_STATUS_REG	&=	0xfd;
 1114               		.loc 1 629 0
 1115 0374 8091 C000 		lds r24,192
 1116 0378 8D7F      		andi r24,lo8(-3)
 1117 037a 8093 C000 		sts 192,r24
 1118               	.L43:
 630:bootSAH_7.c   **** 	boot_rww_enable_safe();				// enable application section
 1119               		.loc 1 630 0 discriminator 1
 1120 037e 07B6      		in __tmp_reg__,0x37
 1121 0380 00FC      		sbrc __tmp_reg__,0
 1122 0382 00C0      		rjmp .L43
 1123               	.L44:
 1124               		.loc 1 630 0 is_stmt 0 discriminator 3
 1125 0384 F999      		sbic 0x1f,1
 1126 0386 00C0      		rjmp .L44
 1127               		.loc 1 630 0 discriminator 4
 1128 0388 81E1      		ldi r24,lo8(17)
 1129               	/* #APP */
 1130               	 ;  630 "bootSAH_7.c" 1
 1131 038a 8093 5700 		sts 87, r24
 1132 038e E895      		spm
 1133               		
 1134               	 ;  0 "" 2
 631:bootSAH_7.c   **** 	// leaving bootloader  # bye_bye # sayonara # suba_gaman #
 632:bootSAH_7.c   **** 	asm volatile(
 1135               		.loc 1 632 0 is_stmt 1 discriminator 4
 1136               	 ;  632 "bootSAH_7.c" 1
 1137 0390 EE27      		clr	r30		
 1138 0392 FF27      		clr	r31		
 1139 0394 0994      		ijmp			
 1140               		
 1141               	 ;  0 "" 2
 1142               	/* #NOAPP */
 1143               	.L45:
 633:bootSAH_7.c   **** 					"clr	r30		\n\t"
 634:bootSAH_7.c   **** 					"clr	r31		\n\t"
 635:bootSAH_7.c   **** 					"ijmp			\n\t"
 636:bootSAH_7.c   **** 				);
 637:bootSAH_7.c   **** 	
 638:bootSAH_7.c   ****     for(;;)
 639:bootSAH_7.c   ****     {		
 640:bootSAH_7.c   **** 		tiny_delay();
 1144               		.loc 1 640 0 discriminator 1
 1145 0396 0E94 0000 		call tiny_delay
 1146               	.LVL120:
 1147 039a 00C0      		rjmp .L45
 1148               		.cfi_endproc
 1149               	.LFE25:
 1151               	.global	app_start
 1152               		.section .bss
 1155               	app_start:
 1156 0000 0000      		.zero	2
 1157               		.text
 1158               	.Letext0:
 1159               		.file 3 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\st
DEFINED SYMBOLS
                            *ABS*:00000000 bootSAH_7.c
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:2      *ABS*:0000003e __SP_H__
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:3      *ABS*:0000003d __SP_L__
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:4      *ABS*:0000003f __SREG__
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:7      *ABS*:00000001 __zero_reg__
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:12     .text:00000000 SPI_Transfer
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:44     .text:0000000e sendchar
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:72     .text:00000026 delay_ms
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:118    .text:00000044 tiny_delay
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:143    .text:00000050 FLASH_UntilReady
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:182    .text:0000006c FLASH_ResetEnable
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:206    .text:0000007a FLASH_Reset
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:230    .text:00000088 FLASH_WriteEnable
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:254    .text:00000096 FLASH_EraseSector
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:319    .text:000000d2 FLASH_WriteByte
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:397    .init9:00000000 __jumpMain
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:408    *ABS*:000021ff __stack
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:447    .text.startup:00000000 main
C:\Users\supun\AppData\Local\Temp\ccRjvsjN.s:1155   .bss:00000000 app_start

UNDEFINED SYMBOLS
__do_clear_bss
