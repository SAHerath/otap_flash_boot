   1               		.file	"bootSAH_8.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "bootSAH_8.c"
   1:bootSAH_8.c   **** /*****************************************************************************
   2:bootSAH_8.c   **** Title:     STK500v2 compatible bootloader
   3:bootSAH_8.c   ****            Modified for Wiring board ATMega128-16MHz
   4:bootSAH_8.c   **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:bootSAH_8.c   **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:bootSAH_8.c   **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:bootSAH_8.c   **** License:   GNU General Public License
   8:bootSAH_8.c   **** 
   9:bootSAH_8.c   **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:bootSAH_8.c   **** Date:      17 October 2007
  11:bootSAH_8.c   **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:bootSAH_8.c   **** Compiler:  WINAVR20060421
  13:bootSAH_8.c   **** Description: add timeout feature like previous Wiring bootloader
  14:bootSAH_8.c   **** 
  15:bootSAH_8.c   **** Modified:  Supun Herath <supun@utequip.com> 
  16:bootSAH_8.c   **** Date:      20 Aug 2019
  17:bootSAH_8.c   **** Update:
  18:bootSAH_8.c   **** Compiler:  avr-gcc (AVR_8_bit_GNU_Toolchain_3.6.1_1750) 5.4.0
  19:bootSAH_8.c   **** Description: add capability to write internal flash through external flash chip using spi protocol
  20:bootSAH_8.c   **** 
  21:bootSAH_8.c   **** DESCRIPTION:
  22:bootSAH_8.c   ****     This program allows an AVR with bootloader capabilities to
  23:bootSAH_8.c   ****     read/write its own Flash/EEprom. To enter Programming mode
  24:bootSAH_8.c   ****     an input pin is checked. If this pin is pulled low, programming mode
  25:bootSAH_8.c   ****     is entered. If not, normal execution is done from $0000
  26:bootSAH_8.c   ****     "reset" vector in Application area.
  27:bootSAH_8.c   ****     Size fits into a 1024 word bootloader section
  28:bootSAH_8.c   **** 	when compiled with avr-gcc 4.1
  29:bootSAH_8.c   **** 	(direct replace on Wiring Board without fuse setting changed)
  30:bootSAH_8.c   **** 
  31:bootSAH_8.c   **** USAGE:
  32:bootSAH_8.c   ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  33:bootSAH_8.c   ****     - Set baud rate below (AVRISP only works with 115200 bps)
  34:bootSAH_8.c   ****     - compile/link the bootloader with the supplied Makefile
  35:bootSAH_8.c   ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  36:bootSAH_8.c   ****       for boot-size 1024 words:  program BOOTSZ01
  37:bootSAH_8.c   ****     - enable the BOOT Reset Vector (program BOOTRST)
  38:bootSAH_8.c   ****     - Upload the hex file to the AVR using any ISP programmer
  39:bootSAH_8.c   ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  40:bootSAH_8.c   ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  41:bootSAH_8.c   ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  42:bootSAH_8.c   ****     - AVRISP will detect the bootloader
  43:bootSAH_8.c   ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  44:bootSAH_8.c   **** 
  45:bootSAH_8.c   **** Note:
  46:bootSAH_8.c   ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  47:bootSAH_8.c   ****     is not implemented, due to AVRStudio limitations.
  48:bootSAH_8.c   ****     Flash is always erased before programming.
  49:bootSAH_8.c   **** 
  50:bootSAH_8.c   **** 	AVRdude:
  51:bootSAH_8.c   **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  52:bootSAH_8.c   **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  53:bootSAH_8.c   **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  54:bootSAH_8.c   **** 
  55:bootSAH_8.c   **** NOTES:
  56:bootSAH_8.c   ****     Based on Atmel Application Note AVR109 - Self-programming
  57:bootSAH_8.c   ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  58:bootSAH_8.c   **** 
  59:bootSAH_8.c   **** LICENSE:
  60:bootSAH_8.c   ****     Copyright (C) 2006 Peter Fleury
  61:bootSAH_8.c   **** 
  62:bootSAH_8.c   ****     This program is free software; you can redistribute it and/or modify
  63:bootSAH_8.c   ****     it under the terms of the GNU General Public License as published by
  64:bootSAH_8.c   ****     the Free Software Foundation; either version 2 of the License, or
  65:bootSAH_8.c   ****     any later version.
  66:bootSAH_8.c   **** 
  67:bootSAH_8.c   ****     This program is distributed in the hope that it will be useful,
  68:bootSAH_8.c   ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  69:bootSAH_8.c   ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  70:bootSAH_8.c   ****     GNU General Public License for more details.
  71:bootSAH_8.c   **** 
  72:bootSAH_8.c   **** *****************************************************************************/
  73:bootSAH_8.c   **** 
  74:bootSAH_8.c   **** //************************************************************************
  75:bootSAH_8.c   **** //*	Edit History
  76:bootSAH_8.c   **** //************************************************************************
  77:bootSAH_8.c   **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  78:bootSAH_8.c   **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  79:bootSAH_8.c   **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  80:bootSAH_8.c   **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  81:bootSAH_8.c   **** //*	Jul  8,	2010	<MLS> Adding monitor code
  82:bootSAH_8.c   **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  83:bootSAH_8.c   **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  84:bootSAH_8.c   **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  85:bootSAH_8.c   **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  86:bootSAH_8.c   **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  87:bootSAH_8.c   **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  88:bootSAH_8.c   **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  89:bootSAH_8.c   **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  90:bootSAH_8.c   **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  91:bootSAH_8.c   **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  92:bootSAH_8.c   **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  93:bootSAH_8.c   **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  94:bootSAH_8.c   **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  95:bootSAH_8.c   **** //************************************************************************
  96:bootSAH_8.c   **** 
  97:bootSAH_8.c   **** //************************************************************************
  98:bootSAH_8.c   **** //*	these are used to test issues
  99:bootSAH_8.c   **** //*	http://code.google.com/p/arduino/issues/detail?id=505
 100:bootSAH_8.c   **** //*	Reported by mark.stubbs, Mar 14, 2011
 101:bootSAH_8.c   **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
 102:bootSAH_8.c   **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
 103:bootSAH_8.c   **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
 104:bootSAH_8.c   **** 
 105:bootSAH_8.c   **** 
 106:bootSAH_8.c   **** 
 107:bootSAH_8.c   **** //#define	_FIX_ISSUE_505_
 108:bootSAH_8.c   **** //************************************************************************
 109:bootSAH_8.c   **** 
 110:bootSAH_8.c   **** #include	<inttypes.h>
 111:bootSAH_8.c   **** #include	<avr/io.h>
 112:bootSAH_8.c   **** #include	<avr/interrupt.h>
 113:bootSAH_8.c   **** #include	<avr/boot.h>
 114:bootSAH_8.c   **** #include	<avr/pgmspace.h>
 115:bootSAH_8.c   **** #include	<util/delay.h>
 116:bootSAH_8.c   **** #include	<avr/eeprom.h>
 117:bootSAH_8.c   **** #include	<avr/common.h>
 118:bootSAH_8.c   **** #include	<stdlib.h>
 119:bootSAH_8.c   **** #include	"command.h"
 120:bootSAH_8.c   **** 
 121:bootSAH_8.c   **** 
 122:bootSAH_8.c   **** #ifndef EEWE
 123:bootSAH_8.c   **** 	#define EEWE    1
 124:bootSAH_8.c   **** #endif
 125:bootSAH_8.c   **** #ifndef EEMWE
 126:bootSAH_8.c   **** 	#define EEMWE   2
 127:bootSAH_8.c   **** #endif
 128:bootSAH_8.c   **** 
 129:bootSAH_8.c   **** #define	_DEBUG_SERIAL_
 130:bootSAH_8.c   **** //#define	_DEBUG_WITH_LEDS_
 131:bootSAH_8.c   **** 
 132:bootSAH_8.c   **** 
 133:bootSAH_8.c   **** /*
 134:bootSAH_8.c   ****  * Uncomment the following lines to save code space
 135:bootSAH_8.c   ****  */
 136:bootSAH_8.c   **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 137:bootSAH_8.c   **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 138:bootSAH_8.c   **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 139:bootSAH_8.c   **** //
 140:bootSAH_8.c   **** 
 141:bootSAH_8.c   **** 
 142:bootSAH_8.c   **** 
 143:bootSAH_8.c   **** //************************************************************************
 144:bootSAH_8.c   **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 145:bootSAH_8.c   **** //*	indicates that bootloader is active
 146:bootSAH_8.c   **** //*	PG2 -> LED on Wiring board
 147:bootSAH_8.c   **** //************************************************************************
 148:bootSAH_8.c   **** #define		BLINK_LED_WHILE_WAITING
 149:bootSAH_8.c   **** 
 150:bootSAH_8.c   **** #ifdef __AVR_ATmega2560__
 151:bootSAH_8.c   **** 	#define PROGLED_PORT	PORTB
 152:bootSAH_8.c   **** 	#define PROGLED_DDR		DDRB
 153:bootSAH_8.c   **** 	#define PROGLED_PIN		PINB6
 154:bootSAH_8.c   **** #endif
 155:bootSAH_8.c   **** 
 156:bootSAH_8.c   **** 
 157:bootSAH_8.c   **** 
 158:bootSAH_8.c   **** /*
 159:bootSAH_8.c   ****  * define CPU frequency in Mhz here if not defined in Makefile
 160:bootSAH_8.c   ****  */
 161:bootSAH_8.c   **** #ifndef F_CPU
 162:bootSAH_8.c   **** 	#define F_CPU 16000000UL
 163:bootSAH_8.c   **** #endif
 164:bootSAH_8.c   **** 
 165:bootSAH_8.c   **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 166:bootSAH_8.c   **** /*
 167:bootSAH_8.c   ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 168:bootSAH_8.c   ****  */
 169:bootSAH_8.c   **** 
 170:bootSAH_8.c   **** #ifndef BAUDRATE
 171:bootSAH_8.c   **** 	#define BAUDRATE 115200
 172:bootSAH_8.c   **** #endif
 173:bootSAH_8.c   **** 
 174:bootSAH_8.c   **** /*
 175:bootSAH_8.c   ****  *  Enable (1) or disable (0) USART double speed operation
 176:bootSAH_8.c   ****  */
 177:bootSAH_8.c   **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 178:bootSAH_8.c   **** 	#if defined (__AVR_ATmega32__)
 179:bootSAH_8.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 180:bootSAH_8.c   **** 	#else
 181:bootSAH_8.c   **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 182:bootSAH_8.c   **** 	#endif
 183:bootSAH_8.c   **** #endif
 184:bootSAH_8.c   **** 
 185:bootSAH_8.c   **** /*
 186:bootSAH_8.c   ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 187:bootSAH_8.c   ****  */
 188:bootSAH_8.c   **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 189:bootSAH_8.c   **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 190:bootSAH_8.c   **** #define CONFIG_PARAM_HW_VER				0x0F
 191:bootSAH_8.c   **** #define CONFIG_PARAM_SW_MAJOR			2
 192:bootSAH_8.c   **** #define CONFIG_PARAM_SW_MINOR			0x0A
 193:bootSAH_8.c   **** 
 194:bootSAH_8.c   **** /*
 195:bootSAH_8.c   ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 196:bootSAH_8.c   ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 197:bootSAH_8.c   ****  */
 198:bootSAH_8.c   **** //#define BOOTSIZE 1024
 199:bootSAH_8.c   **** #if FLASHEND > 0x0F000
 200:bootSAH_8.c   **** 	#define BOOTSIZE 8192
 201:bootSAH_8.c   **** #else
 202:bootSAH_8.c   **** 	#define BOOTSIZE 2048
 203:bootSAH_8.c   **** #endif
 204:bootSAH_8.c   **** 
 205:bootSAH_8.c   **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 206:bootSAH_8.c   **** 
 207:bootSAH_8.c   **** /*
 208:bootSAH_8.c   ****  * Signature bytes are not available in avr-gcc io_xxx.h
 209:bootSAH_8.c   ****  * configured for atmega2560
 210:bootSAH_8.c   ****  */
 211:bootSAH_8.c   **** #ifndef SIGNATURE_BYTES
 212:bootSAH_8.c   **** 	#define SIGNATURE_BYTES 0x1E9801
 213:bootSAH_8.c   **** #endif
 214:bootSAH_8.c   **** 
 215:bootSAH_8.c   **** /* 
 216:bootSAH_8.c   ****  * ATMega with two USART, use UART0 
 217:bootSAH_8.c   ****  * configured for atmega2560 
 218:bootSAH_8.c   ****  */
 219:bootSAH_8.c   **** #define	UART_BAUD_RATE_LOW			UBRR0L
 220:bootSAH_8.c   **** #define	UART_STATUS_REG				UCSR0A
 221:bootSAH_8.c   **** #define	UART_CONTROL_REG			UCSR0B
 222:bootSAH_8.c   **** #define	UART_ENABLE_TRANSMITTER		TXEN0
 223:bootSAH_8.c   **** #define	UART_ENABLE_RECEIVER		RXEN0
 224:bootSAH_8.c   **** #define	UART_TRANSMIT_COMPLETE		TXC0
 225:bootSAH_8.c   **** #define	UART_RECEIVE_COMPLETE		RXC0
 226:bootSAH_8.c   **** #define	UART_DATA_REG				UDR0
 227:bootSAH_8.c   **** #define	UART_DOUBLE_SPEED			U2X0
 228:bootSAH_8.c   **** 
 229:bootSAH_8.c   **** 
 230:bootSAH_8.c   **** /*
 231:bootSAH_8.c   ****  * Macro to calculate UBBR from XTAL and baudrate
 232:bootSAH_8.c   ****  */
 233:bootSAH_8.c   **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 234:bootSAH_8.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 235:bootSAH_8.c   **** #elif defined(__AVR_ATmega32__)
 236:bootSAH_8.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 237:bootSAH_8.c   **** #elif UART_BAUDRATE_DOUBLE_SPEED
 238:bootSAH_8.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 239:bootSAH_8.c   **** #else
 240:bootSAH_8.c   **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 241:bootSAH_8.c   **** #endif
 242:bootSAH_8.c   **** 
 243:bootSAH_8.c   **** 
 244:bootSAH_8.c   **** /*
 245:bootSAH_8.c   ****  * States used in the receive state machine
 246:bootSAH_8.c   ****  */
 247:bootSAH_8.c   **** #define	ST_START		0
 248:bootSAH_8.c   **** #define	ST_GET_SEQ_NUM	1
 249:bootSAH_8.c   **** #define ST_MSG_SIZE_1	2
 250:bootSAH_8.c   **** #define ST_MSG_SIZE_2	3
 251:bootSAH_8.c   **** #define ST_GET_TOKEN	4
 252:bootSAH_8.c   **** #define ST_GET_DATA		5
 253:bootSAH_8.c   **** #define	ST_GET_CHECK	6
 254:bootSAH_8.c   **** #define	ST_PROCESS		7
 255:bootSAH_8.c   **** 
 256:bootSAH_8.c   **** /*
 257:bootSAH_8.c   ****  * use 16bit address variable for ATmegas with <= 64K flash
 258:bootSAH_8.c   ****  */
 259:bootSAH_8.c   **** // #if defined(RAMPZ)
 260:bootSAH_8.c   **** // 	typedef uint32_t address_t;
 261:bootSAH_8.c   **** // #else
 262:bootSAH_8.c   **** // 	typedef uint16_t address_t;
 263:bootSAH_8.c   **** // #endif
 264:bootSAH_8.c   **** 
 265:bootSAH_8.c   **** /*
 266:bootSAH_8.c   ****  * function prototypes
 267:bootSAH_8.c   ****  */
 268:bootSAH_8.c   **** static void sendchar(char c);
 269:bootSAH_8.c   **** static unsigned char recchar(void);
 270:bootSAH_8.c   **** 
 271:bootSAH_8.c   **** /*
 272:bootSAH_8.c   ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 273:bootSAH_8.c   ****  * to reduce the code size, we need to provide our own initialization
 274:bootSAH_8.c   ****  */
 275:bootSAH_8.c   **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 276:bootSAH_8.c   **** #include <avr/sfr_defs.h>
 277:bootSAH_8.c   **** 
 278:bootSAH_8.c   **** //#define	SPH_REG	0x3E
 279:bootSAH_8.c   **** //#define	SPL_REG	0x3D
 280:bootSAH_8.c   **** 
 281:bootSAH_8.c   **** //*****************************************************************************
 282:bootSAH_8.c   **** void __jumpMain(void)
 283:bootSAH_8.c   **** {
 284:bootSAH_8.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 285:bootSAH_8.c   **** //*	the first line did not do the job on the ATmega128
 286:bootSAH_8.c   **** 
 287:bootSAH_8.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 288:bootSAH_8.c   **** 
 289:bootSAH_8.c   **** //*	set stack pointer to top of RAM
 290:bootSAH_8.c   **** 
 291:bootSAH_8.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 292:bootSAH_8.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 293:bootSAH_8.c   **** 
 294:bootSAH_8.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 295:bootSAH_8.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 296:bootSAH_8.c   **** 
 297:bootSAH_8.c   **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 298:bootSAH_8.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 299:bootSAH_8.c   **** 	asm volatile ( "jmp main");												// jump to main()
 300:bootSAH_8.c   **** }
 301:bootSAH_8.c   **** 
 302:bootSAH_8.c   **** 
 303:bootSAH_8.c   **** //*****************************************************************************
 304:bootSAH_8.c   **** void delay_ms(unsigned int timedelay)
 305:bootSAH_8.c   **** {
 306:bootSAH_8.c   **** 	unsigned int i;
 307:bootSAH_8.c   **** 	for (i=0;i<timedelay;i++)
 308:bootSAH_8.c   **** 	{
 309:bootSAH_8.c   **** 		_delay_ms(0.5);
 310:bootSAH_8.c   **** 	}
 311:bootSAH_8.c   **** }
 312:bootSAH_8.c   **** 
 313:bootSAH_8.c   **** 
 314:bootSAH_8.c   **** //*****************************************************************************
 315:bootSAH_8.c   **** /*
 316:bootSAH_8.c   ****  * send single byte to USART, wait until transmission is completed
 317:bootSAH_8.c   ****  */
 318:bootSAH_8.c   **** static void sendchar(char c)
 319:bootSAH_8.c   **** {
  15               		.loc 1 319 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 320:bootSAH_8.c   **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 320 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 321:bootSAH_8.c   **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 321 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 322:bootSAH_8.c   **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 322 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE13:
  39               		.section	.init9,"ax",@progbits
  40               	.global	__jumpMain
  42               	__jumpMain:
  43               	.LFB11:
 283:bootSAH_8.c   **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  44               		.loc 1 283 0
  45               		.cfi_startproc
  46               	/* prologue: naked */
  47               	/* frame size = 0 */
  48               	/* stack size = 0 */
  49               	.L__stack_usage = 0
 287:bootSAH_8.c   **** 
  50               		.loc 1 287 0
  51               	/* #APP */
  52               	 ;  287 "bootSAH_8.c" 1
  53               		.set __stack, 8703
  54               	 ;  0 "" 2
 291:bootSAH_8.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  55               		.loc 1 291 0
  56               	 ;  291 "bootSAH_8.c" 1
  57 0000 01E2      		ldi	16, 33
  58               	 ;  0 "" 2
 292:bootSAH_8.c   **** 
  59               		.loc 1 292 0
  60               	 ;  292 "bootSAH_8.c" 1
  61 0002 0EBF      		out 62,16
  62               	 ;  0 "" 2
 294:bootSAH_8.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  63               		.loc 1 294 0
  64               	 ;  294 "bootSAH_8.c" 1
  65 0004 0FEF      		ldi	16, 255
  66               	 ;  0 "" 2
 295:bootSAH_8.c   **** 
  67               		.loc 1 295 0
  68               	 ;  295 "bootSAH_8.c" 1
  69 0006 0DBF      		out 61,16
  70               	 ;  0 "" 2
 297:bootSAH_8.c   **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  71               		.loc 1 297 0
  72               	 ;  297 "bootSAH_8.c" 1
  73 0008 1124      		clr __zero_reg__
  74               	 ;  0 "" 2
 298:bootSAH_8.c   **** 	asm volatile ( "jmp main");												// jump to main()
  75               		.loc 1 298 0
  76               	 ;  298 "bootSAH_8.c" 1
  77 000a 1FBE      		out 63, __zero_reg__
  78               	 ;  0 "" 2
 299:bootSAH_8.c   **** }
  79               		.loc 1 299 0
  80               	 ;  299 "bootSAH_8.c" 1
  81 000c 0C94 0000 		jmp main
  82               	 ;  0 "" 2
  83               	/* epilogue start */
 300:bootSAH_8.c   **** 
  84               		.loc 1 300 0
  85               	/* #NOAPP */
  86               		.cfi_endproc
  87               	.LFE11:
  89               		.text
  90               	.global	delay_ms
  92               	delay_ms:
  93               	.LFB12:
 305:bootSAH_8.c   **** 	unsigned int i;
  94               		.loc 1 305 0
  95               		.cfi_startproc
  96               	.LVL3:
  97               	/* prologue: function */
  98               	/* frame size = 0 */
  99               	/* stack size = 0 */
 100               	.L__stack_usage = 0
 307:bootSAH_8.c   **** 	{
 101               		.loc 1 307 0
 102 0018 20E0      		ldi r18,0
 103 001a 30E0      		ldi r19,0
 104               	.LVL4:
 105               	.L8:
 307:bootSAH_8.c   **** 	{
 106               		.loc 1 307 0 is_stmt 0 discriminator 1
 107 001c 2817      		cp r18,r24
 108 001e 3907      		cpc r19,r25
 109 0020 01F0      		breq .L10
 110               	.LVL5:
 111               	.LBB38:
 112               	.LBB39:
 113               		.file 2 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\ut
   1:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:e:\programfiles\atmelstudio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 114               		.loc 2 187 0 is_stmt 1
 115 0022 EFEC      		ldi r30,lo8(1999)
 116 0024 F7E0      		ldi r31,hi8(1999)
 117 0026 3197      	1:	sbiw r30,1
 118 0028 01F4      		brne 1b
 119 002a 00C0      		rjmp .
 120 002c 0000      		nop
 121               	.LVL6:
 122               	.LBE39:
 123               	.LBE38:
 307:bootSAH_8.c   **** 	{
 124               		.loc 1 307 0
 125 002e 2F5F      		subi r18,-1
 126 0030 3F4F      		sbci r19,-1
 127               	.LVL7:
 128 0032 00C0      		rjmp .L8
 129               	.L10:
 130               	/* epilogue start */
 311:bootSAH_8.c   **** 
 131               		.loc 1 311 0
 132 0034 0895      		ret
 133               		.cfi_endproc
 134               	.LFE12:
 136               		.section	.text.startup,"ax",@progbits
 137               	.global	main
 139               	main:
 140               	.LFB17:
 323:bootSAH_8.c   **** }
 324:bootSAH_8.c   **** 
 325:bootSAH_8.c   **** 
 326:bootSAH_8.c   **** //************************************************************************
 327:bootSAH_8.c   **** static int	Serial_Available(void)
 328:bootSAH_8.c   **** {
 329:bootSAH_8.c   **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 330:bootSAH_8.c   **** }
 331:bootSAH_8.c   **** 
 332:bootSAH_8.c   **** 
 333:bootSAH_8.c   **** //*****************************************************************************
 334:bootSAH_8.c   **** /*
 335:bootSAH_8.c   ****  * Read single byte from USART, block if no data available
 336:bootSAH_8.c   ****  */
 337:bootSAH_8.c   **** static unsigned char recchar(void)
 338:bootSAH_8.c   **** {
 339:bootSAH_8.c   **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 340:bootSAH_8.c   **** 	{
 341:bootSAH_8.c   **** 		// wait for data
 342:bootSAH_8.c   **** 	}
 343:bootSAH_8.c   **** 	return UART_DATA_REG;
 344:bootSAH_8.c   **** }
 345:bootSAH_8.c   **** 
 346:bootSAH_8.c   **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 347:bootSAH_8.c   **** //*****************************************************************************
 348:bootSAH_8.c   **** static unsigned char recchar_timeout(void)
 349:bootSAH_8.c   **** {
 350:bootSAH_8.c   **** uint32_t count = 0;
 351:bootSAH_8.c   **** 
 352:bootSAH_8.c   **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 353:bootSAH_8.c   **** 	{
 354:bootSAH_8.c   **** 		// wait for data
 355:bootSAH_8.c   **** 		count++;
 356:bootSAH_8.c   **** 		if (count > MAX_TIME_COUNT)
 357:bootSAH_8.c   **** 		{
 358:bootSAH_8.c   **** 		unsigned int	data;
 359:bootSAH_8.c   **** 		#if (FLASHEND > 0x10000)
 360:bootSAH_8.c   **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 361:bootSAH_8.c   **** 		#else
 362:bootSAH_8.c   **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 363:bootSAH_8.c   **** 		#endif
 364:bootSAH_8.c   **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 365:bootSAH_8.c   **** 			{
 366:bootSAH_8.c   **** 				asm volatile(
 367:bootSAH_8.c   **** 						"clr	r30		\n\t"
 368:bootSAH_8.c   **** 						"clr	r31		\n\t"
 369:bootSAH_8.c   **** 						"ijmp	\n\t"
 370:bootSAH_8.c   **** 						);
 371:bootSAH_8.c   **** 			}
 372:bootSAH_8.c   **** 			count	=	0;
 373:bootSAH_8.c   **** 		}
 374:bootSAH_8.c   **** 	}
 375:bootSAH_8.c   **** 	return UART_DATA_REG;
 376:bootSAH_8.c   **** }
 377:bootSAH_8.c   **** 
 378:bootSAH_8.c   **** /*
 379:bootSAH_8.c   **** unsigned char hexArr[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
 380:bootSAH_8.c   **** 
 381:bootSAH_8.c   **** void printByte(uint8_t numData)
 382:bootSAH_8.c   **** {
 383:bootSAH_8.c   **** 	char chData1, chData2;
 384:bootSAH_8.c   **** 	chData1 = hexArr[numData >> 4];
 385:bootSAH_8.c   **** 	chData2 = hexArr[numData & 0xF];
 386:bootSAH_8.c   **** 	sendchar(chData1);
 387:bootSAH_8.c   **** 	sendchar(chData2);
 388:bootSAH_8.c   **** }
 389:bootSAH_8.c   **** */
 390:bootSAH_8.c   **** 
 391:bootSAH_8.c   **** //*	for watch dog timer startup
 392:bootSAH_8.c   **** void (*app_start)(void) = 0x0000;
 393:bootSAH_8.c   **** 
 394:bootSAH_8.c   **** 
 395:bootSAH_8.c   **** //*****************************************************************************
 396:bootSAH_8.c   **** int main(void)
 397:bootSAH_8.c   **** {
 141               		.loc 1 397 0
 142               		.cfi_startproc
 143 0000 CF93      		push r28
 144               	.LCFI0:
 145               		.cfi_def_cfa_offset 4
 146               		.cfi_offset 28, -3
 147 0002 DF93      		push r29
 148               	.LCFI1:
 149               		.cfi_def_cfa_offset 5
 150               		.cfi_offset 29, -4
 151 0004 CDB7      		in r28,__SP_L__
 152 0006 DEB7      		in r29,__SP_H__
 153               	.LCFI2:
 154               		.cfi_def_cfa_register 28
 155 0008 C052      		subi r28,32
 156 000a D140      		sbci r29,1
 157               	.LCFI3:
 158               		.cfi_def_cfa_offset 293
 159 000c 0FB6      		in __tmp_reg__,__SREG__
 160 000e F894      		cli
 161 0010 DEBF      		out __SP_H__,r29
 162 0012 0FBE      		out __SREG__,__tmp_reg__
 163 0014 CDBF      		out __SP_L__,r28
 164               	/* prologue: function */
 165               	/* frame size = 288 */
 166               	/* stack size = 290 */
 167               	.L__stack_usage = 290
 168               	.LVL8:
 398:bootSAH_8.c   **** 	/*uint32_t	address			=	0;*/
 399:bootSAH_8.c   **** 	uint32_t	fTmpPgAddr	=	0;
 400:bootSAH_8.c   **** 	uint32_t	fPageAddr	=	0;
 401:bootSAH_8.c   **** 	uint8_t		msgParseState;
 402:bootSAH_8.c   **** 	uint16_t	ii				=	0;
 403:bootSAH_8.c   **** 	uint8_t		checksum		=	0;
 404:bootSAH_8.c   **** 	uint8_t		seqNum			=	0;
 405:bootSAH_8.c   **** 	uint16_t	msgLength		=	0;
 406:bootSAH_8.c   **** 	uint8_t		msgBuffer[285];
 407:bootSAH_8.c   **** 	uint8_t		c, *p;
 408:bootSAH_8.c   **** 	uint8_t		isLeave = 0;
 409:bootSAH_8.c   **** 
 410:bootSAH_8.c   **** 	uint32_t	boot_timeout;
 411:bootSAH_8.c   **** 	uint32_t	boot_timer;
 412:bootSAH_8.c   **** 	uint8_t		boot_state;
 413:bootSAH_8.c   **** /*
 414:bootSAH_8.c   **** #ifdef ENABLE_MONITOR
 415:bootSAH_8.c   **** 	uint16_t	exPointCntr		=	0;
 416:bootSAH_8.c   **** 	uint16_t	rcvdCharCntr	=	0;
 417:bootSAH_8.c   **** #endif
 418:bootSAH_8.c   **** */
 419:bootSAH_8.c   **** 
 420:bootSAH_8.c   **** 	//*	some chips dont set the stack properly
 421:bootSAH_8.c   **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 169               		.loc 1 421 0
 170               	/* #APP */
 171               	 ;  421 "bootSAH_8.c" 1
 172               		.set __stack, 8703
 173               	 ;  0 "" 2
 422:bootSAH_8.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 174               		.loc 1 422 0
 175               	 ;  422 "bootSAH_8.c" 1
 176 0016 01E2      		ldi	16, 33
 177               	 ;  0 "" 2
 423:bootSAH_8.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 178               		.loc 1 423 0
 179               	 ;  423 "bootSAH_8.c" 1
 180 0018 0EBF      		out 62,16
 181               	 ;  0 "" 2
 424:bootSAH_8.c   **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 182               		.loc 1 424 0
 183               	 ;  424 "bootSAH_8.c" 1
 184 001a 0FEF      		ldi	16, 255
 185               	 ;  0 "" 2
 425:bootSAH_8.c   **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 186               		.loc 1 425 0
 187               	 ;  425 "bootSAH_8.c" 1
 188 001c 0DBF      		out 61,16
 189               	 ;  0 "" 2
 426:bootSAH_8.c   **** 
 427:bootSAH_8.c   **** 	//************************************************************************
 428:bootSAH_8.c   **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 429:bootSAH_8.c   **** 	//*	handle the watch dog timer
 430:bootSAH_8.c   **** 	uint8_t	mcuStatusReg;
 431:bootSAH_8.c   **** 	mcuStatusReg	=	MCUSR;
 190               		.loc 1 431 0
 191               	/* #NOAPP */
 192 001e 94B7      		in r25,0x34
 193               	.LVL9:
 432:bootSAH_8.c   **** 
 433:bootSAH_8.c   **** 	__asm__ __volatile__ ("cli");
 194               		.loc 1 433 0
 195               	/* #APP */
 196               	 ;  433 "bootSAH_8.c" 1
 197 0020 F894      		cli
 198               	 ;  0 "" 2
 434:bootSAH_8.c   **** 	__asm__ __volatile__ ("wdr");
 199               		.loc 1 434 0
 200               	 ;  434 "bootSAH_8.c" 1
 201 0022 A895      		wdr
 202               	 ;  0 "" 2
 435:bootSAH_8.c   **** 	
 436:bootSAH_8.c   **** 	/*MCUSR	=	0;*/
 437:bootSAH_8.c   **** 	MCUSR &= ~(1<<WDRF);		// clear WDRF in MCUSR
 203               		.loc 1 437 0
 204               	/* #NOAPP */
 205 0024 84B7      		in r24,0x34
 206 0026 877F      		andi r24,lo8(-9)
 207 0028 84BF      		out 0x34,r24
 438:bootSAH_8.c   **** 	
 439:bootSAH_8.c   **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 208               		.loc 1 439 0
 209 002a 8091 6000 		lds r24,96
 210 002e 8861      		ori r24,lo8(24)
 211 0030 8093 6000 		sts 96,r24
 440:bootSAH_8.c   **** 	WDTCSR	=	0;
 212               		.loc 1 440 0
 213 0034 1092 6000 		sts 96,__zero_reg__
 441:bootSAH_8.c   **** 	__asm__ __volatile__ ("sei");
 214               		.loc 1 441 0
 215               	/* #APP */
 216               	 ;  441 "bootSAH_8.c" 1
 217 0038 7894      		sei
 218               	 ;  0 "" 2
 442:bootSAH_8.c   **** 	// check if WDT generated the reset, if so, go straight to app
 443:bootSAH_8.c   **** 	if (mcuStatusReg & _BV(WDRF))
 219               		.loc 1 443 0
 220               	/* #NOAPP */
 221 003a 93FF      		sbrs r25,3
 222 003c 00C0      		rjmp .L12
 444:bootSAH_8.c   **** 	{
 445:bootSAH_8.c   **** 		app_start();
 223               		.loc 1 445 0
 224 003e E091 0000 		lds r30,app_start
 225 0042 F091 0000 		lds r31,app_start+1
 226 0046 1995      		eicall
 227               	.LVL10:
 228               	.L12:
 446:bootSAH_8.c   **** 	}
 447:bootSAH_8.c   **** 	//************************************************************************
 448:bootSAH_8.c   **** 
 449:bootSAH_8.c   **** 
 450:bootSAH_8.c   **** 	boot_timer	=	0;
 451:bootSAH_8.c   **** 	boot_state	=	0;
 452:bootSAH_8.c   **** 
 453:bootSAH_8.c   **** #ifdef BLINK_LED_WHILE_WAITING
 454:bootSAH_8.c   **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 455:bootSAH_8.c   **** //	boot_timeout	=	170000;
 456:bootSAH_8.c   **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 457:bootSAH_8.c   **** #else
 458:bootSAH_8.c   **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 459:bootSAH_8.c   **** #endif
 460:bootSAH_8.c   **** 	/*
 461:bootSAH_8.c   **** 	 * Branch to bootloader or application code ?
 462:bootSAH_8.c   **** 	 */
 463:bootSAH_8.c   **** 
 464:bootSAH_8.c   **** #ifndef REMOVE_BOOTLOADER_LED
 465:bootSAH_8.c   **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 466:bootSAH_8.c   **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 229               		.loc 1 466 0
 230 0048 269A      		sbi 0x4,6
 467:bootSAH_8.c   **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 468:bootSAH_8.c   **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 231               		.loc 1 468 0
 232 004a 2E9A      		sbi 0x5,6
 469:bootSAH_8.c   **** 	delay_ms(100);
 233               		.loc 1 469 0
 234 004c 84E6      		ldi r24,lo8(100)
 235 004e 90E0      		ldi r25,0
 236 0050 0E94 0000 		call delay_ms
 237               	.LVL11:
 470:bootSAH_8.c   **** 
 471:bootSAH_8.c   **** //#ifdef _DEBUG_WITH_LEDS_
 472:bootSAH_8.c   **** // 	for (ii=0; ii<3; ii++)
 473:bootSAH_8.c   **** // 	{
 474:bootSAH_8.c   **** // 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 475:bootSAH_8.c   **** // 		delay_ms(100);
 476:bootSAH_8.c   **** // 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 477:bootSAH_8.c   **** // 		delay_ms(100);
 478:bootSAH_8.c   **** // 	}
 479:bootSAH_8.c   **** // 	delay_ms(100);
 480:bootSAH_8.c   **** // #endif
 481:bootSAH_8.c   **** 
 482:bootSAH_8.c   **** #endif
 483:bootSAH_8.c   **** 	/*
 484:bootSAH_8.c   **** 	 * Init UART
 485:bootSAH_8.c   **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 486:bootSAH_8.c   **** 	 */
 487:bootSAH_8.c   **** #if UART_BAUDRATE_DOUBLE_SPEED
 488:bootSAH_8.c   **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 238               		.loc 1 488 0
 239 0054 8091 C000 		lds r24,192
 240 0058 8260      		ori r24,lo8(2)
 241 005a 8093 C000 		sts 192,r24
 489:bootSAH_8.c   **** #endif
 490:bootSAH_8.c   **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 242               		.loc 1 490 0
 243 005e 80E1      		ldi r24,lo8(16)
 244 0060 8093 C400 		sts 196,r24
 491:bootSAH_8.c   **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 245               		.loc 1 491 0
 246 0064 88E1      		ldi r24,lo8(24)
 247 0066 8093 C100 		sts 193,r24
 492:bootSAH_8.c   **** 
 493:bootSAH_8.c   **** 	asm volatile ("nop");			// wait until port has changed
 248               		.loc 1 493 0
 249               	/* #APP */
 250               	 ;  493 "bootSAH_8.c" 1
 251 006a 0000      		nop
 252               	 ;  0 "" 2
 494:bootSAH_8.c   **** 
 495:bootSAH_8.c   **** #ifdef _DEBUG_SERIAL_
 496:bootSAH_8.c   **** //	delay_ms(500);
 497:bootSAH_8.c   **** 
 498:bootSAH_8.c   **** 	sendchar('u');
 253               		.loc 1 498 0
 254               	/* #NOAPP */
 255 006c 85E7      		ldi r24,lo8(117)
 256 006e 0E94 0000 		call sendchar
 257               	.LVL12:
 499:bootSAH_8.c   **** 	sendchar('t');
 258               		.loc 1 499 0
 259 0072 84E7      		ldi r24,lo8(116)
 260 0074 0E94 0000 		call sendchar
 261               	.LVL13:
 500:bootSAH_8.c   **** 	sendchar('e');
 262               		.loc 1 500 0
 263 0078 85E6      		ldi r24,lo8(101)
 264 007a 0E94 0000 		call sendchar
 265               	.LVL14:
 501:bootSAH_8.c   **** 	sendchar('c');
 266               		.loc 1 501 0
 267 007e 83E6      		ldi r24,lo8(99)
 268 0080 0E94 0000 		call sendchar
 269               	.LVL15:
 502:bootSAH_8.c   **** 	sendchar('h');
 270               		.loc 1 502 0
 271 0084 88E6      		ldi r24,lo8(104)
 272 0086 0E94 0000 		call sendchar
 273               	.LVL16:
 503:bootSAH_8.c   **** 	sendchar('_');
 274               		.loc 1 503 0
 275 008a 8FE5      		ldi r24,lo8(95)
 276 008c 0E94 0000 		call sendchar
 277               	.LVL17:
 504:bootSAH_8.c   **** 	sendchar('B');
 278               		.loc 1 504 0
 279 0090 82E4      		ldi r24,lo8(66)
 280 0092 0E94 0000 		call sendchar
 281               	.LVL18:
 505:bootSAH_8.c   **** 	sendchar('B');
 282               		.loc 1 505 0
 283 0096 82E4      		ldi r24,lo8(66)
 284 0098 0E94 0000 		call sendchar
 285               	.LVL19:
 506:bootSAH_8.c   **** 
 507:bootSAH_8.c   **** 	sendchar(0x0d);
 286               		.loc 1 507 0
 287 009c 8DE0      		ldi r24,lo8(13)
 288 009e 0E94 0000 		call sendchar
 289               	.LVL20:
 508:bootSAH_8.c   **** 	sendchar(0x0a);
 290               		.loc 1 508 0
 291 00a2 8AE0      		ldi r24,lo8(10)
 292 00a4 0E94 0000 		call sendchar
 293               	.LVL21:
 294 00a8 10E0      		ldi r17,0
 295 00aa C12C      		mov r12,__zero_reg__
 296 00ac D12C      		mov r13,__zero_reg__
 297 00ae 7601      		movw r14,r12
 509:bootSAH_8.c   **** /*	
 510:bootSAH_8.c   **** 	//FLASHEND and BOOTSIZE
 511:bootSAH_8.c   **** // 	uint32_t flash_end = FLASHEND;
 512:bootSAH_8.c   **** // 	uint16_t boot_size = BOOTSIZE;
 513:bootSAH_8.c   **** // 	uint16_t blink_count = _BLINK_LOOP_COUNT_;
 514:bootSAH_8.c   **** // 	
 515:bootSAH_8.c   **** // 	printByte((uint8_t)(flash_end >> 24));
 516:bootSAH_8.c   **** // 	printByte((uint8_t)((flash_end >> 16) & 0xff));
 517:bootSAH_8.c   **** // 	printByte((uint8_t)((flash_end >> 8) & 0xff));
 518:bootSAH_8.c   **** // 	printByte((uint8_t)(flash_end & 0xff));
 519:bootSAH_8.c   **** // 	
 520:bootSAH_8.c   **** // 	sendchar(' ');
 521:bootSAH_8.c   **** // 	
 522:bootSAH_8.c   **** // 	printByte((uint8_t)((boot_size >> 8) & 0xff));
 523:bootSAH_8.c   **** // 	printByte((uint8_t)(boot_size & 0xff));
 524:bootSAH_8.c   **** // 	
 525:bootSAH_8.c   **** // 	printByte((uint8_t)((blink_count >> 8) & 0xff));
 526:bootSAH_8.c   **** // 	printByte((uint8_t)(blink_count & 0xff));
 527:bootSAH_8.c   **** // 
 528:bootSAH_8.c   **** // 	delay_ms(100);
 529:bootSAH_8.c   **** */
 530:bootSAH_8.c   **** 
 531:bootSAH_8.c   **** #endif
 532:bootSAH_8.c   **** 
 533:bootSAH_8.c   **** 	while (boot_state==0)
 534:bootSAH_8.c   **** 	{
 535:bootSAH_8.c   **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 536:bootSAH_8.c   **** 		{
 537:bootSAH_8.c   **** 			_delay_ms(0.001);
 538:bootSAH_8.c   **** 			boot_timer++;
 539:bootSAH_8.c   **** 			if (boot_timer > boot_timeout)
 540:bootSAH_8.c   **** 			{
 541:bootSAH_8.c   **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 542:bootSAH_8.c   **** 			}
 543:bootSAH_8.c   **** 		#ifdef BLINK_LED_WHILE_WAITING
 544:bootSAH_8.c   **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 298               		.loc 1 544 0
 299 00b0 97EC      		ldi r25,lo8(-57)
 300 00b2 892E      		mov r8,r25
 301 00b4 9BE1      		ldi r25,lo8(27)
 302 00b6 992E      		mov r9,r25
 303 00b8 A12C      		mov r10,__zero_reg__
 304 00ba B12C      		mov r11,__zero_reg__
 545:bootSAH_8.c   **** 			{
 546:bootSAH_8.c   **** 				//*	toggle the LED
 547:bootSAH_8.c   **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 305               		.loc 1 547 0
 306 00bc 00E4      		ldi r16,lo8(64)
 307               	.LVL22:
 308               	.L13:
 309               	.LBB62:
 310               	.LBB63:
 329:bootSAH_8.c   **** }
 311               		.loc 1 329 0
 312 00be 8091 C000 		lds r24,192
 313               	.LBE63:
 314               	.LBE62:
 535:bootSAH_8.c   **** 		{
 315               		.loc 1 535 0
 316 00c2 87FD      		sbrc r24,7
 317 00c4 00C0      		rjmp .L137
 535:bootSAH_8.c   **** 		{
 318               		.loc 1 535 0 is_stmt 0 discriminator 1
 319 00c6 1111      		cpse r17,__zero_reg__
 320 00c8 00C0      		rjmp .L137
 321               	.LVL23:
 322               	.LBB64:
 323               	.LBB65:
 324               		.loc 2 187 0 is_stmt 1
 325 00ca 25E0      		ldi r18,lo8(5)
 326 00cc 2A95      	1:	dec r18
 327 00ce 01F4      		brne 1b
 328 00d0 0000      		nop
 329               	.LVL24:
 330               	.LBE65:
 331               	.LBE64:
 538:bootSAH_8.c   **** 			if (boot_timer > boot_timeout)
 332               		.loc 1 538 0
 333 00d2 4FEF      		ldi r20,-1
 334 00d4 C41A      		sub r12,r20
 335 00d6 D40A      		sbc r13,r20
 336 00d8 E40A      		sbc r14,r20
 337 00da F40A      		sbc r15,r20
 338               	.LVL25:
 541:bootSAH_8.c   **** 			}
 339               		.loc 1 541 0
 340 00dc 11E0      		ldi r17,lo8(1)
 341               	.LVL26:
 342 00de 81E2      		ldi r24,33
 343 00e0 C816      		cp r12,r24
 344 00e2 8EE4      		ldi r24,78
 345 00e4 D806      		cpc r13,r24
 346 00e6 E104      		cpc r14,__zero_reg__
 347 00e8 F104      		cpc r15,__zero_reg__
 348 00ea 00F4      		brsh .L14
 349 00ec 10E0      		ldi r17,0
 350               	.L14:
 351               	.LVL27:
 544:bootSAH_8.c   **** 			{
 352               		.loc 1 544 0
 353 00ee C701      		movw r24,r14
 354 00f0 B601      		movw r22,r12
 355 00f2 A501      		movw r20,r10
 356 00f4 9401      		movw r18,r8
 357 00f6 0E94 0000 		call __udivmodsi4
 358 00fa 672B      		or r22,r23
 359 00fc 682B      		or r22,r24
 360 00fe 692B      		or r22,r25
 361 0100 01F4      		brne .L13
 362               		.loc 1 547 0
 363 0102 85B1      		in r24,0x5
 364 0104 8027      		eor r24,r16
 365 0106 85B9      		out 0x5,r24
 366 0108 00C0      		rjmp .L13
 367               	.LVL28:
 368               	.L137:
 548:bootSAH_8.c   **** 			}
 549:bootSAH_8.c   **** 		#endif
 550:bootSAH_8.c   **** 		}
 551:bootSAH_8.c   **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 369               		.loc 1 551 0
 370 010a 1F5F      		subi r17,lo8(-(1))
 371               	.LVL29:
 552:bootSAH_8.c   **** 	}
 553:bootSAH_8.c   **** 
 554:bootSAH_8.c   **** 
 555:bootSAH_8.c   **** 	if (boot_state==1)
 372               		.loc 1 555 0
 373 010c 1130      		cpi r17,lo8(1)
 374 010e 01F0      		breq .+2
 375 0110 00C0      		rjmp .L20
 376 0112 C25E      		subi r28,lo8(-286)
 377 0114 DE4F      		sbci r29,hi8(-286)
 378 0116 1882      		st Y,__zero_reg__
 379 0118 CE51      		subi r28,lo8(286)
 380 011a D140      		sbci r29,hi8(286)
 381 011c D12C      		mov r13,__zero_reg__
 382 011e 212C      		mov r2,__zero_reg__
 383 0120 312C      		mov r3,__zero_reg__
 384 0122 812C      		mov r8,__zero_reg__
 385 0124 912C      		mov r9,__zero_reg__
 386 0126 5401      		movw r10,r8
 387 0128 412C      		mov r4,__zero_reg__
 388 012a 512C      		mov r5,__zero_reg__
 389 012c 3201      		movw r6,r4
 390               	.LVL30:
 391               	.L83:
 508:bootSAH_8.c   **** /*	
 392               		.loc 1 508 0
 393 012e 20E0      		ldi r18,0
 394 0130 30E0      		ldi r19,0
 395 0132 80E0      		ldi r24,0
 396               	.LVL31:
 556:bootSAH_8.c   **** 	{
 557:bootSAH_8.c   **** 		//*	main loop
 558:bootSAH_8.c   **** 		while (!isLeave)
 559:bootSAH_8.c   **** 		{
 560:bootSAH_8.c   **** 			/*
 561:bootSAH_8.c   **** 			 * Collect received bytes to a complete message
 562:bootSAH_8.c   **** 			 */
 563:bootSAH_8.c   **** 			msgParseState	=	ST_START;
 564:bootSAH_8.c   **** 			while ( msgParseState != ST_PROCESS )
 565:bootSAH_8.c   **** 			{
 566:bootSAH_8.c   **** 				if (boot_state==1)
 397               		.loc 1 566 0
 398 0134 1130      		cpi r17,lo8(1)
 399 0136 01F0      		breq .L141
 400               	.LVL32:
 401               	.L24:
 508:bootSAH_8.c   **** /*	
 402               		.loc 1 508 0
 403 0138 41E0      		ldi r20,lo8(1)
 404 013a 52E1      		ldi r21,lo8(18)
 405 013c 6AE7      		ldi r22,lo8(122)
 406 013e 70E0      		ldi r23,0
 407               	.L23:
 408               	.LVL33:
 409               	.LBB66:
 410               	.LBB67:
 352:bootSAH_8.c   **** 	{
 411               		.loc 1 352 0
 412 0140 9091 C000 		lds r25,192
 413 0144 97FD      		sbrc r25,7
 414 0146 00C0      		rjmp .L141
 415               	.LVL34:
 416 0148 4150      		subi r20,1
 417 014a 5109      		sbc r21,__zero_reg__
 418 014c 6109      		sbc r22,__zero_reg__
 419 014e 7109      		sbc r23,__zero_reg__
 420               	.LVL35:
 356:bootSAH_8.c   **** 		{
 421               		.loc 1 356 0
 422 0150 01F4      		brne .L23
 423               	.LVL36:
 424               	.LBB68:
 425               	.LBB69:
 360:bootSAH_8.c   **** 		#else
 426               		.loc 1 360 0
 427               	/* #APP */
 428               	 ;  360 "bootSAH_8.c" 1
 429 0152 6BBF      		out 59, r22
 430 0154 FA01      		movw r30, r20
 431 0156 4791      		elpm r20, Z+
 432 0158 5691      		elpm r21, Z
 433               		
 434               	 ;  0 "" 2
 435               	.LVL37:
 436               	/* #NOAPP */
 437               	.LBE69:
 364:bootSAH_8.c   **** 			{
 438               		.loc 1 364 0
 439 015a 4F3F      		cpi r20,-1
 440 015c 5F4F      		sbci r21,-1
 441 015e 01F0      		breq .L24
 366:bootSAH_8.c   **** 						"clr	r30		\n\t"
 442               		.loc 1 366 0
 443               	/* #APP */
 444               	 ;  366 "bootSAH_8.c" 1
 445 0160 EE27      		clr	r30		
 446 0162 FF27      		clr	r31		
 447 0164 0994      		ijmp	
 448               		
 449               	 ;  0 "" 2
 450               	/* #NOAPP */
 451 0166 00C0      		rjmp .L24
 452               	.LVL38:
 453               	.L141:
 454               	.LBE68:
 375:bootSAH_8.c   **** }
 455               		.loc 1 375 0
 456 0168 9091 C600 		lds r25,198
 457               	.LVL39:
 458               	.LBE67:
 459               	.LBE66:
 567:bootSAH_8.c   **** 				{
 568:bootSAH_8.c   **** 					boot_state	=	0;
 569:bootSAH_8.c   **** 					c			=	UART_DATA_REG;
 570:bootSAH_8.c   **** 				}
 571:bootSAH_8.c   **** 				else
 572:bootSAH_8.c   **** 				{
 573:bootSAH_8.c   **** 				//	c	=	recchar();
 574:bootSAH_8.c   **** 					c	=	recchar_timeout();
 575:bootSAH_8.c   **** 					
 576:bootSAH_8.c   **** 				}		
 577:bootSAH_8.c   **** 
 578:bootSAH_8.c   **** 				switch (msgParseState)
 460               		.loc 1 578 0
 461 016c 8330      		cpi r24,lo8(3)
 462 016e 01F0      		breq .L27
 463 0170 00F4      		brsh .L28
 464 0172 8130      		cpi r24,lo8(1)
 465 0174 01F0      		breq .L29
 466 0176 00F0      		brlo .L138
 467 0178 00C0      		rjmp .L148
 468               	.L28:
 469 017a 8530      		cpi r24,lo8(5)
 470 017c 01F0      		breq .L32
 471 017e 00F0      		brlo .L33
 472 0180 8630      		cpi r24,lo8(6)
 473 0182 01F0      		breq .L34
 474 0184 00C0      		rjmp .L149
 475               	.L138:
 579:bootSAH_8.c   **** 				{
 580:bootSAH_8.c   **** 					case ST_START:
 581:bootSAH_8.c   **** 				if ( c == MESSAGE_START )
 476               		.loc 1 581 0
 477 0186 9B31      		cpi r25,lo8(27)
 478 0188 01F4      		brne .L24
 582:bootSAH_8.c   **** 						{
 583:bootSAH_8.c   **** 							msgParseState	=	ST_GET_SEQ_NUM;
 584:bootSAH_8.c   **** 							checksum		=	MESSAGE_START^0;
 479               		.loc 1 584 0
 480 018a 8BE1      		ldi r24,lo8(27)
 481 018c D82E      		mov r13,r24
 583:bootSAH_8.c   **** 							checksum		=	MESSAGE_START^0;
 482               		.loc 1 583 0
 483 018e 81E0      		ldi r24,lo8(1)
 484 0190 00C0      		rjmp .L24
 485               	.L29:
 486               	.LVL40:
 585:bootSAH_8.c   **** 						}
 586:bootSAH_8.c   **** 						break;
 587:bootSAH_8.c   **** 
 588:bootSAH_8.c   **** 					case ST_GET_SEQ_NUM:
 589:bootSAH_8.c   **** //					#ifdef _FIX_ISSUE_505_
 590:bootSAH_8.c   **** 						seqNum			=	c;
 591:bootSAH_8.c   **** 						msgParseState	=	ST_MSG_SIZE_1;
 592:bootSAH_8.c   **** 						checksum		^=	c;
 487               		.loc 1 592 0
 488 0192 D926      		eor r13,r25
 489               	.LVL41:
 593:bootSAH_8.c   **** // 					#else
 594:bootSAH_8.c   **** // 						if ( (c == 1) || (c == seqNum) )
 595:bootSAH_8.c   **** // 						{
 596:bootSAH_8.c   **** // 							seqNum			=	c;
 597:bootSAH_8.c   **** // 							msgParseState	=	ST_MSG_SIZE_1;
 598:bootSAH_8.c   **** // 							checksum		^=	c;
 599:bootSAH_8.c   **** // 						}
 600:bootSAH_8.c   **** // 						else
 601:bootSAH_8.c   **** // 						{
 602:bootSAH_8.c   **** // 							msgParseState	=	ST_START;
 603:bootSAH_8.c   **** // 						}
 604:bootSAH_8.c   **** // 					#endif
 605:bootSAH_8.c   **** 						break;
 490               		.loc 1 605 0
 491 0194 C25E      		subi r28,lo8(-286)
 492 0196 DE4F      		sbci r29,hi8(-286)
 493 0198 9883      		st Y,r25
 494 019a CE51      		subi r28,lo8(286)
 495 019c D140      		sbci r29,hi8(286)
 591:bootSAH_8.c   **** 						checksum		^=	c;
 496               		.loc 1 591 0
 497 019e 82E0      		ldi r24,lo8(2)
 498               		.loc 1 605 0
 499 01a0 00C0      		rjmp .L24
 500               	.LVL42:
 501               	.L148:
 606:bootSAH_8.c   **** 
 607:bootSAH_8.c   **** 					case ST_MSG_SIZE_1:
 608:bootSAH_8.c   **** 						msgLength		=	c<<8;
 502               		.loc 1 608 0
 503 01a2 292F      		mov r18,r25
 504               	.LVL43:
 505 01a4 30E0      		ldi r19,0
 506 01a6 322F      		mov r19,r18
 507 01a8 2227      		clr r18
 508               	.LVL44:
 609:bootSAH_8.c   **** 						msgParseState	=	ST_MSG_SIZE_2;
 610:bootSAH_8.c   **** 						checksum		^=	c;
 509               		.loc 1 610 0
 510 01aa D926      		eor r13,r25
 511               	.LVL45:
 609:bootSAH_8.c   **** 						msgParseState	=	ST_MSG_SIZE_2;
 512               		.loc 1 609 0
 513 01ac 83E0      		ldi r24,lo8(3)
 611:bootSAH_8.c   **** 						break;
 514               		.loc 1 611 0
 515 01ae 00C0      		rjmp .L24
 516               	.LVL46:
 517               	.L27:
 612:bootSAH_8.c   **** 
 613:bootSAH_8.c   **** 					case ST_MSG_SIZE_2:
 614:bootSAH_8.c   **** 						msgLength		|=	c;
 518               		.loc 1 614 0
 519 01b0 292B      		or r18,r25
 520               	.LVL47:
 615:bootSAH_8.c   **** 						msgParseState	=	ST_GET_TOKEN;
 616:bootSAH_8.c   **** 						checksum		^=	c;
 521               		.loc 1 616 0
 522 01b2 D926      		eor r13,r25
 523               	.LVL48:
 615:bootSAH_8.c   **** 						msgParseState	=	ST_GET_TOKEN;
 524               		.loc 1 615 0
 525 01b4 84E0      		ldi r24,lo8(4)
 617:bootSAH_8.c   **** 						break;
 526               		.loc 1 617 0
 527 01b6 00C0      		rjmp .L24
 528               	.LVL49:
 529               	.L33:
 618:bootSAH_8.c   **** 
 619:bootSAH_8.c   **** 					case ST_GET_TOKEN:
 620:bootSAH_8.c   **** 						if ( c == TOKEN )
 530               		.loc 1 620 0
 531 01b8 9E30      		cpi r25,lo8(14)
 532 01ba 01F0      		breq .+2
 533 01bc 00C0      		rjmp .L90
 534               	.LVL50:
 621:bootSAH_8.c   **** 						{
 622:bootSAH_8.c   **** 							msgParseState	=	ST_GET_DATA;
 623:bootSAH_8.c   **** 							checksum		^=	c;
 535               		.loc 1 623 0
 536 01be D926      		eor r13,r25
 537               	.LVL51:
 624:bootSAH_8.c   **** 							ii				=	0;
 538               		.loc 1 624 0
 539 01c0 212C      		mov r2,__zero_reg__
 540 01c2 312C      		mov r3,__zero_reg__
 622:bootSAH_8.c   **** 							checksum		^=	c;
 541               		.loc 1 622 0
 542 01c4 85E0      		ldi r24,lo8(5)
 543 01c6 00C0      		rjmp .L24
 544               	.LVL52:
 545               	.L32:
 625:bootSAH_8.c   **** 						}
 626:bootSAH_8.c   **** 						else
 627:bootSAH_8.c   **** 						{
 628:bootSAH_8.c   **** 							msgParseState	=	ST_START;
 629:bootSAH_8.c   **** 						}
 630:bootSAH_8.c   **** 						break;
 631:bootSAH_8.c   **** 
 632:bootSAH_8.c   **** 					case ST_GET_DATA:
 633:bootSAH_8.c   **** 						msgBuffer[ii++]	=	c;
 546               		.loc 1 633 0
 547 01c8 A101      		movw r20,r2
 548 01ca 4F5F      		subi r20,-1
 549 01cc 5F4F      		sbci r21,-1
 550               	.LVL53:
 551 01ce E1E0      		ldi r30,lo8(1)
 552 01d0 F0E0      		ldi r31,0
 553 01d2 EC0F      		add r30,r28
 554 01d4 FD1F      		adc r31,r29
 555 01d6 E20D      		add r30,r2
 556 01d8 F31D      		adc r31,r3
 557 01da 9083      		st Z,r25
 634:bootSAH_8.c   **** 						checksum		^=	c;
 558               		.loc 1 634 0
 559 01dc D926      		eor r13,r25
 560               	.LVL54:
 635:bootSAH_8.c   **** 						if (ii == msgLength )
 561               		.loc 1 635 0
 562 01de 2417      		cp r18,r20
 563 01e0 3507      		cpc r19,r21
 564 01e2 01F4      		brne .+2
 565 01e4 00C0      		rjmp .L91
 566 01e6 1A01      		movw r2,r20
 567 01e8 00C0      		rjmp .L24
 568               	.LVL55:
 569               	.L34:
 636:bootSAH_8.c   **** 						{
 637:bootSAH_8.c   **** 							msgParseState	=	ST_GET_CHECK;
 638:bootSAH_8.c   **** 						}
 639:bootSAH_8.c   **** 						break;
 640:bootSAH_8.c   **** 
 641:bootSAH_8.c   **** 					case ST_GET_CHECK:
 642:bootSAH_8.c   **** 						if ( c == checksum )
 570               		.loc 1 642 0
 571 01ea 9D11      		cpse r25,r13
 572 01ec 00C0      		rjmp .L90
 573 01ee 00C0      		rjmp .L36
 574               	.L149:
 575               	.LVL56:
 564:bootSAH_8.c   **** 			{
 576               		.loc 1 564 0
 577 01f0 8730      		cpi r24,lo8(7)
 578 01f2 01F0      		breq .+2
 579 01f4 00C0      		rjmp .L24
 580               	.LVL57:
 581               	.L36:
 643:bootSAH_8.c   **** 						{
 644:bootSAH_8.c   **** 							msgParseState	=	ST_PROCESS;
 645:bootSAH_8.c   **** 						}
 646:bootSAH_8.c   **** 						else
 647:bootSAH_8.c   **** 						{
 648:bootSAH_8.c   **** 							msgParseState	=	ST_START;
 649:bootSAH_8.c   **** 						}
 650:bootSAH_8.c   **** 						break;
 651:bootSAH_8.c   **** 				}	//	switch
 652:bootSAH_8.c   **** 			}	//	while(msgParseState)
 653:bootSAH_8.c   **** 
 654:bootSAH_8.c   **** 			/*
 655:bootSAH_8.c   **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 656:bootSAH_8.c   **** 			 */
 657:bootSAH_8.c   **** 
 658:bootSAH_8.c   **** 			switch (msgBuffer[0])
 582               		.loc 1 658 0
 583 01f6 2981      		ldd r18,Y+1
 584 01f8 2331      		cpi r18,lo8(19)
 585 01fa 01F4      		brne .+2
 586 01fc 00C0      		rjmp .L39
 587 01fe 00F4      		brsh .L40
 588 0200 2630      		cpi r18,lo8(6)
 589 0202 01F4      		brne .+2
 590 0204 00C0      		rjmp .L41
 591 0206 00F4      		brsh .L42
 592 0208 2230      		cpi r18,lo8(2)
 593 020a 01F0      		breq .L43
 594 020c 2330      		cpi r18,lo8(3)
 595 020e 01F0      		breq .L44
 596 0210 2130      		cpi r18,lo8(1)
 597 0212 01F0      		breq .+2
 598 0214 00C0      		rjmp .L38
 599               	.LVL58:
 659:bootSAH_8.c   **** 			{
 660:bootSAH_8.c   **** /*
 661:bootSAH_8.c   **** 	#ifndef REMOVE_CMD_SPI_MULTI
 662:bootSAH_8.c   **** 				case CMD_SPI_MULTI:
 663:bootSAH_8.c   **** 					{
 664:bootSAH_8.c   **** 						unsigned char answerByte;
 665:bootSAH_8.c   **** 						unsigned char flag=0;
 666:bootSAH_8.c   **** 
 667:bootSAH_8.c   **** 						if ( msgBuffer[4]== 0x30 )
 668:bootSAH_8.c   **** 						{
 669:bootSAH_8.c   **** 							unsigned char signatureIndex	=	msgBuffer[6];
 670:bootSAH_8.c   **** 
 671:bootSAH_8.c   **** 							if ( signatureIndex == 0 )
 672:bootSAH_8.c   **** 							{
 673:bootSAH_8.c   **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 674:bootSAH_8.c   **** 							}
 675:bootSAH_8.c   **** 							else if ( signatureIndex == 1 )
 676:bootSAH_8.c   **** 							{
 677:bootSAH_8.c   **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 678:bootSAH_8.c   **** 							}
 679:bootSAH_8.c   **** 							else
 680:bootSAH_8.c   **** 							{
 681:bootSAH_8.c   **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 682:bootSAH_8.c   **** 							}
 683:bootSAH_8.c   **** 						}
 684:bootSAH_8.c   **** 						else if ( msgBuffer[4] & 0x50 )
 685:bootSAH_8.c   **** 						{
 686:bootSAH_8.c   **** 						//	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 687:bootSAH_8.c   **** 						//	I cant find the docs that say what these are supposed to be but this was figured out by tr
 688:bootSAH_8.c   **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 689:bootSAH_8.c   **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 690:bootSAH_8.c   **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 691:bootSAH_8.c   **** 							if (msgBuffer[4] == 0x50)
 692:bootSAH_8.c   **** 							{
 693:bootSAH_8.c   **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 694:bootSAH_8.c   **** 							}
 695:bootSAH_8.c   **** 							else if (msgBuffer[4] == 0x58)
 696:bootSAH_8.c   **** 							{
 697:bootSAH_8.c   **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 698:bootSAH_8.c   **** 							}
 699:bootSAH_8.c   **** 							else
 700:bootSAH_8.c   **** 							{
 701:bootSAH_8.c   **** 								answerByte	=	0;
 702:bootSAH_8.c   **** 							}
 703:bootSAH_8.c   **** 						}
 704:bootSAH_8.c   **** 						else
 705:bootSAH_8.c   **** 						{
 706:bootSAH_8.c   **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 707:bootSAH_8.c   **** 						}
 708:bootSAH_8.c   **** 						if ( !flag )
 709:bootSAH_8.c   **** 						{
 710:bootSAH_8.c   **** 							msgLength		=	7;
 711:bootSAH_8.c   **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 712:bootSAH_8.c   **** 							msgBuffer[2]	=	0;
 713:bootSAH_8.c   **** 							msgBuffer[3]	=	msgBuffer[4];
 714:bootSAH_8.c   **** 							msgBuffer[4]	=	0;
 715:bootSAH_8.c   **** 							msgBuffer[5]	=	answerByte;
 716:bootSAH_8.c   **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 717:bootSAH_8.c   **** 						}
 718:bootSAH_8.c   **** 					}
 719:bootSAH_8.c   **** 					break;
 720:bootSAH_8.c   **** 	#endif
 721:bootSAH_8.c   **** */
 722:bootSAH_8.c   **** 				case CMD_SIGN_ON:
 723:bootSAH_8.c   **** 					msgLength		=	11;
 724:bootSAH_8.c   **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 600               		.loc 1 724 0
 601 0216 1A82      		std Y+2,__zero_reg__
 725:bootSAH_8.c   **** 					msgBuffer[2] 	=	8;
 602               		.loc 1 725 0
 603 0218 88E0      		ldi r24,lo8(8)
 604 021a 8B83      		std Y+3,r24
 726:bootSAH_8.c   **** 					msgBuffer[3] 	=	'A';
 605               		.loc 1 726 0
 606 021c 81E4      		ldi r24,lo8(65)
 607 021e 8C83      		std Y+4,r24
 727:bootSAH_8.c   **** 					msgBuffer[4] 	=	'V';
 608               		.loc 1 727 0
 609 0220 86E5      		ldi r24,lo8(86)
 610 0222 8D83      		std Y+5,r24
 728:bootSAH_8.c   **** 					msgBuffer[5] 	=	'R';
 611               		.loc 1 728 0
 612 0224 82E5      		ldi r24,lo8(82)
 613 0226 8E83      		std Y+6,r24
 729:bootSAH_8.c   **** 					msgBuffer[6] 	=	'I';
 614               		.loc 1 729 0
 615 0228 89E4      		ldi r24,lo8(73)
 616 022a 8F83      		std Y+7,r24
 730:bootSAH_8.c   **** 					msgBuffer[7] 	=	'S';
 617               		.loc 1 730 0
 618 022c 83E5      		ldi r24,lo8(83)
 619 022e 8887      		std Y+8,r24
 731:bootSAH_8.c   **** 					msgBuffer[8] 	=	'P';
 620               		.loc 1 731 0
 621 0230 80E5      		ldi r24,lo8(80)
 622 0232 8987      		std Y+9,r24
 732:bootSAH_8.c   **** 					msgBuffer[9] 	=	'_';
 623               		.loc 1 732 0
 624 0234 8FE5      		ldi r24,lo8(95)
 625 0236 8A87      		std Y+10,r24
 733:bootSAH_8.c   **** 					msgBuffer[10]	=	'2';
 626               		.loc 1 733 0
 627 0238 82E3      		ldi r24,lo8(50)
 628 023a 8B87      		std Y+11,r24
 734:bootSAH_8.c   **** 					break;
 629               		.loc 1 734 0
 630 023c C12C      		mov r12,__zero_reg__
 723:bootSAH_8.c   **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 631               		.loc 1 723 0
 632 023e 0BE0      		ldi r16,lo8(11)
 633 0240 10E0      		ldi r17,0
 634               		.loc 1 734 0
 635 0242 00C0      		rjmp .L54
 636               	.LVL59:
 637               	.L42:
 658:bootSAH_8.c   **** 			{
 638               		.loc 1 658 0
 639 0244 2131      		cpi r18,lo8(17)
 640 0246 01F0      		breq .L92
 641 0248 00F0      		brlo .+2
 642 024a 00C0      		rjmp .L47
 643 024c 2031      		cpi r18,lo8(16)
 644 024e 01F0      		breq .L43
 645 0250 00C0      		rjmp .L38
 646               	.L40:
 647 0252 2831      		cpi r18,lo8(24)
 648 0254 01F4      		brne .+2
 649 0256 00C0      		rjmp .L48
 650 0258 00F4      		brsh .L49
 651 025a 2531      		cpi r18,lo8(21)
 652 025c 01F4      		brne .+2
 653 025e 00C0      		rjmp .L39
 654 0260 00F4      		brsh .+2
 655 0262 00C0      		rjmp .L50
 656 0264 2631      		cpi r18,lo8(22)
 657 0266 01F4      		brne .+2
 658 0268 00C0      		rjmp .L50
 659 026a 00C0      		rjmp .L38
 660               	.L49:
 661 026c 2A31      		cpi r18,lo8(26)
 662 026e 01F0      		breq .L51
 663 0270 00F4      		brsh .+2
 664 0272 00C0      		rjmp .L52
 665 0274 2B31      		cpi r18,lo8(27)
 666 0276 01F0      		breq .L53
 667 0278 00C0      		rjmp .L38
 668               	.L43:
 669 027a C12C      		mov r12,__zero_reg__
 670 027c 00C0      		rjmp .L46
 671               	.L44:
 672 027e EA81      		ldd r30,Y+2
 673 0280 E059      		subi r30,lo8(-(112))
 674 0282 E330      		cpi r30,lo8(3)
 675 0284 00F4      		brsh .L93
 676 0286 F0E0      		ldi r31,0
 677 0288 E050      		subi r30,lo8(-(CSWTCH.26))
 678 028a F040      		sbci r31,hi8(-(CSWTCH.26))
 679 028c 8081      		ld r24,Z
 680 028e 00C0      		rjmp .L55
 681               	.L93:
 682               	.LBB70:
 735:bootSAH_8.c   **** 
 736:bootSAH_8.c   **** 				case CMD_GET_PARAMETER:
 737:bootSAH_8.c   **** 					{
 738:bootSAH_8.c   **** 						unsigned char value;
 739:bootSAH_8.c   **** 
 740:bootSAH_8.c   **** 						switch(msgBuffer[1])
 683               		.loc 1 740 0
 684 0290 80E0      		ldi r24,0
 685               	.L55:
 686               	.LVL60:
 741:bootSAH_8.c   **** 						{
 742:bootSAH_8.c   **** 						case PARAM_BUILD_NUMBER_LOW:
 743:bootSAH_8.c   **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 744:bootSAH_8.c   **** 							break;
 745:bootSAH_8.c   **** 						case PARAM_BUILD_NUMBER_HIGH:
 746:bootSAH_8.c   **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 747:bootSAH_8.c   **** 							break;
 748:bootSAH_8.c   **** 						case PARAM_HW_VER:
 749:bootSAH_8.c   **** 							value	=	CONFIG_PARAM_HW_VER;
 750:bootSAH_8.c   **** 							break;
 751:bootSAH_8.c   **** 						case PARAM_SW_MAJOR:
 752:bootSAH_8.c   **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 753:bootSAH_8.c   **** 							break;
 754:bootSAH_8.c   **** 						case PARAM_SW_MINOR:
 755:bootSAH_8.c   **** 							value	=	CONFIG_PARAM_SW_MINOR;
 756:bootSAH_8.c   **** 							break;
 757:bootSAH_8.c   **** 						default:
 758:bootSAH_8.c   **** 							value	=	0;
 759:bootSAH_8.c   **** 							break;
 760:bootSAH_8.c   **** 						}
 761:bootSAH_8.c   **** 						msgLength		=	3;
 762:bootSAH_8.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 687               		.loc 1 762 0
 688 0292 1A82      		std Y+2,__zero_reg__
 763:bootSAH_8.c   **** 						msgBuffer[2]	=	value;
 689               		.loc 1 763 0
 690 0294 8B83      		std Y+3,r24
 691 0296 00C0      		rjmp .L143
 692               	.LVL61:
 693               	.L92:
 694               	.LBE70:
 764:bootSAH_8.c   **** 					}
 765:bootSAH_8.c   **** 					break;
 766:bootSAH_8.c   **** 
 767:bootSAH_8.c   **** 				case CMD_LEAVE_PROGMODE_ISP:
 768:bootSAH_8.c   **** 					isLeave	=	1;
 695               		.loc 1 768 0
 696 0298 CC24      		clr r12
 697 029a C394      		inc r12
 698               	.L46:
 699               	.LVL62:
 769:bootSAH_8.c   **** 					//*	fall thru
 770:bootSAH_8.c   **** 
 771:bootSAH_8.c   **** 				case CMD_SET_PARAMETER:
 772:bootSAH_8.c   **** 				case CMD_ENTER_PROGMODE_ISP:
 773:bootSAH_8.c   **** 					msgLength		=	2;
 774:bootSAH_8.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 700               		.loc 1 774 0
 701 029c 1A82      		std Y+2,__zero_reg__
 702 029e 00C0      		rjmp .L144
 703               	.LVL63:
 704               	.L53:
 705               	.LBB71:
 775:bootSAH_8.c   **** 					break;
 776:bootSAH_8.c   **** 
 777:bootSAH_8.c   **** 				case CMD_READ_SIGNATURE_ISP:
 778:bootSAH_8.c   **** 					{
 779:bootSAH_8.c   **** 						unsigned char signatureIndex	=	msgBuffer[4];
 706               		.loc 1 779 0
 707 02a0 8D81      		ldd r24,Y+5
 708               	.LVL64:
 780:bootSAH_8.c   **** 						unsigned char signature;
 781:bootSAH_8.c   **** 
 782:bootSAH_8.c   **** 						if ( signatureIndex == 0 )
 709               		.loc 1 782 0
 710 02a2 8823      		tst r24
 711 02a4 01F0      		breq .L94
 783:bootSAH_8.c   **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 784:bootSAH_8.c   **** 						else if ( signatureIndex == 1 )
 712               		.loc 1 784 0
 713 02a6 8130      		cpi r24,lo8(1)
 714 02a8 01F4      		brne .L95
 785:bootSAH_8.c   **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 715               		.loc 1 785 0
 716 02aa 88E9      		ldi r24,lo8(-104)
 717               	.LVL65:
 718 02ac 00C0      		rjmp .L147
 719               	.LVL66:
 720               	.L94:
 783:bootSAH_8.c   **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 721               		.loc 1 783 0
 722 02ae 8EE1      		ldi r24,lo8(30)
 723               	.LVL67:
 724 02b0 00C0      		rjmp .L147
 725               	.LVL68:
 726               	.L95:
 786:bootSAH_8.c   **** 						else
 787:bootSAH_8.c   **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 727               		.loc 1 787 0
 728 02b2 81E0      		ldi r24,lo8(1)
 729               	.LVL69:
 730 02b4 00C0      		rjmp .L147
 731               	.LVL70:
 732               	.L51:
 733               	.LBE71:
 788:bootSAH_8.c   **** 
 789:bootSAH_8.c   **** 						msgLength		=	4;
 790:bootSAH_8.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 791:bootSAH_8.c   **** 						msgBuffer[2]	=	signature;
 792:bootSAH_8.c   **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 793:bootSAH_8.c   **** 					}
 794:bootSAH_8.c   **** 					break;
 795:bootSAH_8.c   **** 
 796:bootSAH_8.c   **** 				case CMD_READ_LOCK_ISP:
 797:bootSAH_8.c   **** 					msgLength		=	4;
 798:bootSAH_8.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 734               		.loc 1 798 0
 735 02b6 1A82      		std Y+2,__zero_reg__
 736               	.LBB72:
 799:bootSAH_8.c   **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 737               		.loc 1 799 0
 738 02b8 E1E0      		ldi r30,lo8(1)
 739 02ba F0E0      		ldi r31,0
 740 02bc 89E0      		ldi r24,lo8(9)
 741               	/* #APP */
 742               	 ;  799 "bootSAH_8.c" 1
 743 02be 8093 5700 		sts 87, r24
 744 02c2 8491      		lpm r24, Z
 745               		
 746               	 ;  0 "" 2
 747               	/* #NOAPP */
 748               	.L146:
 749               	.LVL71:
 750               	.LBE72:
 751 02c4 8B83      		std Y+3,r24
 800:bootSAH_8.c   **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 752               		.loc 1 800 0
 753 02c6 1C82      		std Y+4,__zero_reg__
 801:bootSAH_8.c   **** 					break;
 754               		.loc 1 801 0
 755 02c8 C12C      		mov r12,__zero_reg__
 797:bootSAH_8.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 756               		.loc 1 797 0
 757 02ca 04E0      		ldi r16,lo8(4)
 758 02cc 10E0      		ldi r17,0
 759               		.loc 1 801 0
 760 02ce 00C0      		rjmp .L54
 761               	.LVL72:
 762               	.L48:
 763               	.LBB73:
 802:bootSAH_8.c   **** 
 803:bootSAH_8.c   **** 				case CMD_READ_FUSE_ISP:
 804:bootSAH_8.c   **** 					{
 805:bootSAH_8.c   **** 						unsigned char fuseBits;
 806:bootSAH_8.c   **** 
 807:bootSAH_8.c   **** 						if ( msgBuffer[2] == 0x50 )
 764               		.loc 1 807 0
 765 02d0 8B81      		ldd r24,Y+3
 766 02d2 8035      		cpi r24,lo8(80)
 767 02d4 01F4      		brne .L57
 808:bootSAH_8.c   **** 						{
 809:bootSAH_8.c   **** 							if ( msgBuffer[3] == 0x08 )
 768               		.loc 1 809 0
 769 02d6 8C81      		ldd r24,Y+4
 770 02d8 8830      		cpi r24,lo8(8)
 771 02da 01F4      		brne .L58
 772               	.LBB74:
 810:bootSAH_8.c   **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 773               		.loc 1 810 0
 774 02dc 89E0      		ldi r24,lo8(9)
 775 02de E2E0      		ldi r30,lo8(2)
 776 02e0 F0E0      		ldi r31,0
 777 02e2 00C0      		rjmp .L142
 778               	.L58:
 779               	.LBE74:
 780               	.LBB75:
 811:bootSAH_8.c   **** 							else
 812:bootSAH_8.c   **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 781               		.loc 1 812 0
 782 02e4 89E0      		ldi r24,lo8(9)
 783 02e6 E0E0      		ldi r30,0
 784 02e8 F0E0      		ldi r31,0
 785 02ea 00C0      		rjmp .L142
 786               	.L57:
 787               	.LBE75:
 788               	.LBB76:
 813:bootSAH_8.c   **** 						}
 814:bootSAH_8.c   **** 						else
 815:bootSAH_8.c   **** 						{
 816:bootSAH_8.c   **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 789               		.loc 1 816 0
 790 02ec E3E0      		ldi r30,lo8(3)
 791 02ee F0E0      		ldi r31,0
 792 02f0 89E0      		ldi r24,lo8(9)
 793               	.L142:
 794               	/* #APP */
 795               	 ;  816 "bootSAH_8.c" 1
 796 02f2 8093 5700 		sts 87, r24
 797 02f6 8491      		lpm r24, Z
 798               		
 799               	 ;  0 "" 2
 800               	.LVL73:
 801               	/* #NOAPP */
 802               	.L147:
 803               	.LBE76:
 817:bootSAH_8.c   **** 						}
 818:bootSAH_8.c   **** 						msgLength		=	4;
 819:bootSAH_8.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 804               		.loc 1 819 0
 805 02f8 1A82      		std Y+2,__zero_reg__
 806 02fa 00C0      		rjmp .L146
 807               	.LVL74:
 808               	.L52:
 809               	.LBE73:
 810               	.LBB77:
 820:bootSAH_8.c   **** 						msgBuffer[2]	=	fuseBits;
 821:bootSAH_8.c   **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 822:bootSAH_8.c   **** 					}
 823:bootSAH_8.c   **** 					break;
 824:bootSAH_8.c   **** 
 825:bootSAH_8.c   **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 826:bootSAH_8.c   **** 				case CMD_PROGRAM_LOCK_ISP:
 827:bootSAH_8.c   **** 					{
 828:bootSAH_8.c   **** 						unsigned char lockBits	=	msgBuffer[4];
 829:bootSAH_8.c   **** 
 830:bootSAH_8.c   **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 811               		.loc 1 830 0
 812 02fc 8D81      		ldd r24,Y+5
 813               	.LVL75:
 814               	.LBB78:
 831:bootSAH_8.c   **** 						boot_lock_bits_set(lockBits);		// and program it
 815               		.loc 1 831 0
 816 02fe 836C      		ori r24,lo8(-61)
 817               	.LVL76:
 818 0300 99E0      		ldi r25,lo8(9)
 819               	.LVL77:
 820               	/* #APP */
 821               	 ;  831 "bootSAH_8.c" 1
 822 0302 E1E0      		ldi r30, 1
 823 0304 F0E0      		ldi r31, 0
 824 0306 082E      		mov r0, r24
 825 0308 9093 5700 		sts 87, r25
 826 030c E895      		spm
 827               		
 828               	 ;  0 "" 2
 829               	/* #NOAPP */
 830               	.L60:
 831               	.LBE78:
 832:bootSAH_8.c   **** 						boot_spm_busy_wait();
 832               		.loc 1 832 0 discriminator 1
 833 030e 07B6      		in __tmp_reg__,0x37
 834 0310 00FC      		sbrc __tmp_reg__,0
 835 0312 00C0      		rjmp .L60
 836               	.LVL78:
 833:bootSAH_8.c   **** 
 834:bootSAH_8.c   **** 						msgLength		=	3;
 835:bootSAH_8.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 837               		.loc 1 835 0
 838 0314 1A82      		std Y+2,__zero_reg__
 836:bootSAH_8.c   **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 839               		.loc 1 836 0
 840 0316 1B82      		std Y+3,__zero_reg__
 841               	.LVL79:
 842               	.L143:
 843               	.LBE77:
 837:bootSAH_8.c   **** 					}
 838:bootSAH_8.c   **** 					break;
 844               		.loc 1 838 0
 845 0318 C12C      		mov r12,__zero_reg__
 846               	.LBB79:
 834:bootSAH_8.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 847               		.loc 1 834 0
 848 031a 03E0      		ldi r16,lo8(3)
 849 031c 10E0      		ldi r17,0
 850               	.LBE79:
 851               		.loc 1 838 0
 852 031e 00C0      		rjmp .L54
 853               	.LVL80:
 854               	.L47:
 839:bootSAH_8.c   **** 	#endif
 840:bootSAH_8.c   **** 				case CMD_CHIP_ERASE_ISP:
 841:bootSAH_8.c   **** 					fPageAddr		=	0;
 842:bootSAH_8.c   **** 					msgLength		=	2;
 843:bootSAH_8.c   **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 844:bootSAH_8.c   **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 855               		.loc 1 844 0
 856 0320 80EC      		ldi r24,lo8(-64)
 857 0322 8A83      		std Y+2,r24
 845:bootSAH_8.c   **** 					break;
 858               		.loc 1 845 0
 859 0324 C12C      		mov r12,__zero_reg__
 842:bootSAH_8.c   **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 860               		.loc 1 842 0
 861 0326 02E0      		ldi r16,lo8(2)
 862 0328 10E0      		ldi r17,0
 841:bootSAH_8.c   **** 					msgLength		=	2;
 863               		.loc 1 841 0
 864 032a 812C      		mov r8,__zero_reg__
 865 032c 912C      		mov r9,__zero_reg__
 866 032e 5401      		movw r10,r8
 867               		.loc 1 845 0
 868 0330 00C0      		rjmp .L54
 869               	.LVL81:
 870               	.L41:
 871 0332 6A81      		ldd r22,Y+2
 872 0334 7B81      		ldd r23,Y+3
 873 0336 8C81      		ldd r24,Y+4
 874 0338 9D81      		ldd r25,Y+5
 875 033a 0E94 0000 		call __bswapsi2
 846:bootSAH_8.c   **** 
 847:bootSAH_8.c   **** 				case CMD_LOAD_ADDRESS:
 848:bootSAH_8.c   **** 	//#if defined(RAMPZ)
 849:bootSAH_8.c   **** 					fTmpPgAddr	=	( ((uint32_t)(msgBuffer[1])<<24)|((uint32_t)(msgBuffer[2])<<16)|((uint32_t)(msgBu
 876               		.loc 1 849 0
 877 033e 2B01      		movw r4,r22
 878 0340 3C01      		movw r6,r24
 879               	.LVL82:
 880 0342 440C      		lsl r4
 881 0344 551C      		rol r5
 882 0346 661C      		rol r6
 883 0348 771C      		rol r7
 884               	.LVL83:
 850:bootSAH_8.c   **** 	//#else
 851:bootSAH_8.c   **** 				//	address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 852:bootSAH_8.c   **** 	//#endif
 853:bootSAH_8.c   **** 			
 854:bootSAH_8.c   **** 					msgLength		=	2;
 855:bootSAH_8.c   **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 885               		.loc 1 855 0
 886 034a 1A82      		std Y+2,__zero_reg__
 887 034c 00C0      		rjmp .L145
 888               	.LVL84:
 889               	.L39:
 890 034e EA80      		ldd r14,Y+2
 891 0350 FB80      		ldd r15,Y+3
 892 0352 FE24      		eor r15,r14
 893 0354 EF24      		eor r14,r15
 894 0356 FE24      		eor r15,r14
 895               	.LVL85:
 896               	.LBB80:
 856:bootSAH_8.c   **** 					break;
 857:bootSAH_8.c   **** 
 858:bootSAH_8.c   **** 				case CMD_PROGRAM_FLASH_ISP:
 859:bootSAH_8.c   **** 				case CMD_PROGRAM_EEPROM_ISP:
 860:bootSAH_8.c   **** 					{
 861:bootSAH_8.c   **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 862:bootSAH_8.c   **** 						unsigned char	*p	=	msgBuffer+10;
 863:bootSAH_8.c   **** 						unsigned int	data;
 864:bootSAH_8.c   **** 						unsigned char	highByte, lowByte;
 865:bootSAH_8.c   **** 						uint32_t		tempaddress	=	fTmpPgAddr;
 866:bootSAH_8.c   **** 
 867:bootSAH_8.c   **** 
 868:bootSAH_8.c   **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 897               		.loc 1 868 0
 898 0358 2331      		cpi r18,lo8(19)
 899 035a 01F0      		breq .+2
 900 035c 00C0      		rjmp .L61
 869:bootSAH_8.c   **** 						{
 870:bootSAH_8.c   **** 							// erase only main section (bootloader protection)
 871:bootSAH_8.c   **** 							if (fPageAddr < APP_END )
 901               		.loc 1 871 0
 902 035e 8114      		cp r8,__zero_reg__
 903 0360 F0EC      		ldi r31,-64
 904 0362 9F06      		cpc r9,r31
 905 0364 F3E0      		ldi r31,3
 906 0366 AF06      		cpc r10,r31
 907 0368 B104      		cpc r11,__zero_reg__
 908 036a 00F4      		brsh .L62
 909               	.L111:
 872:bootSAH_8.c   **** 							{
 873:bootSAH_8.c   **** 								boot_page_erase_safe(fPageAddr);	// Perform page erase
 910               		.loc 1 873 0 discriminator 1
 911 036c 07B6      		in __tmp_reg__,0x37
 912 036e 00FC      		sbrc __tmp_reg__,0
 913 0370 00C0      		rjmp .L111
 914               	.L64:
 915               		.loc 1 873 0 is_stmt 0 discriminator 3
 916 0372 F999      		sbic 0x1f,1
 917 0374 00C0      		rjmp .L64
 918               		.loc 1 873 0 discriminator 4
 919 0376 23E0      		ldi r18,lo8(3)
 920               	/* #APP */
 921               	 ;  873 "bootSAH_8.c" 1
 922 0378 F401      		movw r30, r8
 923 037a A092 5B00 		sts  91, r10
 924 037e 2093 5700 		sts 87, r18
 925 0382 E895      		spm
 926               		
 927               	 ;  0 "" 2
 928               	/* #NOAPP */
 929               	.L65:
 874:bootSAH_8.c   **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 930               		.loc 1 874 0 is_stmt 1 discriminator 1
 931 0384 07B6      		in __tmp_reg__,0x37
 932 0386 00FC      		sbrc __tmp_reg__,0
 933 0388 00C0      		rjmp .L65
 875:bootSAH_8.c   **** 								fPageAddr += SPM_PAGESIZE;	// point to next page to be erase
 934               		.loc 1 875 0
 935 038a 4FEF      		ldi r20,-1
 936 038c 941A      		sub r9,r20
 937 038e A40A      		sbc r10,r20
 938 0390 B40A      		sbc r11,r20
 939               	.LVL86:
 940               	.L62:
 941 0392 8B85      		ldd r24,Y+11
 942 0394 DE01      		movw r26,r28
 943 0396 1196      		adiw r26,1
 944               	.LBE80:
 945               	.LBB82:
 787:bootSAH_8.c   **** 
 946               		.loc 1 787 0
 947 0398 9301      		movw r18,r6
 948 039a 8201      		movw r16,r4
 949               	.LVL87:
 950               	.L69:
 951               	.LBE82:
 952               	.LBB83:
 876:bootSAH_8.c   **** 							}
 877:bootSAH_8.c   **** 
 878:bootSAH_8.c   **** 							/* Write FLASH */
 879:bootSAH_8.c   **** 							do {
 880:bootSAH_8.c   **** 								lowByte		=	*p++;
 881:bootSAH_8.c   **** 								highByte 	=	*p++;
 882:bootSAH_8.c   **** 
 883:bootSAH_8.c   **** 								data		=	(highByte << 8) | lowByte;
 953               		.loc 1 883 0
 954 039c 1B96      		adiw r26,11
 955 039e 4C91      		ld r20,X
 956 03a0 1B97      		sbiw r26,11
 957 03a2 90E0      		ldi r25,0
 958 03a4 942B      		or r25,r20
 959               	.LVL88:
 960               	.L66:
 884:bootSAH_8.c   **** 								boot_page_fill_safe(fTmpPgAddr,data);
 961               		.loc 1 884 0 discriminator 1
 962 03a6 07B6      		in __tmp_reg__,0x37
 963 03a8 00FC      		sbrc __tmp_reg__,0
 964 03aa 00C0      		rjmp .L66
 965               	.L67:
 966               		.loc 1 884 0 is_stmt 0 discriminator 3
 967 03ac F999      		sbic 0x1f,1
 968 03ae 00C0      		rjmp .L67
 969               		.loc 1 884 0 discriminator 4
 970 03b0 41E0      		ldi r20,lo8(1)
 971               	/* #APP */
 972               	 ;  884 "bootSAH_8.c" 1
 973 03b2 0C01      		movw  r0, r24
 974 03b4 F801      		movw r30, r16
 975 03b6 2093 5B00 		sts 91, r18
 976 03ba 4093 5700 		sts 87, r20
 977 03be E895      		spm
 978 03c0 1124      		clr  r1
 979               		
 980               	 ;  0 "" 2
 885:bootSAH_8.c   **** 
 886:bootSAH_8.c   **** 								fTmpPgAddr	=	fTmpPgAddr + 2;	// Select next word in memory
 981               		.loc 1 886 0 is_stmt 1 discriminator 4
 982               	/* #NOAPP */
 983 03c2 0E5F      		subi r16,-2
 984 03c4 1F4F      		sbci r17,-1
 985 03c6 2F4F      		sbci r18,-1
 986 03c8 3F4F      		sbci r19,-1
 987               	.LVL89:
 887:bootSAH_8.c   **** 								size	-=	2;				// Reduce number of bytes to write by two
 988               		.loc 1 887 0 discriminator 4
 989 03ca 82E0      		ldi r24,2
 990 03cc E81A      		sub r14,r24
 991 03ce F108      		sbc r15,__zero_reg__
 992               	.LVL90:
 993 03d0 1296      		adiw r26,2
 994               	.LVL91:
 888:bootSAH_8.c   **** 							} while (size);					// Loop until all bytes written
 995               		.loc 1 888 0 discriminator 4
 996 03d2 E114      		cp r14,__zero_reg__
 997 03d4 F104      		cpc r15,__zero_reg__
 998 03d6 01F0      		breq .L68
 881:bootSAH_8.c   **** 
 999               		.loc 1 881 0
 1000 03d8 1A96      		adiw r26,10
 1001 03da 8C91      		ld r24,X
 1002 03dc 1A97      		sbiw r26,10
 1003 03de 00C0      		rjmp .L69
 1004               	.L68:
 889:bootSAH_8.c   **** 
 890:bootSAH_8.c   **** 							boot_page_write_safe(tempaddress);
 1005               		.loc 1 890 0 discriminator 1
 1006 03e0 07B6      		in __tmp_reg__,0x37
 1007 03e2 00FC      		sbrc __tmp_reg__,0
 1008 03e4 00C0      		rjmp .L68
 1009               	.L70:
 1010               		.loc 1 890 0 is_stmt 0 discriminator 3
 1011 03e6 F999      		sbic 0x1f,1
 1012 03e8 00C0      		rjmp .L70
 1013               		.loc 1 890 0 discriminator 4
 1014 03ea 95E0      		ldi r25,lo8(5)
 1015               	/* #APP */
 1016               	 ;  890 "bootSAH_8.c" 1
 1017 03ec F201      		movw r30, r4
 1018 03ee 6092 5B00 		sts 91, r6
 1019 03f2 9093 5700 		sts 87, r25
 1020 03f6 E895      		spm
 1021               		
 1022               	 ;  0 "" 2
 1023               	/* #NOAPP */
 1024               	.L71:
 891:bootSAH_8.c   **** 							boot_spm_busy_wait();
 1025               		.loc 1 891 0 is_stmt 1 discriminator 1
 1026 03f8 07B6      		in __tmp_reg__,0x37
 1027 03fa 00FC      		sbrc __tmp_reg__,0
 1028 03fc 00C0      		rjmp .L71
 1029               	.L72:
 892:bootSAH_8.c   **** 							boot_rww_enable_safe();				// Re-enable the RWW section
 1030               		.loc 1 892 0 discriminator 1
 1031 03fe 07B6      		in __tmp_reg__,0x37
 1032 0400 00FC      		sbrc __tmp_reg__,0
 1033 0402 00C0      		rjmp .L72
 1034               	.L73:
 1035               		.loc 1 892 0 is_stmt 0 discriminator 3
 1036 0404 F999      		sbic 0x1f,1
 1037 0406 00C0      		rjmp .L73
 1038               		.loc 1 892 0 discriminator 4
 1039 0408 81E1      		ldi r24,lo8(17)
 1040               	/* #APP */
 1041               	 ;  892 "bootSAH_8.c" 1
 1042 040a 8093 5700 		sts 87, r24
 1043 040e E895      		spm
 1044               		
 1045               	 ;  0 "" 2
 1046               	/* #NOAPP */
 1047 0410 00C0      		rjmp .L74
 1048               	.LVL92:
 1049               	.L61:
 1050               	.LBB81:
 893:bootSAH_8.c   **** 						}
 894:bootSAH_8.c   **** 						else
 895:bootSAH_8.c   **** 						{
 896:bootSAH_8.c   **** 							//*	issue 543, this should work, It has not been tested.
 897:bootSAH_8.c   **** 							uint16_t ii = fTmpPgAddr >> 1;
 1051               		.loc 1 897 0 is_stmt 1
 1052 0412 D301      		movw r26,r6
 1053 0414 C201      		movw r24,r4
 1054 0416 B695      		lsr r27
 1055 0418 A795      		ror r26
 1056 041a 9795      		ror r25
 1057 041c 8795      		ror r24
 1058 041e 6C01      		movw r12,r24
 1059               	.LVL93:
 1060 0420 FE01      		movw r30,r28
 1061 0422 3B96      		adiw r30,11
 1062 0424 C15E      		subi r28,lo8(-287)
 1063 0426 DE4F      		sbci r29,hi8(-287)
 1064 0428 F983      		std Y+1,r31
 1065 042a E883      		st Y,r30
 1066 042c CF51      		subi r28,lo8(287)
 1067 042e D140      		sbci r29,hi8(287)
 898:bootSAH_8.c   **** 							/* write EEPROM */
 899:bootSAH_8.c   **** 							while (size) {
 1068               		.loc 1 899 0
 1069 0430 00E0      		ldi r16,0
 1070 0432 10E0      		ldi r17,0
 1071               	.LVL94:
 1072               	.L75:
 1073 0434 0E15      		cp r16,r14
 1074 0436 1F05      		cpc r17,r15
 1075 0438 01F0      		breq .L150
 900:bootSAH_8.c   **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 1076               		.loc 1 900 0
 1077 043a C15E      		subi r28,lo8(-287)
 1078 043c DE4F      		sbci r29,hi8(-287)
 1079 043e E881      		ld r30,Y
 1080 0440 F981      		ldd r31,Y+1
 1081 0442 CF51      		subi r28,lo8(287)
 1082 0444 D140      		sbci r29,hi8(287)
 1083 0446 6191      		ld r22,Z+
 1084 0448 C15E      		subi r28,lo8(-287)
 1085 044a DE4F      		sbci r29,hi8(-287)
 1086 044c F983      		std Y+1,r31
 1087 044e E883      		st Y,r30
 1088 0450 CF51      		subi r28,lo8(287)
 1089 0452 D140      		sbci r29,hi8(287)
 1090 0454 C801      		movw r24,r16
 1091 0456 8C0D      		add r24,r12
 1092 0458 9D1D      		adc r25,r13
 1093 045a 0E94 0000 		call eeprom_write_byte
 1094               	.LVL95:
 1095 045e 0F5F      		subi r16,-1
 1096 0460 1F4F      		sbci r17,-1
 1097               	.LVL96:
 1098 0462 00C0      		rjmp .L75
 1099               	.L150:
 1100 0464 20E0      		ldi r18,0
 1101 0466 30E0      		ldi r19,0
 1102 0468 000F      		lsl r16
 1103 046a 111F      		rol r17
 1104 046c 221F      		rol r18
 1105 046e 331F      		rol r19
 1106               	.LVL97:
 1107 0470 040D      		add r16,r4
 1108 0472 151D      		adc r17,r5
 1109 0474 261D      		adc r18,r6
 1110 0476 371D      		adc r19,r7
 1111               	.L74:
 1112               	.LVL98:
 1113               	.LBE81:
 901:bootSAH_8.c   **** 								fTmpPgAddr+=2;						// Select next EEPROM byte
 902:bootSAH_8.c   **** 								ii++;
 903:bootSAH_8.c   **** 								size--;
 904:bootSAH_8.c   **** 							}
 905:bootSAH_8.c   **** 						}
 906:bootSAH_8.c   **** 						msgLength		=	2;
 907:bootSAH_8.c   **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 1114               		.loc 1 907 0
 1115 0478 1A82      		std Y+2,__zero_reg__
 1116               	.LBE83:
 908:bootSAH_8.c   **** 					}
 909:bootSAH_8.c   **** 					break;
 1117               		.loc 1 909 0
 1118 047a 2801      		movw r4,r16
 1119 047c 3901      		movw r6,r18
 1120               	.LVL99:
 1121 047e 00C0      		rjmp .L145
 1122               	.LVL100:
 1123               	.L50:
 1124 0480 8A81      		ldd r24,Y+2
 1125 0482 9B81      		ldd r25,Y+3
 1126 0484 9827      		eor r25,r24
 1127               	.LVL101:
 1128 0486 8927      		eor r24,r25
 1129 0488 9827      		eor r25,r24
 1130               	.LVL102:
 1131               	.LBB84:
 910:bootSAH_8.c   **** 
 911:bootSAH_8.c   **** 				case CMD_READ_FLASH_ISP:
 912:bootSAH_8.c   **** 				case CMD_READ_EEPROM_ISP:
 913:bootSAH_8.c   **** 					{
 914:bootSAH_8.c   **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 915:bootSAH_8.c   **** 						unsigned char	*p		=	msgBuffer+1;
 916:bootSAH_8.c   **** 						msgLength				=	size+3;
 1132               		.loc 1 916 0
 1133 048a 8C01      		movw r16,r24
 1134 048c 0D5F      		subi r16,-3
 1135 048e 1F4F      		sbci r17,-1
 1136               	.LVL103:
 917:bootSAH_8.c   **** 
 918:bootSAH_8.c   **** 						*p++	=	STATUS_CMD_OK;
 1137               		.loc 1 918 0
 1138 0490 1A82      		std Y+2,__zero_reg__
 919:bootSAH_8.c   **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 1139               		.loc 1 919 0
 1140 0492 2431      		cpi r18,lo8(20)
 1141 0494 01F4      		brne .L77
 1142 0496 DE01      		movw r26,r28
 1143 0498 1196      		adiw r26,1
 1144               	.LVL104:
 1145               	.L78:
 1146               	.LBB85:
 1147               	.LBB86:
 920:bootSAH_8.c   **** 						{
 921:bootSAH_8.c   **** 							unsigned int data;
 922:bootSAH_8.c   **** 
 923:bootSAH_8.c   **** 							// Read FLASH
 924:bootSAH_8.c   **** 							do {
 925:bootSAH_8.c   **** 						//#if defined(RAMPZ)
 926:bootSAH_8.c   **** 						#if (FLASHEND > 0x10000)
 927:bootSAH_8.c   **** 								data	=	pgm_read_word_far(fTmpPgAddr);
 1148               		.loc 1 927 0 discriminator 1
 1149               	/* #APP */
 1150               	 ;  927 "bootSAH_8.c" 1
 1151 049a 6BBE      		out 59, r6
 1152 049c F201      		movw r30, r4
 1153 049e 2791      		elpm r18, Z+
 1154 04a0 3691      		elpm r19, Z
 1155               		
 1156               	 ;  0 "" 2
 1157               	.LVL105:
 1158               	/* #NOAPP */
 1159               	.LBE86:
 928:bootSAH_8.c   **** 						#else
 929:bootSAH_8.c   **** 								data	=	pgm_read_word_near(fTmpPgAddr);
 930:bootSAH_8.c   **** 						#endif
 931:bootSAH_8.c   **** 								*p++	=	(unsigned char)data;		//LSB
 1160               		.loc 1 931 0 discriminator 1
 1161 04a2 1296      		adiw r26,2
 1162 04a4 2C93      		st X,r18
 1163 04a6 1297      		sbiw r26,2
 1164 04a8 FD01      		movw r30,r26
 1165 04aa 3496      		adiw r30,4
 1166               	.LVL106:
 932:bootSAH_8.c   **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 1167               		.loc 1 932 0 discriminator 1
 1168 04ac 1396      		adiw r26,3
 1169 04ae 3C93      		st X,r19
 1170 04b0 1397      		sbiw r26,3
 933:bootSAH_8.c   **** 								fTmpPgAddr	+=	2;							// Select next word in memory
 1171               		.loc 1 933 0 discriminator 1
 1172 04b2 22E0      		ldi r18,2
 1173 04b4 420E      		add r4,r18
 1174 04b6 511C      		adc r5,__zero_reg__
 1175 04b8 611C      		adc r6,__zero_reg__
 1176 04ba 711C      		adc r7,__zero_reg__
 1177               	.LVL107:
 934:bootSAH_8.c   **** 								size	-=	2;
 1178               		.loc 1 934 0 discriminator 1
 1179 04bc 0297      		sbiw r24,2
 1180               	.LVL108:
 1181 04be 1296      		adiw r26,2
 935:bootSAH_8.c   **** 							}while (size);
 1182               		.loc 1 935 0 discriminator 1
 1183 04c0 0097      		sbiw r24,0
 1184 04c2 01F4      		brne .L78
 1185 04c4 00C0      		rjmp .L79
 1186               	.LVL109:
 1187               	.L77:
 1188 04c6 FE01      		movw r30,r28
 1189 04c8 3196      		adiw r30,1
 1190 04ca 9F01      		movw r18,r30
 1191 04cc 280F      		add r18,r24
 1192 04ce 391F      		adc r19,r25
 1193               	.LBE85:
 919:bootSAH_8.c   **** 						{
 1194               		.loc 1 919 0 discriminator 1
 1195 04d0 B301      		movw r22,r6
 1196 04d2 A201      		movw r20,r4
 1197               	.LVL110:
 1198               	.L80:
 936:bootSAH_8.c   **** 						}
 937:bootSAH_8.c   **** 						else
 938:bootSAH_8.c   **** 						{
 939:bootSAH_8.c   **** 							/* Read EEPROM */
 940:bootSAH_8.c   **** 							do {
 941:bootSAH_8.c   **** 								EEARL	=	fTmpPgAddr;			// Setup EEPROM address
 1199               		.loc 1 941 0 discriminator 1
 1200 04d4 41BD      		out 0x21,r20
 942:bootSAH_8.c   **** 								EEARH	=	((fTmpPgAddr >> 8));
 1201               		.loc 1 942 0 discriminator 1
 1202 04d6 C52E      		mov r12,r21
 1203 04d8 D62E      		mov r13,r22
 1204 04da E72E      		mov r14,r23
 1205 04dc FF24      		clr r15
 1206 04de C2BC      		out 0x22,r12
 943:bootSAH_8.c   **** 								fTmpPgAddr++;					// Select next EEPROM byte
 1207               		.loc 1 943 0 discriminator 1
 1208 04e0 4F5F      		subi r20,-1
 1209 04e2 5F4F      		sbci r21,-1
 1210 04e4 6F4F      		sbci r22,-1
 1211 04e6 7F4F      		sbci r23,-1
 1212               	.LVL111:
 944:bootSAH_8.c   **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 1213               		.loc 1 944 0 discriminator 1
 1214 04e8 F89A      		sbi 0x1f,0
 1215               	.LVL112:
 945:bootSAH_8.c   **** 								*p++	=	EEDR;				// Send EEPROM data
 1216               		.loc 1 945 0 discriminator 1
 1217 04ea A0B5      		in r26,0x20
 1218 04ec A283      		std Z+2,r26
 1219 04ee 3196      		adiw r30,1
 1220               	.LVL113:
 946:bootSAH_8.c   **** 								size--;
 947:bootSAH_8.c   **** 							} while (size);
 1221               		.loc 1 947 0 discriminator 1
 1222 04f0 2E17      		cp r18,r30
 1223 04f2 3F07      		cpc r19,r31
 1224 04f4 01F4      		brne .L80
 1225 04f6 AC01      		movw r20,r24
 1226               	.LVL114:
 1227 04f8 4150      		subi r20,1
 1228 04fa 5109      		sbc r21,__zero_reg__
 1229 04fc 60E0      		ldi r22,0
 1230 04fe 70E0      		ldi r23,0
 1231 0500 4F5F      		subi r20,-1
 1232 0502 5F4F      		sbci r21,-1
 1233 0504 6F4F      		sbci r22,-1
 1234 0506 7F4F      		sbci r23,-1
 1235 0508 440E      		add r4,r20
 1236 050a 551E      		adc r5,r21
 1237 050c 661E      		adc r6,r22
 1238 050e 771E      		adc r7,r23
 1239 0510 E3E0      		ldi r30,lo8(3)
 1240 0512 F0E0      		ldi r31,0
 1241               	.LVL115:
 1242 0514 EC0F      		add r30,r28
 1243 0516 FD1F      		adc r31,r29
 1244 0518 E80F      		add r30,r24
 1245 051a F91F      		adc r31,r25
 1246               	.L79:
 1247               	.LVL116:
 948:bootSAH_8.c   **** 						}
 949:bootSAH_8.c   **** 						*p++	=	STATUS_CMD_OK;
 1248               		.loc 1 949 0
 1249 051c 1082      		st Z,__zero_reg__
 1250               	.LBE84:
 950:bootSAH_8.c   **** 					}
 951:bootSAH_8.c   **** 					break;
 1251               		.loc 1 951 0
 1252 051e C12C      		mov r12,__zero_reg__
 1253 0520 00C0      		rjmp .L54
 1254               	.LVL117:
 1255               	.L38:
 952:bootSAH_8.c   **** 
 953:bootSAH_8.c   **** 				default:
 954:bootSAH_8.c   **** 					msgLength		=	2;
 955:bootSAH_8.c   **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 1256               		.loc 1 955 0
 1257 0522 80EC      		ldi r24,lo8(-64)
 1258 0524 8A83      		std Y+2,r24
 1259               	.LVL118:
 1260               	.L145:
 956:bootSAH_8.c   **** 					break;
 1261               		.loc 1 956 0
 1262 0526 C12C      		mov r12,__zero_reg__
 1263               	.LVL119:
 1264               	.L144:
 954:bootSAH_8.c   **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 1265               		.loc 1 954 0
 1266 0528 02E0      		ldi r16,lo8(2)
 1267 052a 10E0      		ldi r17,0
 1268               	.LVL120:
 1269               	.L54:
 957:bootSAH_8.c   **** 			}
 958:bootSAH_8.c   **** 
 959:bootSAH_8.c   **** 			/*
 960:bootSAH_8.c   **** 			 * Now send answer message back
 961:bootSAH_8.c   **** 			 */
 962:bootSAH_8.c   **** 			sendchar(MESSAGE_START);
 1270               		.loc 1 962 0
 1271 052c 8BE1      		ldi r24,lo8(27)
 1272 052e 0E94 0000 		call sendchar
 1273               	.LVL121:
 963:bootSAH_8.c   **** 			checksum	=	MESSAGE_START^0;
 964:bootSAH_8.c   **** 
 965:bootSAH_8.c   **** 			sendchar(seqNum);
 1274               		.loc 1 965 0
 1275 0532 C25E      		subi r28,lo8(-286)
 1276 0534 DE4F      		sbci r29,hi8(-286)
 1277 0536 8881      		ld r24,Y
 1278 0538 CE51      		subi r28,lo8(286)
 1279 053a D140      		sbci r29,hi8(286)
 1280 053c 0E94 0000 		call sendchar
 1281               	.LVL122:
 966:bootSAH_8.c   **** 			checksum	^=	seqNum;
 967:bootSAH_8.c   **** 
 968:bootSAH_8.c   **** 			c			=	((msgLength>>8)&0xFF);
 969:bootSAH_8.c   **** 			sendchar(c);
 1282               		.loc 1 969 0
 1283 0540 812F      		mov r24,r17
 1284 0542 0E94 0000 		call sendchar
 1285               	.LVL123:
 970:bootSAH_8.c   **** 			checksum	^=	c;
 971:bootSAH_8.c   **** 
 972:bootSAH_8.c   **** 			c			=	msgLength&0x00FF;
 973:bootSAH_8.c   **** 			sendchar(c);
 1286               		.loc 1 973 0
 1287 0546 802F      		mov r24,r16
 1288 0548 0E94 0000 		call sendchar
 1289               	.LVL124:
 1290 054c 85E1      		ldi r24,lo8(21)
 1291 054e C25E      		subi r28,lo8(-286)
 1292 0550 DE4F      		sbci r29,hi8(-286)
 1293 0552 D880      		ld r13,Y
 1294 0554 CE51      		subi r28,lo8(286)
 1295 0556 D140      		sbci r29,hi8(286)
 1296 0558 D826      		eor r13,r24
 1297 055a D026      		eor r13,r16
 1298               	.LVL125:
 974:bootSAH_8.c   **** 			checksum ^= c;
 975:bootSAH_8.c   **** 
 976:bootSAH_8.c   **** 			sendchar(TOKEN);
 1299               		.loc 1 976 0
 1300 055c 8EE0      		ldi r24,lo8(14)
 1301 055e 0E94 0000 		call sendchar
 1302               	.LVL126:
 977:bootSAH_8.c   **** 			checksum ^= TOKEN;
 1303               		.loc 1 977 0
 1304 0562 D126      		eor r13,r17
 1305               	.LVL127:
 1306 0564 CE01      		movw r24,r28
 1307 0566 0196      		adiw r24,1
 1308 0568 7C01      		movw r14,r24
 1309 056a 080F      		add r16,r24
 1310 056c 191F      		adc r17,r25
 1311               	.LVL128:
 1312               	.L81:
 978:bootSAH_8.c   **** 
 979:bootSAH_8.c   **** 			p	=	msgBuffer;
 980:bootSAH_8.c   **** 			while ( msgLength )
 1313               		.loc 1 980 0
 1314 056e 0E15      		cp r16,r14
 1315 0570 1F05      		cpc r17,r15
 1316 0572 01F0      		breq .L151
 1317               	.LVL129:
 981:bootSAH_8.c   **** 			{
 982:bootSAH_8.c   **** 				c	=	*p++;
 1318               		.loc 1 982 0
 1319 0574 F701      		movw r30,r14
 1320 0576 2191      		ld r18,Z+
 1321               	.LVL130:
 1322 0578 7F01      		movw r14,r30
 1323 057a C15E      		subi r28,lo8(-287)
 1324 057c DE4F      		sbci r29,hi8(-287)
 1325 057e 2883      		st Y,r18
 1326 0580 CF51      		subi r28,lo8(287)
 1327 0582 D140      		sbci r29,hi8(287)
 1328               	.LVL131:
 983:bootSAH_8.c   **** 				sendchar(c);
 1329               		.loc 1 983 0
 1330 0584 822F      		mov r24,r18
 1331 0586 0E94 0000 		call sendchar
 1332               	.LVL132:
 984:bootSAH_8.c   **** 				checksum ^=c;
 1333               		.loc 1 984 0
 1334 058a C15E      		subi r28,lo8(-287)
 1335 058c DE4F      		sbci r29,hi8(-287)
 1336 058e 4881      		ld r20,Y
 1337 0590 CF51      		subi r28,lo8(287)
 1338 0592 D140      		sbci r29,hi8(287)
 1339 0594 D426      		eor r13,r20
 1340               	.LVL133:
 1341 0596 00C0      		rjmp .L81
 1342               	.LVL134:
 1343               	.L151:
 985:bootSAH_8.c   **** 				msgLength--;
 986:bootSAH_8.c   **** 			}
 987:bootSAH_8.c   **** 			sendchar(checksum);
 1344               		.loc 1 987 0
 1345 0598 8D2D      		mov r24,r13
 1346 059a 0E94 0000 		call sendchar
 1347               	.LVL135:
 988:bootSAH_8.c   **** 			seqNum++;
 1348               		.loc 1 988 0
 1349 059e C25E      		subi r28,lo8(-286)
 1350 05a0 DE4F      		sbci r29,hi8(-286)
 1351 05a2 8881      		ld r24,Y
 1352 05a4 CE51      		subi r28,lo8(286)
 1353 05a6 D140      		sbci r29,hi8(286)
 1354 05a8 8F5F      		subi r24,lo8(-(1))
 1355 05aa C25E      		subi r28,lo8(-286)
 1356 05ac DE4F      		sbci r29,hi8(-286)
 1357 05ae 8883      		st Y,r24
 1358 05b0 CE51      		subi r28,lo8(286)
 1359 05b2 D140      		sbci r29,hi8(286)
 1360               	.LVL136:
 989:bootSAH_8.c   **** 	
 990:bootSAH_8.c   **** 		#ifndef REMOVE_BOOTLOADER_LED
 991:bootSAH_8.c   **** 			//*	<MLS>	toggle the LED
 992:bootSAH_8.c   **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
 1361               		.loc 1 992 0
 1362 05b4 95B1      		in r25,0x5
 1363 05b6 80E4      		ldi r24,lo8(64)
 1364               	.LVL137:
 1365 05b8 8927      		eor r24,r25
 1366 05ba 85B9      		out 0x5,r24
 1367               	.LVL138:
 1368 05bc 10E0      		ldi r17,0
 558:bootSAH_8.c   **** 		{
 1369               		.loc 1 558 0
 1370 05be CC20      		tst r12
 1371 05c0 01F4      		brne .+2
 1372 05c2 00C0      		rjmp .L83
 1373               	.LVL139:
 1374               	.L20:
 993:bootSAH_8.c   **** 		#endif
 994:bootSAH_8.c   **** 
 995:bootSAH_8.c   **** 		}
 996:bootSAH_8.c   **** 	}
 997:bootSAH_8.c   **** 
 998:bootSAH_8.c   **** //#ifdef _DEBUG_WITH_LEDS_
 999:bootSAH_8.c   **** 	//	this is for debugging it can be removed
1000:bootSAH_8.c   **** // 	for (ii=0; ii<10; ii++)
1001:bootSAH_8.c   **** // 	{
1002:bootSAH_8.c   **** // 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1003:bootSAH_8.c   **** // 		delay_ms(200);
1004:bootSAH_8.c   **** // 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1005:bootSAH_8.c   **** // 		delay_ms(200);
1006:bootSAH_8.c   **** // 	}
1007:bootSAH_8.c   **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1008:bootSAH_8.c   **** //#endif
1009:bootSAH_8.c   **** 
1010:bootSAH_8.c   **** #ifdef _DEBUG_SERIAL_
1011:bootSAH_8.c   **** 	sendchar('b');
 1375               		.loc 1 1011 0
 1376 05c4 82E6      		ldi r24,lo8(98)
 1377 05c6 0E94 0000 		call sendchar
 1378               	.LVL140:
1012:bootSAH_8.c   **** 	sendchar('y');
 1379               		.loc 1 1012 0
 1380 05ca 89E7      		ldi r24,lo8(121)
 1381 05cc 0E94 0000 		call sendchar
 1382               	.LVL141:
1013:bootSAH_8.c   **** 	sendchar(' ');
 1383               		.loc 1 1013 0
 1384 05d0 80E2      		ldi r24,lo8(32)
 1385 05d2 0E94 0000 		call sendchar
 1386               	.LVL142:
1014:bootSAH_8.c   **** 	sendchar('s');
 1387               		.loc 1 1014 0
 1388 05d6 83E7      		ldi r24,lo8(115)
 1389 05d8 0E94 0000 		call sendchar
 1390               	.LVL143:
1015:bootSAH_8.c   **** 	sendchar('a');
 1391               		.loc 1 1015 0
 1392 05dc 81E6      		ldi r24,lo8(97)
 1393 05de 0E94 0000 		call sendchar
 1394               	.LVL144:
1016:bootSAH_8.c   **** 	sendchar('h');
 1395               		.loc 1 1016 0
 1396 05e2 88E6      		ldi r24,lo8(104)
 1397 05e4 0E94 0000 		call sendchar
 1398               	.LVL145:
1017:bootSAH_8.c   **** 	sendchar(0x0d);
 1399               		.loc 1 1017 0
 1400 05e8 8DE0      		ldi r24,lo8(13)
 1401 05ea 0E94 0000 		call sendchar
 1402               	.LVL146:
1018:bootSAH_8.c   **** 	sendchar(0x0a);
 1403               		.loc 1 1018 0
 1404 05ee 8AE0      		ldi r24,lo8(10)
 1405 05f0 0E94 0000 		call sendchar
 1406               	.LVL147:
1019:bootSAH_8.c   **** 
1020:bootSAH_8.c   **** 	delay_ms(100);
 1407               		.loc 1 1020 0
 1408 05f4 84E6      		ldi r24,lo8(100)
 1409 05f6 90E0      		ldi r25,0
 1410 05f8 0E94 0000 		call delay_ms
 1411               	.LVL148:
1021:bootSAH_8.c   **** #endif
1022:bootSAH_8.c   **** 
1023:bootSAH_8.c   **** 
1024:bootSAH_8.c   **** #ifndef REMOVE_BOOTLOADER_LED
1025:bootSAH_8.c   **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
 1412               		.loc 1 1025 0
 1413 05fc 2698      		cbi 0x4,6
1026:bootSAH_8.c   **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 1414               		.loc 1 1026 0
 1415 05fe 2E98      		cbi 0x5,6
1027:bootSAH_8.c   **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1028:bootSAH_8.c   **** 	delay_ms(100);							// delay after exit
 1416               		.loc 1 1028 0
 1417 0600 84E6      		ldi r24,lo8(100)
 1418 0602 90E0      		ldi r25,0
 1419 0604 0E94 0000 		call delay_ms
 1420               	.LVL149:
1029:bootSAH_8.c   **** #endif
1030:bootSAH_8.c   **** 
1031:bootSAH_8.c   **** 
1032:bootSAH_8.c   **** 	asm volatile ("nop");			// wait until port has changed
 1421               		.loc 1 1032 0
 1422               	/* #APP */
 1423               	 ;  1032 "bootSAH_8.c" 1
 1424 0608 0000      		nop
 1425               	 ;  0 "" 2
1033:bootSAH_8.c   **** 
1034:bootSAH_8.c   **** 	/*
1035:bootSAH_8.c   **** 	 * Now leave bootloader
1036:bootSAH_8.c   **** 	 */
1037:bootSAH_8.c   **** 
1038:bootSAH_8.c   **** 	UART_STATUS_REG	&=	0xfd;
 1426               		.loc 1 1038 0
 1427               	/* #NOAPP */
 1428 060a 8091 C000 		lds r24,192
 1429 060e 8D7F      		andi r24,lo8(-3)
 1430 0610 8093 C000 		sts 192,r24
 1431               	.L85:
1039:bootSAH_8.c   **** 	boot_rww_enable_safe();				// enable application section
 1432               		.loc 1 1039 0 discriminator 1
 1433 0614 07B6      		in __tmp_reg__,0x37
 1434 0616 00FC      		sbrc __tmp_reg__,0
 1435 0618 00C0      		rjmp .L85
 1436               	.L86:
 1437               		.loc 1 1039 0 is_stmt 0 discriminator 3
 1438 061a F999      		sbic 0x1f,1
 1439 061c 00C0      		rjmp .L86
 1440               		.loc 1 1039 0 discriminator 4
 1441 061e 81E1      		ldi r24,lo8(17)
 1442               	/* #APP */
 1443               	 ;  1039 "bootSAH_8.c" 1
 1444 0620 8093 5700 		sts 87, r24
 1445 0624 E895      		spm
 1446               		
 1447               	 ;  0 "" 2
1040:bootSAH_8.c   **** 
1041:bootSAH_8.c   **** 
1042:bootSAH_8.c   **** 	asm volatile(
 1448               		.loc 1 1042 0 is_stmt 1 discriminator 4
 1449               	 ;  1042 "bootSAH_8.c" 1
 1450 0626 EE27      		clr	r30		
 1451 0628 FF27      		clr	r31		
 1452 062a 0994      		ijmp	
 1453               		
 1454               	 ;  0 "" 2
 1455               	/* #NOAPP */
 1456               	.L87:
 1457 062c 00C0      		rjmp .L87
 1458               	.LVL150:
 1459               	.L90:
 628:bootSAH_8.c   **** 						}
 1460               		.loc 1 628 0
 1461 062e 80E0      		ldi r24,0
 1462 0630 00C0      		rjmp .L24
 1463               	.LVL151:
 1464               	.L91:
 1465 0632 1901      		movw r2,r18
 637:bootSAH_8.c   **** 						}
 1466               		.loc 1 637 0
 1467 0634 86E0      		ldi r24,lo8(6)
 1468               	.LVL152:
 1469 0636 00C0      		rjmp .L24
 1470               		.cfi_endproc
 1471               	.LFE17:
 1473               		.section	.rodata
 1476               	CSWTCH.26:
 1477 0000 0F        		.byte	15
 1478 0001 02        		.byte	2
 1479 0002 0A        		.byte	10
 1480               	.global	app_start
 1481               		.section .bss
 1484               	app_start:
 1485 0000 0000      		.zero	2
 1486               		.text
 1487               	.Letext0:
 1488               		.file 3 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\st
 1489               		.file 4 "e:\\programfiles\\atmelstudio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\av
DEFINED SYMBOLS
                            *ABS*:00000000 bootSAH_8.c
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:2      *ABS*:0000003e __SP_H__
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:3      *ABS*:0000003d __SP_L__
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:4      *ABS*:0000003f __SREG__
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:7      *ABS*:00000001 __zero_reg__
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:12     .text:00000000 sendchar
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:42     .init9:00000000 __jumpMain
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:53     *ABS*:000021ff __stack
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:139    .text.startup:00000000 main
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:92     .text:00000018 delay_ms
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:1484   .bss:00000000 app_start
C:\Users\supun\AppData\Local\Temp\cciQSMJT.s:1476   .rodata:00000000 CSWTCH.26

UNDEFINED SYMBOLS
__udivmodsi4
__bswapsi2
eeprom_write_byte
__do_copy_data
__do_clear_bss
